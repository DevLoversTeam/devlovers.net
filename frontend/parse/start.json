[
  {
    "question": "1. Що таке CSS? І навіщо він використовується?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "CSS (Cascading Style Sheets) — це мова стилів для опису вигляду веб-сторінок. Використовується для розмітки елементів на сторінці, таких як шрифти, кольори, відступи, позиціонування та інші візуальні аспекти. CSS дозволяє відокремити контент (HTML) від стилів, що полегшує підтримку та зміну вигляду сайту."
          }
        ]
      }
    ]
  },
  {
    "question": "2. Що таке каскадність у CSS??",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Каскадність у CSS — це механізм, який визначає, як застосовуються стилі до елементів веб-сторінки, якщо для одного елемента задано кілька різних стилів із різних джерел або рівнів. Вона дозволяє браузеру вирішити, які стилі будуть мати вищий пріоритет і застосовуватися в кінцевому результаті."
          }
        ]
      }
    ]
  },
  {
    "question": "3. Які є способи підключення CSS до HTML-документу?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вбудовані стилі (inline) — напряму в HTML-тегах через атрибут "
              },
              {
                "text": "style",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Внутрішні стилі — у секції "
              },
              {
                "text": "<style>...</style> ",
                "code": true
              },
              {
                "text": " всередині HTML-документа."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зовнішні стилі — у CSS-файлах, підключених через "
              },
              {
                "text": "<link rel=”stylesheet” href=”styles.css”>",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "@import",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "4. Що таке CSS-селектори? Наведіть приклади.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "CSS-селектори використовуються для вибору HTML-елементів, до яких застосовуються стилі."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклади:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "За тегом: "
              },
              {
                "text": "h1 { color: red; }",
                "code": true
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "За класом: "
              },
              {
                "text": ".button { background: blue; }",
                "code": true
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "За ID: "
              },
              {
                "text": "#header { padding: 10px; }",
                "code": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Комбіновані:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Дочірні: "
              },
              {
                "text": "ul > li { margin: 5px; }",
                "code": true
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Нащадки: "
              },
              {
                "text": "div p { font-size: 14px; }",
                "code": true
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Атрибути: "
              },
              {
                "text": "[type=\"text\"] { border: 1px solid gray; }",
                "code": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдокласи:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "a:hover { color: green; }",
                "code": true
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":nth-child(2) { font-weight: bold; }",
                "code": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдоелементи:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "p::first-line { text-transform: uppercase; }",
                "code": true
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "5. Як працює наслідування в CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Наслідування в CSS дозволяє деяким властивостям автоматично передаватися від батьківського елемента до дочірніх."
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Особливості:",
                "bold": true
              }
            ]
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Автоматично наслідуються тільки текстові та декоративні властивості:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "color",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "font",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "visibility",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "line-height",
            "code": true
          },
          {
            "text": " тощо."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Не наслідуються автоматично властивості, що впливають на коробку (box model):"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "margin",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "padding",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "border",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "width",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "heigh",
            "code": true
          },
          {
            "text": "t тощо."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Контроль наслідування:",
            "bold": true
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Примусове наслідування:",
                "bold": true
              },
              {
                "text": " використовуйте значення inherit."
              },
              {
                "type": "code",
                "language": "css",
                "content": "   p {\n     border: inherit;\n   }"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Відміна наслідування:",
                "bold": true
              },
              {
                "text": " значення initial скидає властивість до початкового (згідно стандарту)."
              },
              {
                "type": "code",
                "language": "css",
                "content": "   p {\n     color: initial;\n   }"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "6. Що таке «модель коробки» (box model) в CSS і як її можна змінити?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "«Модель коробки» (box model) визначає, як розміри елемента розраховуються в CSS. Вона складається з:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Content:",
                "bold": true
              },
              {
                "text": " Вміст елемента (текст, зображення)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Padding:",
                "bold": true
              },
              {
                "text": " Внутрішній відступ між вмістом і рамкою."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Border:",
                "bold": true
              },
              {
                "text": " Рамка навколо padding."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Margin:",
                "bold": true
              },
              {
                "text": " Зовнішній відступ між елементом і сусідніми елементами."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Розрахунок ширини та висоти:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "За замовчуванням:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "Width/Height = Content + Padding + Border"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зміна моделі коробки:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовуйте властивість box-sizing:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "content-box (за замовчуванням):"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Ширина/висота включає лише вміст. Padding і border додаються до загального розміру."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "box-sizing: content-box;"
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "border-box:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Ширина/висота включають вміст, padding і border (зручніше для макетів)."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "box-sizing: border-box;"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "* {\n  box-sizing: border-box;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Це допомагає уникнути помилок у розмітці."
          }
        ]
      }
    ]
  },
  {
    "question": "7. У чому різниця між margin і padding?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Різниця між margin і padding:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Розташування:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "margin",
            "code": true
          },
          {
            "text": " створює зовнішній відступ між елементом і сусідніми елементами. "
          },
          {
            "text": "padding",
            "code": true
          },
          {
            "text": " створює внутрішній відступ між вмістом елемента і його рамкою (border)."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вплив на фон:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "margin",
            "code": true
          },
          {
            "text": " не впливає на фон елемента; простір залишається прозорим. "
          },
          {
            "text": "padding",
            "code": true
          },
          {
            "text": " є частиною елемента, тому фон розтягується на область padding."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Колізія (margin collapsing):"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "margin",
            "code": true
          },
          {
            "text": " сусідніх блоків може \"зливатися\" в один (найбільший). "
          },
          {
            "text": "padding",
            "code": true
          },
          {
            "text": " не зливається; завжди додається до внутрішнього простору."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "div {\n  margin: 20px; /* Відступ від інших елементів */\n  padding: 20px; /* Відступ між вмістом і рамкою */\n  background-color: lightblue;\n}"
      }
    ]
  },
  {
    "question": "8. Що таке Flexbox?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Flexbox (Flexible Box Layout) — це CSS-модель розташування елементів, яка забезпечує гнучке вирівнювання та розподіл простору в межах контейнера, навіть якщо розміри елементів невідомі або змінюються."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Основні поняття:",
            "bold": true
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Flex-контейнер:",
            "bold": true
          },
          {
            "text": " Батьківський елемент, на який застосовується "
          },
          {
            "text": "display: flex;",
            "code": true
          },
          {
            "text": ". "
          },
          {
            "text": "Flex-елементи:",
            "bold": true
          },
          {
            "text": " Дочірні елементи flex-контейнера."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Основні властивості Flexbox:",
            "bold": true
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для контейнера:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "flex-direction",
                "code": true
              },
              {
                "text": ": Напрямок розташування елементів ("
              },
              {
                "text": "row",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "row-reverse",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "column",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "column-reverse",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "justify-content",
                "code": true
              },
              {
                "text": ": Горизонтальне вирівнювання елементів ("
              },
              {
                "text": "flex-start",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "center",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "space-between",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "space-around",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "space-evenly",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "align-items",
                "code": true
              },
              {
                "text": ": Вертикальне вирівнювання елементів ("
              },
              {
                "text": "stretch",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "center",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "flex-start",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "flex-end",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "baseline",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "align-content",
                "code": true
              },
              {
                "text": ": Вирівнювання рядків у багаторядковому контейнері ("
              },
              {
                "text": "stretch",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "center",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "space-between",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "flex-wrap",
                "code": true
              },
              {
                "text": ": Дозволяє елементам переноситися ("
              },
              {
                "text": "nowrap",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "wrap",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "wrap-reverse",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для елементів:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "flex-grow",
                "code": true
              },
              {
                "text": ": Як елемент збільшується вільним простором."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "flex-shrink",
                "code": true
              },
              {
                "text": ": Як елемент зменшується при нестачі простору."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "flex-basis",
                "code": true
              },
              {
                "text": ": Базовий розмір елемента перед розподілом простору."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "align-self",
                "code": true
              },
              {
                "text": ": Вирівнювання конкретного елемента всередині контейнера."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Приклад:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "  .container {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n\n  .item {\n    flex: 1; /* Рівний розподіл простору */\n  }"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "9. Що таке Grid?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "CSS Grid — це потужна система розмітки, яка дозволяє створювати двовимірні сітки для розташування елементів як по горизонталі, так і по вертикалі."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Основні поняття:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Grid-контейнер:",
                "bold": true
              },
              {
                "text": " Елемент, на який застосовується "
              },
              {
                "text": "display: grid;",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Grid-елементи:",
                "bold": true
              },
              {
                "text": " Дочірні елементи grid-контейнера."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Лінії сітки:",
                "bold": true
              },
              {
                "text": " Вертикальні та горизонтальні межі, що ділять сітку на осередки."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Треки:",
                "bold": true
              },
              {
                "text": " Рядки ("
              },
              {
                "text": "rows",
                "code": true
              },
              {
                "text": ") і колонки ("
              },
              {
                "text": "columns",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Області:",
                "bold": true
              },
              {
                "text": " Прямокутні зони, об'єднані з кількох осередків."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Основні властивості Grid:",
                "bold": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для контейнера:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "grid-template-rows",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "grid-template-columns",
                "code": true
              },
              {
                "text": ": Задають кількість і розміри рядків та колонок."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "grid-template-areas",
                "code": true
              },
              {
                "text": ": Іменовані області для організації елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "gap",
                "code": true
              },
              {
                "text": " (або "
              },
              {
                "text": "row-gap/column-gap",
                "code": true
              },
              {
                "text": "): Відступи між рядками та колонками."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "justify-items",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "align-items",
                "code": true
              },
              {
                "text": ": Вирівнювання елементів у клітинках."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "justify-content",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "align-content",
                "code": true
              },
              {
                "text": ": Вирівнювання всієї сітки в контейнері."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для елементів:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "grid-column",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "grid-row",
                "code": true
              },
              {
                "text": ": Позиціювання по колонках і рядках."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "grid-area",
                "code": true
              },
              {
                "text": ": Розміщення в іменованій області."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "place-self",
                "code": true
              },
              {
                "text": ": Індивідуальне вирівнювання елемента."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  display: grid;\n  grid-template-columns: 1fr 2fr; /* Дві колонки: 1 частина та 2 частини */\n  grid-template-rows: 100px auto; /* Рядок фіксованої висоти і автоматичний */\n  gap: 10px;\n}\n\n.item1 {\n  grid-column: 1 / 3; /* Займає дві колонки */\n}\n\n.item2 {\n  grid-row: 2; /* Розташований у другому рядку */\n}"
      }
    ]
  },
  {
    "question": "10. Що таке медіазапити та як їх використовувати?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Медіазапити — це умови, які дозволяють застосовувати різні стилі в залежності від характеристик пристрою (наприклад, розміру екрану, орієнтації). Вони використовуються в CSS через правило @media."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад медіазапиту для адаптивного дизайну:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "/* Стилі для мобільних пристроїв */\n@media (max-width: 768px) {\n  body {\n    background-color: lightblue;\n  }\n}\n\n/* Стилі для десктопів */\n@media (min-width: 769px) {\n  body {\n    background-color: lightgreen;\n  }\n}"
      }
    ]
  },
  {
    "question": "11. Як можна приховати елемент за допомогою CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Щоб приховати елемент за допомогою CSS, можна використовувати:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "display: none;",
                "code": true
              },
              {
                "text": " — видаляє елемент з потоку документа. Він не займає місця на сторінці і з ним не можна взаємодіяти."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "visibility: hidden;",
                "code": true
              },
              {
                "text": " — елемент стає невидимим, але зберігає своє місце на сторінці."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "opacity: 0;",
                "code": true
              },
              {
                "text": " — робить елемент прозорим, але він залишається видимим і займає місце на сторінці."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "12. Як можна зробити лого посередині екрана?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Щоб розмістити лого посередині екрана, можна використати такі способи:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Flexbox:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   body,\n   html {\n     height: 100%;\n     margin: 0;\n     display: flex;\n     justify-content: center;\n     align-items: center;\n   }\n\n   .logo {\n     /* стилі лого */\n   }"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Grid:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   body,\n   html {\n     height: 100%;\n     margin: 0;\n     display: grid;\n     place-items: center;\n   }\n\n   .logo {\n     /* стилі лого */\n   }"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Absolute позиціювання:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   body,\n   html {\n     height: 100%;\n     margin: 0;\n     position: relative;\n   }\n\n   .logo {\n     position: absolute;\n     top: 50%;\n     left: 50%;\n     transform: translate(-50%, -50%);\n   }"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "13. Як розмістити хрестик для закриття справа зверху елемента?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Щоб розмістити хрестик для закриття в правому верхньому куті елемента, можна використати абсолютне позиціювання:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  position: relative; /* щоб хрестик позиціонувався відносно контейнера */\n}\n\n.close-btn {\n  position: absolute;\n  top: 10px; /* відстань від верхнього краю */\n  right: 10px; /* відстань від правого краю */\n  cursor: pointer; /* щоб курсор змінювався при наведенні */\n}"
      },
      {
        "type": "code",
        "language": "html",
        "content": "<div class=\"container\">\n  <div class=\"close-btn\">&times;</div>\n  <!-- інший контент -->\n</div>"
      }
    ]
  },
  {
    "question": "14. Як зробити останній елемент списку червоним, незалежно від довжини списку без JS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб зробити останній елемент списку червоним без JavaScript, можна використати псевдоклас "
              },
              {
                "text": ":last-child:",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Це правило зробить останній елемент у будь-якому списку (незалежно від його довжини) червоним."
              },
              {
                "type": "code",
                "language": "css",
                "content": "  ul li:last-child {\n    color: red;\n  }"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Це правило зробить останній елемент у будь-якому списку (незалежно від його довжини) червоним."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "15. Які є можливості задати колір?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "У CSS є кілька способів задати колір:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Ім’я кольору:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   color: red;"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Шістнадцятковий код:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   color: #ff0000; /* червоний */"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "RGB (Red, Green, Blue):"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   color: rgb(255, 0, 0); /* червоний */"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "RGBA (Red, Green, Blue, Alpha):"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   color: rgba(255, 0, 0, 0.5); /* червоний з прозорістю */"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "HSL (Hue, Saturation, Lightness):"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   color: hsl(0, 100%, 50%); /* червоний */"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "HSLA (Hue, Saturation, Lightness, Alpha):"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   color: hsla(0, 100%, 50%, 0.5); /* червоний з прозорістю */"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Ключові слова прозорості:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "   color: transparent; /* прозорий */"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Ці способи дозволяють вибирати колір за різними параметрами: від прямого опису кольору до використання прозорості або відтінків."
          }
        ]
      }
    ]
  },
  {
    "question": "16. Що таке z-index? Чи кожен елемент його має?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": " — це властивість CSS, яка визначає порядок накладання елементів по осі Z (глибина, перетин елементів). Елементи з більшим "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": " накладаються поверх елементів з меншим значенням."
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Особливості:",
                "bold": true
              }
            ]
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Тільки для позиційованих елементів: "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " працює, якщо елемент має "
              },
              {
                "text": "position",
                "code": true
              },
              {
                "text": ": "
              },
              {
                "text": "relative",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "absolute",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "fixed",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "sticky",
                "code": true
              },
              {
                "text": ". Без цього "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " ігнорується."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Значення за замовчуванням: Якщо "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " не задано, значення за замовчуванням — "
              },
              {
                "text": "auto",
                "code": true
              },
              {
                "text": ". У такому випадку порядок накладання визначається порядком у DOM."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Може бути від’ємним: Елементи з від’ємним "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " можуть накладатися позаду батьківських елементів."
              },
              {
                "type": "bulletList",
                "children": [
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Приклад:"
                      },
                      {
                        "type": "code",
                        "language": "css",
                        "content": "  .div1 {\n    position: relative;\n    z-index: 10; /* цей елемент буде поверх */\n  }\n\n  .div2 {\n    position: relative;\n    z-index: 5; /* цей елемент буде під div1 */\n  }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "17. Які переваги і недоліки використання CSS-препроцесорів?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Переваги CSS-препроцесорів:",
            "bold": true
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Змінні:",
                "bold": true
              },
              {
                "text": " Легко створювати глобальні змінні для кольорів, шрифтів, розмірів."
              },
              {
                "type": "code",
                "language": "css",
                "content": "   $primary-color: #3498db;\n\n   body {\n     color: $primary-color;\n   }"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вкладеність:",
                "bold": true
              },
              {
                "text": " Зручний запис стилів для вкладених елементів."
              },
              {
                "type": "code",
                "language": "css",
                "content": "   nav {\n     ul {\n       li {\n         a {\n           color: #000;\n         }\n       }\n     }\n   }"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Міксіни:",
                "bold": true
              },
              {
                "text": " Повторно використовувані блоки коду."
              },
              {
                "type": "code",
                "language": "css",
                "content": "   @mixin flex-center {\n     display: flex;\n     justify-content: center;\n     align-items: center;\n   }\n\n   div {\n     @include flex-center;\n   }"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Функції:",
                "bold": true
              },
              {
                "text": " Обчислення прямо в стилях."
              },
              {
                "type": "code",
                "language": "css",
                "content": "   width: calc(100% - 50px);"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Управління кодом:",
                "bold": true
              },
              {
                "text": " Імпорт окремих файлів ("
              },
              {
                "text": "@import",
                "code": true
              },
              {
                "text": "), що полегшує підтримку великого проекту."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Недоліки CSS-препроцесорів:",
            "bold": true
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Складність налаштування:",
                "bold": true
              },
              {
                "text": " Потрібно встановлювати додаткові інструменти (наприклад, компілятор для SCSS або LESS)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Продуктивність:",
                "bold": true
              },
              {
                "text": " Велика кількість вкладеностей або міксінів може ускладнити генерований CSS і вплинути на швидкість."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Залежність:",
                "bold": true
              },
              {
                "text": " Знання синтаксису препроцесора необов'язково підтримується усіма розробниками в команді."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Дебагінг:",
                "bold": true
              },
              {
                "text": " Згенерований CSS може бути складніше дебажити, якщо немає source maps."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використання залежить від розміру проекту та необхідності складних стилів. Для великих проектів переваги переважують недоліки."
          }
        ]
      }
    ]
  },
  {
    "question": "18. Для чого існують різні рівні заголовків, якщо розмір можна встановити стилями?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Рівні заголовків ("
          },
          {
            "text": "<h1> – <h6>",
            "code": true
          },
          {
            "text": ") мають інше призначення, окрім визначення розміру. Їхня основна функція — структуризація контенту для семантики та доступності:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Семантика:",
                "bold": true
              },
              {
                "text": " Заголовки формують ієрархію документа. Наприклад:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "<h1>",
            "code": true
          },
          {
            "text": " — головна тема сторінки. "
          },
          {
            "text": "<h2>",
            "code": true
          },
          {
            "text": " — підрозділ теми "
          },
          {
            "text": "<h1>",
            "code": true
          },
          {
            "text": ". "
          },
          {
            "text": "<h3>",
            "code": true
          },
          {
            "text": " — підрозділ "
          },
          {
            "text": "<h2>",
            "code": true
          },
          {
            "text": ", і так далі."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "SEO:",
                "bold": true
              },
              {
                "text": " Пошукові системи (Google, Bing) використовують заголовки для розуміння структури і змісту сторінки. Коректна ієрархія заголовків підвищує релевантність сторінки."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Доступність:",
                "bold": true
              },
              {
                "text": " Екранні читачі для людей із порушеннями зору використовують заголовки для навігації по сторінці."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Стандарти:",
                "bold": true
              },
              {
                "text": " Використання заголовків за призначенням робить код зрозумілим для інших розробників."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Розмір заголовків можна стилізувати за допомогою CSS, але правильне використання тегів забезпечує краще розуміння і роботу сторінки."
          }
        ]
      }
    ]
  },
  {
    "question": "19. Які є варіанти позиціонування елемента на сторінці?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "У CSS є кілька варіантів позиціонування елементів:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "static",
                "code": true
              },
              {
                "text": " (за замовчуванням): Елемент розташовується в потоці документа відповідно до порядку в HTML. Немає можливості змінювати його положення через властивості top, right, bottom, left."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "relative",
                "code": true
              },
              {
                "text": ": Елемент залишається в потоці документа, але його положення можна змінити відносно початкової позиції за допомогою top, right, bottom, left."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "absolute",
                "code": true
              },
              {
                "text": ": Елемент вилучається з потоку і позиціонується відносно найближчого батьківського елемента з позиціюванням (relative, absolute, fixed). Якщо такого немає, то відносно всього документа."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "fixed",
                "code": true
              },
              {
                "text": ": Елемент вилучається з потоку і закріплюється відносно вікна браузера. Його положення не змінюється при прокручуванні сторінки."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "sticky",
                "code": true
              },
              {
                "text": ": Комбінація relative і fixed. Елемент позиціонується відносно потоку документа, поки не досягне заданого порогу (top, bottom тощо), після чого \"прилипає\" до цього порогу при прокручуванні."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "inherit",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "initial",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "unset",
                "code": true
              },
              {
                "text": ":"
              },
              {
                "type": "bulletList",
                "children": [
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "inherit — наслідує значення від батьківського елемента."
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "initial — скидає до значення за замовчуванням (static)."
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "unset — застосовує inherit або initial залежно від контексту."
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Кожен варіант використовується залежно від завдання: від базового розташування до складного позиціонування в макетах."
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "20. Які бувають види display? Який використовуєте найчастіше? У чому особливість inline-block?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Основні види display в CSS:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`block`",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елемент займає всю ширину батьківського контейнера."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Починається з нового рядка."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Можна задавати ширину, висоту, внутрішні/зовнішні відступи."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Приклад: "
              },
              {
                "text": "<div>",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "<p>",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`inline`",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елемент розташовується в одному рядку з іншими елементами."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Неможливо задавати ширину та висоту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Відступи (margin/padding) впливають лише на внутрішній простір."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Приклад: "
              },
              {
                "text": "<span>",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "<a>",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`inline-block`",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Поєднує особливості block і inline."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елемент розташовується в рядку, але дозволяє задавати ширину, висоту, відступи."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зручний для створення кнопок, тегів."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`flex`",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Відображає елемент як контейнер для гнучкого компонування дочірніх елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується для вирівнювання та розподілу простору між елементами."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`grid`",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Задає контейнер для компонування в двовимірній сітці."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зручний для складних макетів."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`none`",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елемент не відображається на сторінці."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`inline-flex` / `inline-grid`",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Аналогічні flex і grid, але зберігають властивості inline."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`table` / `table-row` / `table-cell`",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елементи імітують поведінку таблиць HTML."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Найчастіше використовується:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "block, inline-block, flex, і grid — залежно від завдань."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "inline-block популярний для створення кнопок або елементів меню, які потрібно розташувати в рядок, але контролювати їх розміри."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Особливість inline-block:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елементи розташовуються в рядок, як inline, але поводяться як block, дозволяючи задавати ширину, висоту, та всі відступи."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Проблема: між елементами може з’явитися проміжок (через пробіли в HTML)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Виправляється:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Видаленням пробілів у коді."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Встановленням font-size: 0 для батьківського контейнера."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "21. Що таке CSS-правило?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "CSS-правило складається з селектора та блоку декларацій. Селектор визначає, до яких елементів на сторінці застосовуються стилі, а блок декларацій містить властивості та їх значення, що визначають вигляд цих елементів. Наприклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "p {\n  color: red;\n  font-size: 16px;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Тут "
          },
          {
            "text": "p",
            "code": true
          },
          {
            "text": " — селектор (вибирає всі абзаци), а в блоці декларацій вказано, що текст буде червоним і розмір шрифту 16px."
          }
        ]
      }
    ]
  },
  {
    "question": "22. Варіанти додавання CSS стилів на сторінку?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Inline CSS:",
                "bold": true
              },
              {
                "text": " Стилі додаються безпосередньо до HTML елементів через атрибут "
              },
              {
                "text": "style",
                "code": true
              },
              {
                "text": "."
              },
              {
                "type": "code",
                "language": "html",
                "content": "<p style=\"color: red; font-size: 16px;\">Text</p>"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Internal CSS:",
                "bold": true
              },
              {
                "text": " Стилі додаються в "
              },
              {
                "text": "<style>",
                "code": true
              },
              {
                "text": " тег в межах "
              },
              {
                "text": "<head>",
                "code": true
              },
              {
                "text": " секції HTML документа."
              },
              {
                "type": "code",
                "language": "html",
                "content": "<style>\n  p {\n    color: red;\n    font-size: 16px;\n  }\n</style>"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "External CSS:",
                "bold": true
              },
              {
                "text": " Стилі прописуються в окремому CSS файлі, який підключається до HTML через тег "
              },
              {
                "text": "<link>",
                "code": true
              },
              {
                "text": "."
              },
              {
                "type": "code",
                "language": "html",
                "content": "<link rel=\"stylesheet\" href=\"styles.css\" />"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Ці варіанти відрізняються за пріоритетом і зручністю для масштабування проектів."
          }
        ]
      }
    ]
  },
  {
    "question": "23. Типи позиціонування у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "static:",
                "bold": true
              },
              {
                "text": " За замовчуванням для всіх елементів. Елементи розташовуються в нормальному потоці документа (тобто, згідно з їх порядком у HTML)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "relative:",
                "bold": true
              },
              {
                "text": " Елемент розташовується відносно його початкового положення в потоці. Можна використовувати властивості "
              },
              {
                "text": "top",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "right",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "bottom",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "left",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "absolute:",
                "bold": true
              },
              {
                "text": " Елемент позиціонується відносно найближчого батьківського елемента з позиціонуванням (не "
              },
              {
                "text": "static",
                "code": true
              },
              {
                "text": "). Якщо такого немає, то відносно документа."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "fixed:",
                "bold": true
              },
              {
                "text": " Елемент позиціонується відносно вікна браузера, тобто він залишатиметься на тому ж місці при прокручуванні сторінки."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "sticky:",
                "bold": true
              },
              {
                "text": " Елемент поводиться як relative до певного моменту, після чого стає fixed, коли прокручують сторінку до заданого порогу."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "24. Блокова модель CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Блокова модель CSS (Box Model) описує, як елементи розташовуються на веб-сторінці та як обчислюються їх розміри. Вона включає такі компоненти:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Content (Контент):",
                "bold": true
              },
              {
                "text": " Це основна частина елемента, де міститься текст або інші медіа. Розміри контенту визначаються властивостями "
              },
              {
                "text": "width",
                "code": true
              },
              {
                "text": " і "
              },
              {
                "text": "height",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Padding (Відступи):",
                "bold": true
              },
              {
                "text": " Простір між контентом і межами елемента (border). Відступи додаються всередині елемента. Властивості: "
              },
              {
                "text": "padding-top",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "padding-right",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "padding-bottom",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "padding-left",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Border (Межа):",
                "bold": true
              },
              {
                "text": " Лінія, яка оточує елемент. Може мати товщину, стиль та колір. Властивості: "
              },
              {
                "text": "border-width",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "border-style",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "border-color",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Margin (Зовнішній відступ):",
                "bold": true
              },
              {
                "text": " Простір між елементом і його сусідніми елементами. Відступи додаються зовні елемента. Властивості: "
              },
              {
                "text": "margin-top",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "margin-right",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "margin-bottom",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "margin-left",
                "code": true
              },
              {
                "text": "."
              },
              {
                "type": "bulletList",
                "children": [
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Коли вказуються розміри елемента через "
                      },
                      {
                        "text": "width",
                        "code": true
                      },
                      {
                        "text": " і "
                      },
                      {
                        "text": "height",
                        "code": true
                      },
                      {
                        "text": ", вони зазвичай враховують тільки "
                      },
                      {
                        "text": "content",
                        "code": true
                      },
                      {
                        "text": ", але при додаванні "
                      },
                      {
                        "text": "padding",
                        "code": true
                      },
                      {
                        "text": ", "
                      },
                      {
                        "text": "border",
                        "code": true
                      },
                      {
                        "text": " і "
                      },
                      {
                        "text": "margin",
                        "code": true
                      },
                      {
                        "text": ", розміри елемента змінюються."
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Важливо знати, що властивість "
                      },
                      {
                        "text": "box-sizing",
                        "code": true
                      },
                      {
                        "text": " дозволяє визначати, як враховуються ці величини при обчисленні розмірів елемента:"
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "content-box",
                        "code": true
                      },
                      {
                        "text": " (за замовчуванням): розміри елемента — це тільки контент."
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "border-box",
                        "code": true
                      },
                      {
                        "text": ": розміри елемента враховують також "
                      },
                      {
                        "text": "padding",
                        "code": true
                      },
                      {
                        "text": " та "
                      },
                      {
                        "text": "border",
                        "code": true
                      },
                      {
                        "text": "."
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "25. Що таке селектор? І які селектори є?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Селектор",
            "bold": true
          },
          {
            "text": " у CSS — це частина правила, яка визначає, до яких елементів на сторінці застосовуються стилі. Селектори дозволяють вибирати HTML елементи для застосування стилів."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Основні типи селекторів:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Типовий селектор (Type selector):",
                "bold": true
              },
              {
                "text": " Вибирає елементи за їх тегом."
              },
              {
                "type": "code",
                "language": "css",
                "content": "p {\n  color: red;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Класовий селектор (Class selector):",
                "bold": true
              },
              {
                "text": " Вибирає елементи за класом, починається з крапки."
              },
              {
                "type": "code",
                "language": "css",
                "content": ".my-class {\n  color: blue;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Ідентифікатор (ID selector):",
                "bold": true
              },
              {
                "text": " Вибирає елементи за ідентифікатором, починається з решітки."
              },
              {
                "type": "code",
                "language": "css",
                "content": "#my-id {\n  color: green;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Атрибутний селектор (Attribute selector):",
                "bold": true
              },
              {
                "text": " Вибирає елементи за значенням їх атрибутів."
              },
              {
                "type": "code",
                "language": "css",
                "content": "input[type='text'] {\n  border: 1px solid black;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Псевдоклас (Pseudo-class selector):",
                "bold": true
              },
              {
                "text": " Вибирає елементи, що знаходяться в певному стані."
              },
              {
                "type": "code",
                "language": "css",
                "content": "a:hover {\n  color: red;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Псевдоелемент (Pseudo-element selector):",
                "bold": true
              },
              {
                "text": " Вибирає частини елементів, наприклад, перший рядок або першу літеру."
              },
              {
                "type": "code",
                "language": "css",
                "content": "p::first-letter {\n  font-size: 2em;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Комбінатори (Combinators):",
                "bold": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "_Descendant_",
            "bold": true
          },
          {
            "text": " (потомок): Вибирає елементи, які є нащадками іншого елемента."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "div p {\n  color: purple;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "_Child_",
            "bold": true
          },
          {
            "text": " (прямий нащадок): Вибирає елементи, що є прямими дітьми іншого елемента."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "div > p {\n  color: yellow;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "_Adjacent sibling_",
            "bold": true
          },
          {
            "text": " (сусід): Вибирає елемент, який йде безпосередньо після іншого."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "h1 + p {\n  margin-top: 0;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "_General sibling_",
            "bold": true
          },
          {
            "text": " (загальний сусід): Вибирає елементи, які є сусідами певного елемента."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "h1 ~ p {\n  color: orange;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Це основні типи селекторів, що використовуються для вибору та стилізації елементів."
          }
        ]
      }
    ]
  },
  {
    "question": "26. Різниця між Reset.css та Normalize.css?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Reset.css",
            "bold": true
          },
          {
            "text": " і "
          },
          {
            "text": "Normalize.css",
            "bold": true
          },
          {
            "text": " — це два різні підходи до управління стилями за замовчуванням у браузерах, але з різними цілями:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Reset.css:",
                "bold": true
              },
              {
                "text": "Мета:",
                "bold": true
              },
              {
                "text": " Видалити всі стилі браузера (включаючи відступи, поля, шрифти тощо), щоб почати з \"чистого аркуша\"."
              },
              {
                "text": "Результат:",
                "bold": true
              },
              {
                "text": " Все, що за замовчуванням задається браузером, скидається, і елементи стають однаковими в усіх браузерах. Це часто призводить до того, що потрібно вручну додавати стилі для базових елементів."
              },
              {
                "text": "Приклад:",
                "bold": true
              },
              {
                "type": "code",
                "language": "css",
                "content": "* {\n  margin: 0;\n  padding: 0;\n  border: 0;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Normalize.css:",
                "bold": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Мета:",
            "bold": true
          },
          {
            "text": " Зробити стилі браузерів більш однаковими, але не скидаючи їх повністю. Підтримує стандартні стилі для елементів, щоб забезпечити однаковий вигляд у всіх браузерах."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Результат:",
            "bold": true
          },
          {
            "text": " Зберігаються деякі стилі за замовчуванням, але вони нормалізуються для забезпечення консистентності між різними браузерами (наприклад, вирівнювання шрифтів, списки, таблиці)."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад:",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Основна різниця:",
            "bold": true
          },
          {
            "text": " Reset.css скидає всі стилі браузера до мінімуму, тоді як Normalize.css підтримує базові стилі, але нормалізує їх для більшої узгодженості між браузерами."
          }
        ]
      }
    ]
  },
  {
    "question": "27. Різниця між display: none та visibility: hidden?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "display: none",
            "code": true
          },
          {
            "text": " і "
          },
          {
            "text": "visibility: hidden",
            "code": true
          },
          {
            "text": " приховують елементи, але працюють по-різному:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "display: none",
            "code": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елемент зникає повністю зі сторінки."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Він не займає місця в макеті."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Інші елементи зміщуються так, ніби його не існувало."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Події (наприклад, кліки) не спрацьовують на ньому."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується для повного приховування елементів."
              },
              {
                "type": "code",
                "language": "css",
                "content": ".hidden {\n  display: none;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "visibility: hidden",
            "code": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елемент залишається на сторінці, але стає невидимим."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Він продовжує займати місце в макеті."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Інші елементи не зміщуються."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Події (наприклад, кліки) не спрацьовують, хоча елемент все ще є в DOM."
              },
              {
                "type": "code",
                "language": "css",
                "content": ".hidden {\n  visibility: hidden;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Різниця:",
            "bold": true
          },
          {
            "text": " "
          },
          {
            "text": "display: none",
            "code": true
          },
          {
            "text": " прибирає елемент повністю, а "
          },
          {
            "text": "visibility: hidden",
            "code": true
          },
          {
            "text": " залишає його місце, але робить невидимим."
          }
        ]
      }
    ]
  },
  {
    "question": "28. Різниця між блоковим та інлайновим елементами?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Блокові (block) та інлайнові (inline) елементи",
            "bold": true
          },
          {
            "text": " відрізняються способом відображення та впливом на структуру сторінки."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Блокові елементи (display: block)"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Починаються з нового рядка."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Автоматично займають всю доступну ширину (по горизонталі)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Можуть містити як інші блокові, так і інлайнові елементи."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Підтримують width, height, margin, padding."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклади:",
            "bold": true
          },
          {
            "text": " "
          },
          {
            "text": "<div>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<p>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<h1>-<h6>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<section>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<article>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<form>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<header>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<footer>",
            "code": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "div {\n  display: block;\n  width: 100%;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Інлайнові елементи (display: inline)"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Не починаються з нового рядка, розташовуються \"в потоці\" тексту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Ширина та висота залежать від вмісту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "width і height ігноруються (не можна змінювати вручну)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "margin та padding працюють тільки по горизонталі."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклади:",
            "bold": true
          },
          {
            "text": " "
          },
          {
            "text": "<span>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<a>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<strong>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<em>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<b>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<i>",
            "code": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "span {\n  display: inline;\n  color: red;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Різниця"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Блокові елементи займають всю ширину і формують окремий рядок."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Інлайнові елементи залишаються в потоці тексту та займають рівно стільки місця, скільки потрібно їх вмісту."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "29. Різниця між класом та ідентифікатором у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Клас ("
          },
          {
            "text": "class",
            "code": true
          },
          {
            "text": ") vs Ідентифікатор ("
          },
          {
            "text": "id",
            "code": true
          },
          {
            "text": ") у CSS"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Параметр"
            }
          ],
          [
            {
              "text": "Клас ("
            },
            {
              "text": "class",
              "code": true
            },
            {
              "text": ")"
            }
          ],
          [
            {
              "text": "Ідентифікатор ("
            },
            {
              "text": "id",
              "code": true
            },
            {
              "text": ")"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "Синтаксис"
              }
            ],
            [
              {
                "text": "Починається з "
              },
              {
                "text": ".",
                "code": true
              }
            ],
            [
              {
                "text": "Починається з "
              },
              {
                "text": "#",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "Призначення"
              }
            ],
            [
              {
                "text": "Використовується для групи елементів"
              }
            ],
            [
              {
                "text": "Призначається одному унікальному елементу"
              }
            ]
          ],
          [
            [
              {
                "text": "Повторне використання"
              }
            ],
            [
              {
                "text": "Може застосовуватися до кількох елементів"
              }
            ],
            [
              {
                "text": "Повинен бути унікальним на сторінці"
              }
            ]
          ],
          [
            [
              {
                "text": "Пріоритет у CSS"
              }
            ],
            [
              {
                "text": "Менший (0,0,1,0)"
              }
            ],
            [
              {
                "text": "Вищий (0,1,0,0)"
              }
            ]
          ],
          [
            [
              {
                "text": "HTML приклад"
              }
            ],
            [
              {
                "text": "<div class=\"box\"></div>",
                "code": true
              }
            ],
            [
              {
                "text": "<div id=\"unique-box\"></div>",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "CSS приклад"
              }
            ],
            [
              {
                "text": ".box { color: red; }",
                "code": true
              }
            ],
            [
              {
                "text": "#unique-box { color: blue; }",
                "code": true
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Різниця"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Класи використовуються для стилізації кількох елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "ID застосовується до одного унікального елемента (але можна порушити це правило)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "ID має вищий пріоритет, тому його важко перевизначити."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Класи краще використовувати для стилізації, ID — для JavaScript або унікальної ідентифікації."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "30. Що таке CSS спрайт? І для чого він використовується?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "CSS спрайт — це техніка, де кілька зображень об'єднуються в одне велике зображення, а потім через CSS задаються позиції фону для відображення різних частин цього зображення."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовується для зменшення кількості HTTP-запитів, що підвищує швидкість завантаження сторінки. Зазвичай застосовується для іконок, кнопок або інших маленьких зображень, що використовуються на сайті."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Ось приклад використання CSS спрайту:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Створення спрайта:",
                "bold": true
              },
              {
                "text": " У вас є декілька маленьких зображень (наприклад, іконки), які ви об'єднуєте в один великий файл sprite.png."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS для використання спрайта:",
                "bold": true
              },
              {
                "type": "code",
                "language": "css",
                "content": ".icon {\n  width: 50px;\n  height: 50px;\n  background-image: url('sprite.png');\n  display: inline-block;\n}\n\n.icon-facebook {\n  background-position: 0 0; /* Перша іконка в спрайті */\n}\n\n.icon-twitter {\n  background-position: -50px 0; /* Друга іконка в спрайті */\n}\n\n.icon-linkedin {\n  background-position: -100px 0; /* Третя іконка в спрайті */\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "HTML для іконок:",
                "bold": true
              },
              {
                "type": "code",
                "language": "html",
                "content": "<div class=\"icon icon-facebook\"></div>\n<div class=\"icon icon-twitter\"></div>\n<div class=\"icon icon-linkedin\"></div>"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "У цьому прикладі всі іконки завантажуються з одного файлу sprite.png, і за допомогою CSS background-position визначається, яка частина спрайту відображатиметься для кожної іконки."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Цей підхід вже не використовуеться в CSS, але для себе знати треба. 📝"
          }
        ]
      }
    ]
  },
  {
    "question": "31. Що таке вендорні префікси? І навіщо вони використовуються?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Вендорні префікси — це спеціальні префікси, які додаються до CSS властивостей для забезпечення підтримки нових або експериментальних функцій у різних браузерах. Вони використовуються, коли властивість або функція ще не є стандартом або коли браузери реалізують їх по-своєму."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад вендорних префіксів:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  -webkit-transform: rotate(\n    45deg\n  ); /* для браузерів на WebKit, таких як Chrome, Safari */\n  -moz-transform: rotate(45deg); /* для Firefox */\n  -ms-transform: rotate(45deg); /* для Internet Explorer */\n  transform: rotate(45deg); /* стандартна властивість */\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Вендорні префікси використовуються для забезпечення сумісності з різними браузерами, поки властивість не стане частиною офіційного стандарту CSS. Вони допомагають тестувати нові функції та забезпечують їх роботу на більшій кількості браузерів, поки всі вони не впровадять підтримку стандартних властивостей."
          }
        ]
      }
    ]
  },
  {
    "question": "32. Що таке псевдоелементи? І навіщо вони використовуються?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдоелементи — це конструкції в CSS, які дозволяють стилізувати частини елементів, які не мають власного HTML представлення. Вони дозволяють додавати стилі до таких частин елементів, як перший рядок тексту, вміст перед або після елемента, або створення декоративних елементів без необхідності змінювати HTML."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Основні псевдоелементи:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "::before",
                "code": true
              },
              {
                "text": " — додає вміст перед елементом."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "::after",
                "code": true
              },
              {
                "text": " — додає вміст після елемента."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "::first-letter",
                "code": true
              },
              {
                "text": " — стилізує першу букву тексту в елементі."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "::first-line",
                "code": true
              },
              {
                "text": " — стилізує перший рядок тексту в елементі."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад використання:",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "p::before {\n  content: '🔹 ';\n}\n\np::after {\n  content: ' 🔸';\n}\n\np::first-letter {\n  font-size: 2em;\n  color: red;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Застосування:",
            "bold": true
          },
          {
            "text": " Псевдоелементи використовуються для:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Додавання декоративних елементів без зміни HTML."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Створення візуальних ефектів (наприклад, стилізація першої літери або першого рядка)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Додавання контенту перед або після елемента, наприклад, іконок або текстових маркерів, без необхідності додавати додаткові теги в HTML."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "33. Що таке схлопування меж (margin collapsing)?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Схлопування меж (margin collapsing) — це явище в CSS, коли вертикальні відступи (margins) між сусідніми блоками або елементами \"зливаються\" в один, замість того, щоб відображатися окремо."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Це зазвичай відбувається в таких ситуаціях:",
            "bold": true
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Коли два сусідні блоки мають вертикальні відступи (margins)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Коли один блок має відступ, а наступний блок не має відступу або його margin значення нульове."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "У результаті, між елементами відображається відстань, що дорівнює найбільшому з цих відступів."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад:",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<div style=\"margin-bottom: 20px;\">Block 1</div>\n<div style=\"margin-top: 10px;\">Block 2</div>"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "У цьому випадку схлопування меж призведе до того, що відстань між блоками буде 20px, а не 30px (як можна було б очікувати при додаванні 20px + 10px)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Чому це відбувається?",
                "bold": true
              },
              {
                "text": " Схлопування меж застосовується, щоб уникнути зайвих відступів і зробити верстку більш зручною для використання, оскільки зазвичай не має сенсу мати два відступи, що діють на ту саму частину простору."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Як уникнути схлопування:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати "
              },
              {
                "text": "padding",
                "code": true
              },
              {
                "text": ", а не "
              },
              {
                "text": "margin",
                "code": true
              },
              {
                "text": ", якщо потрібно уникнути схлопування."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Встановити "
              },
              {
                "text": "overflow",
                "code": true
              },
              {
                "text": " на елементі."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати фонові або градієнтні елементи, щоб блокувати схлопування."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "34. Що таке z-index? Як формується контекст накладання?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": " — це CSS властивість, яка визначає порядок накладання елементів на сторінці. Вона використовується для визначення, який елемент має бути поверх іншого, коли елементи перекривають один одного. Вищий "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": " означає, що елемент буде накладатися поверх елементів з нижчим значенням "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": "."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Як працює "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Значення "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " може бути цілим числом (наприклад, 1, 10, -5)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "За замовчуванням, елементи з однаковим "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " або без нього накладаються один на одного в порядку їх появи в HTML."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Чим більше значення "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ", тим вище елемент буде на сторінці."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "div {\n  position: absolute;\n}\n\n.div1 {\n  z-index: 1;\n}\n\n.div2 {\n  z-index: 2;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "У цьому прикладі "
          },
          {
            "text": ".div2",
            "code": true
          },
          {
            "text": " буде накладатися поверх "
          },
          {
            "text": ".div1",
            "code": true
          },
          {
            "text": ", оскільки у неї вищий "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": "."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Контекст накладання:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Контекст накладання — це область, в межах якої визначаються всі значення z-index для елементів. Це стосується елементів з властивістю position (не static), або коли застосовуються інші властивості, які створюють новий контекст накладання."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Контекст накладання формується, коли:",
            "bold": true
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елемент має властивість "
              },
              {
                "text": "position",
                "code": true
              },
              {
                "text": " з одним із значень ("
              },
              {
                "text": "relative",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "absolute",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "fixed",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "sticky",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " встановлено на значення, відмінне від auto."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Властивість opacity менша за 1."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Властивість "
              },
              {
                "text": "transform",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "filter",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "perspective",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "clip-path",
                "code": true
              },
              {
                "text": " та інші створюють новий контекст."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Як формується контекст накладання:",
            "bold": true
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вищезгадані умови (наприклад, "
              },
              {
                "text": "position: relative",
                "code": true
              },
              {
                "text": " і "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Ті елементи, які знаходяться в цьому контексті, будуть порівнювати свої z-index тільки в межах цього контексту, а не з іншими елементами на сторінці."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Якщо елемент знаходиться в різних контекстах накладання, то порівнювати z-index можна лише в межах кожного з контекстів."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад контексту накладання:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<div class=\"parent\" style=\"position: relative; z-index: 10;\">\n  <div class=\"child\" style=\"position: absolute; z-index: 5;\">Child 1</div>\n  <div class=\"child\" style=\"position: absolute; z-index: 15;\">Child 2</div>\n</div>\n\n<div class=\"sibling\" style=\"position: absolute; z-index: 20;\">Sibling</div>"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "У цьому прикладі:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ".child 1",
                "code": true
              },
              {
                "text": " і "
              },
              {
                "text": ".child 2",
                "code": true
              },
              {
                "text": " знаходяться в одному контексті накладання всередині "
              },
              {
                "text": ".parent",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ".sibling",
                "code": true
              },
              {
                "text": " має інший контекст накладання і з'явиться поверх обох "
              },
              {
                "text": ".child",
                "code": true
              },
              {
                "text": ", оскільки має більший "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " у своєму контексті."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "35. Порядок накладання елементів у CSS (Stacking Order)?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Порядок накладання елементів у CSS (Stacking Order) визначається порядком, у якому елементи накладаються один на одного на сторінці. Це важливо, коли елементи з різними властивостями (наприклад, "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": ") можуть перекривати один одного."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Порядок накладання (Stacking Order):"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елементи за замовчуванням",
            "bold": true
          },
          {
            "text": " (статичні елементи, без позиціонування та без "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": "):"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елементи без позиціонування ("
              },
              {
                "text": "position: static",
                "code": true
              },
              {
                "text": " або без властивості "
              },
              {
                "text": "position",
                "code": true
              },
              {
                "text": ") розташовуються один за одним у порядку їхнього розташування в HTML."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елементи з позиціонуванням",
            "bold": true
          },
          {
            "text": " ("
          },
          {
            "text": "relative",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "absolute",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "fixed",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "sticky",
            "code": true
          },
          {
            "text": "):"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Якщо елемент має будь-яке інше значення "
              },
              {
                "text": "position",
                "code": true
              },
              {
                "text": " (крім "
              },
              {
                "text": "static",
                "code": true
              },
              {
                "text": "), він створює новий контекст накладання. У межах цього контексту елементи з більшим значенням "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " будуть накладатися поверх елементів з меншим значенням."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елементи з z-index",
            "bold": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елементи з більш високим "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " будуть розташовуватися поверх елементів з нижчим значенням "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": " (якщо елементи знаходяться в одному контексті накладання)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Невидимі елементи",
            "bold": true
          },
          {
            "text": " (з "
          },
          {
            "text": "opacity",
            "code": true
          },
          {
            "text": " менше 1 або з "
          },
          {
            "text": "visibility: hidden",
            "code": true
          },
          {
            "text": "):"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елементи, які мають властивість "
              },
              {
                "text": "opacity",
                "code": true
              },
              {
                "text": " менше 1 або "
              },
              {
                "text": "visibility: hidden",
                "code": true
              },
              {
                "text": ", можуть бути розташовані поверх інших елементів, але їх все одно не видно."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елементи з властивістю",
            "bold": true
          },
          {
            "text": " "
          },
          {
            "text": "transform",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "filter",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "perspective",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "clip-path",
            "code": true
          },
          {
            "text": " та іншими, що створюють новий контекст накладання:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Коли елемент має одну з цих властивостей, це створює новий контекст накладання, і елементи в цьому контексті будуть накладатися згідно з їхніми значеннями "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ", незалежно від того, де вони знаходяться на сторінці."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елементи з фонового вмісту",
            "bold": true
          },
          {
            "text": " ("
          },
          {
            "text": "backgrounds",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "borders",
            "code": true
          },
          {
            "text": ", etc.):"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вміст, такий як фон або бордери, не створює власного контексту накладання, але може бути важливим для визначення, як інші елементи накладаються."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Порядок накладання елементів за замовчуванням:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Блоки без позиціонування",
                "bold": true
              },
              {
                "text": " (статичні елементи)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елементи з позиціонуванням",
                "bold": true
              },
              {
                "text": " "
              },
              {
                "text": "relative",
                "code": true
              },
              {
                "text": " (якщо не визначено "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Елементи з позиціонуванням",
                "bold": true
              },
              {
                "text": " "
              },
              {
                "text": "absolute",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "fixed",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "sticky",
                "code": true
              },
              {
                "text": " (в залежності від "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Нове контексти накладання",
                "bold": true
              },
              {
                "text": " (наприклад, елементи з "
              },
              {
                "text": "transform",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "opacity < 1",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "filter",
                "code": true
              },
              {
                "text": " тощо)."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Простіше кажучи:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Статичні елементи не створюють контексту накладання і накладаються в порядку їхнього розташування в HTML."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елементи з позиціонуванням "
          },
          {
            "text": "relative",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "absolute",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "fixed",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "sticky",
            "code": true
          },
          {
            "text": " створюють контекст накладання, де "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": " визначає, які елементи будуть поверх інших."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елементи з новими контекстами накладання (наприклад, з "
          },
          {
            "text": "transform",
            "code": true
          },
          {
            "text": " або "
          },
          {
            "text": "opacity < 1",
            "code": true
          },
          {
            "text": ") накладаються поверх всіх інших елементів із меншим пріоритетом."
          }
        ]
      }
    ]
  },
  {
    "question": "36. Як за допомогою CSS визначити, чи підтримується властивість у браузері?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для того, щоб перевірити, чи підтримується властивість у браузері, в CSS безпосередньо неможливо це зробити, оскільки CSS сам по собі не має вбудованих механізмів для перевірки підтримки властивостей. Однак, є кілька способів зробити це за допомогою JavaScript та умовних конструкцій у CSS."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання JavaScript (Modernizr)",
                "bold": true
              },
              {
                "text": "Один із способів перевірити, чи підтримується CSS властивість у браузері — це використати JavaScript-бібліотеку, наприклад, Modernizr. Modernizr дозволяє перевіряти підтримку різних технологій і властивостей браузером."
              },
              {
                "text": "Приклад використання Modernizr:",
                "bold": true
              },
              {
                "type": "code",
                "language": "javascript",
                "content": "if (Modernizr.flexbox) {\n  console.log('Flexbox підтримується!');\n} else {\n  console.log('Flexbox не підтримується.');\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання умови @supports в CSS",
                "bold": true
              },
              {
                "text": "CSS має власну конструкцію "
              },
              {
                "text": "@supports",
                "code": true
              },
              {
                "text": ", яка дозволяє перевіряти, чи підтримується певна CSS властивість або її значення в поточному браузері."
              },
              {
                "text": "Приклад:",
                "bold": true
              },
              {
                "type": "code",
                "language": "css",
                "content": "/* Перевіряє, чи підтримується flexbox */\n@supports (display: flex) {\n  .container {\n    display: flex;\n  }\n}\n\n/* Якщо не підтримується flexbox, додається альтернативне значення */\n@supports not (display: flex) {\n  .container {\n    display: block;\n  }\n}"
              },
              {
                "text": "У цьому прикладі, якщо браузер підтримує "
              },
              {
                "text": "display: flex",
                "code": true
              },
              {
                "text": ", то він застосує стилі, визначені в першому блоці. Якщо ж не підтримує, застосує стилі з блоку "
              },
              {
                "text": "@supports",
                "code": true
              },
              {
                "text": " not."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання префіксів для застарілих властивостей",
                "bold": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для старих властивостей або експериментальних властивостей браузерів часто використовуються вендорні префікси. Якщо необхідно працювати з такими властивостями, часто можна додавати ці префікси та перевіряти, чи працює код на різних браузерах."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад з вендорними префіксами:",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "/* Вендорні префікси для трансформацій */\n.element {\n  -webkit-transform: rotate(45deg);\n  -moz-transform: rotate(45deg);\n  transform: rotate(45deg);\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Це допоможе забезпечити сумісність з різними версіями браузерів."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Висновок"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Найбільш зручним методом перевірки підтримки властивості є використання @supports у CSS або бібліотеки Modernizr для JavaScript, яка дозволяє створити перевірки підтримки за допомогою скриптів."
          }
        ]
      }
    ]
  },
  {
    "question": "37. Глобальні ключові слова у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Глобальні ключові слова в CSS — це спеціальні значення, які можна задати будь-якій CSS-властивості. Вони не змінюють саме значення властивості, а вказують, як її слід обчислювати."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Список глобальних ключових слів"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "inherit",
                "code": true
              },
              {
                "text": " – успадковує значення від батьківського елемента."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "initial",
                "code": true
              },
              {
                "text": " – скидає значення до дефолтного (згідно зі специфікацією)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "unset",
                "code": true
              },
              {
                "text": " – якщо властивість успадковується за замовчуванням (наприклад, color), діє як inherit, інакше – як initial."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "revert",
                "code": true
              },
              {
                "text": " – повертає значення до того, що визначено у стилях браузера чи користувача."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "revert-layer",
                "code": true
              },
              {
                "text": " – скидає значення до попереднього рівня каскаду (актуально для @layer)."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклади використання"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ "
          },
          {
            "text": "inherit",
            "code": true
          },
          {
            "text": " (успадкування значення)"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "p {\n  color: red;\n}\nspan {\n  color: inherit; /* отримає червоний від <p> */\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ "
          },
          {
            "text": "initial",
            "code": true
          },
          {
            "text": " (повернення до стандартного значення)"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "button {\n  all: initial; /* скидає всі властивості до дефолтних */\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ "
          },
          {
            "text": "unset",
            "code": true
          },
          {
            "text": " (залежно від властивості)"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "div {\n  color: unset; /* успадкує */\n  width: unset; /* повернеться до `auto` */\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ "
          },
          {
            "text": "revert",
            "code": true
          },
          {
            "text": " (повернення до стандартних стилів браузера)"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "a {\n  color: green;\n}\na.special {\n  color: revert; /* поверне синій, якщо його задає браузер */\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ "
          },
          {
            "text": "revert-layer",
            "code": true
          },
          {
            "text": " (актуально для @layer)"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@layer framework {\n  button {\n    background: red;\n  }\n}\n\n@layer custom {\n  button {\n    background: blue;\n  }\n}\n\n/* revert-layer поверне червоний із framework, а не дефолтний */\nbutton {\n  background: revert-layer;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Висновок"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "inherit",
                "code": true
              },
              {
                "text": " – для спадкування."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "initial",
                "code": true
              },
              {
                "text": " – для скидання до дефолту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "unset",
                "code": true
              },
              {
                "text": " – комбінує inherit та initial."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "revert",
                "code": true
              },
              {
                "text": " – повертає значення браузера чи стилів користувача."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "revert-layer",
                "code": true
              },
              {
                "text": " – скидає значення до попереднього рівня каскаду."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "38. Що таке перерахування селекторів?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Перерахування селекторів — це використання кількох селекторів, розділених комою, для одночасного застосування стилів до різних елементів."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Синтаксис"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "selector1,\nselector2,\nselector3 {\n  property: value;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклади"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ Стилізація кількох елементів одночасно"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "h1,\nh2,\nh3 {\n  color: red;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Усі h1, h2 і h3 стануть червоними."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ Комбінація класів і тегів"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "button,\n.btn {\n  padding: 10px;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Застосується до "
          },
          {
            "text": "<button>",
            "code": true
          },
          {
            "text": " і будь-якого елемента з "
          },
          {
            "text": ".btn",
            "code": true
          },
          {
            "text": "."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ Перерахування складних селекторів"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".card .title,\n.box .header {\n  font-weight: bold;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Стилізує "
          },
          {
            "text": ".title",
            "code": true
          },
          {
            "text": " всередині "
          },
          {
            "text": ".card",
            "code": true
          },
          {
            "text": " і "
          },
          {
            "text": ".header",
            "code": true
          },
          {
            "text": " всередині "
          },
          {
            "text": ".box",
            "code": true
          },
          {
            "text": "."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Висновок"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Коми ("
              },
              {
                "text": ",",
                "code": true
              },
              {
                "text": ") об'єднують селектори, застосовуючи однакові стилі."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Дозволяє скорочувати код і зменшувати дублювання."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Важливо не плутати з комбінованими селекторами (наприклад, "
              },
              {
                "text": ".class1 .class2",
                "code": true
              },
              {
                "text": ", де "
              },
              {
                "text": ".class2",
                "code": true
              },
              {
                "text": " має бути всередині "
              },
              {
                "text": ".class1",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "39. Для чого використовується ключове слово currentColor у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "currentColor",
            "code": true
          },
          {
            "text": " — це ключове слово в CSS, яке задає значення кольору ("
          },
          {
            "text": "color",
            "code": true
          },
          {
            "text": ") для інших властивостей, що підтримують кольори."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Як працює"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "currentColor",
            "code": true
          },
          {
            "text": " автоматично використовує значення, встановлене у властивості "
          },
          {
            "text": "color",
            "code": true
          },
          {
            "text": "."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклади використання"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ Однаковий колір для тексту та рамки"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "button {\n  color: blue;\n  border: 2px solid currentColor;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Рамка кнопки буде того ж кольору, що й текст ("
          },
          {
            "text": "blue",
            "code": true
          },
          {
            "text": ")."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ SVG-іконки із кольором тексту"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".icon {\n  color: red;\n  fill: currentColor;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "fill",
            "code": true
          },
          {
            "text": " у SVG прийме "
          },
          {
            "text": "color",
            "code": true
          },
          {
            "text": " елемента ("
          },
          {
            "text": "red",
            "code": true
          },
          {
            "text": ")."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ Прозорість зі спадкуванням кольору"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".link {\n  color: green;\n  background: linear-gradient(currentColor 0%, transparent 100%);\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Градієнт стартує від "
          },
          {
            "text": "green",
            "code": true
          },
          {
            "text": ", бо це значення "
          },
          {
            "text": "color",
            "code": true
          },
          {
            "text": "."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Висновок"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовує значення "
              },
              {
                "text": "color",
                "code": true
              },
              {
                "text": ", усуваючи дублювання стилів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Особливо корисно для SVG, "
              },
              {
                "text": "border",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "background",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "box-shadow",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Спрощує темізацію: змінюєш "
              },
              {
                "text": "color",
                "code": true
              },
              {
                "text": ", і все підлаштовується."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "40. Які псевдокласи є CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Псевдокласи в CSS"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Динамічні псевдокласи"
              }
            ]
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Псевдоклас"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": ":hover",
                "code": true
              }
            ],
            [
              {
                "text": "При наведенні курсору."
              }
            ]
          ],
          [
            [
              {
                "text": ":focus",
                "code": true
              }
            ],
            [
              {
                "text": "Коли елемент у фокусі (наприклад, "
              },
              {
                "text": "input",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          ],
          [
            [
              {
                "text": ":active",
                "code": true
              }
            ],
            [
              {
                "text": "Під час натискання."
              }
            ]
          ],
          [
            [
              {
                "text": ":visited",
                "code": true
              }
            ],
            [
              {
                "text": "Для відвіданих посилань."
              }
            ]
          ],
          [
            [
              {
                "text": ":target",
                "code": true
              }
            ],
            [
              {
                "text": "Для елемента, що відповідає "
              },
              {
                "text": "#anchor",
                "code": true
              },
              {
                "text": " в URL."
              }
            ]
          ]
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Структурні псевдокласи"
              }
            ]
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Псевдоклас"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": ":first-child",
                "code": true
              }
            ],
            [
              {
                "text": "Перший дочірній елемент."
              }
            ]
          ],
          [
            [
              {
                "text": ":last-child",
                "code": true
              }
            ],
            [
              {
                "text": "Останній дочірній елемент."
              }
            ]
          ],
          [
            [
              {
                "text": ":nth-child(n)",
                "code": true
              }
            ],
            [
              {
                "text": "Дочірній елемент за індексом "
              },
              {
                "text": "n",
                "code": true
              },
              {
                "text": " (можна "
              },
              {
                "text": "odd",
                "code": true
              },
              {
                "text": "/"
              },
              {
                "text": "even",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          ],
          [
            [
              {
                "text": ":nth-last-child(n)",
                "code": true
              }
            ],
            [
              {
                "text": "Те саме, але з кінця."
              }
            ]
          ],
          [
            [
              {
                "text": ":only-child",
                "code": true
              }
            ],
            [
              {
                "text": "Якщо елемент єдиний у батьківському контейнері."
              }
            ]
          ]
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Типові псевдокласи"
              }
            ]
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Псевдоклас"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": ":first-of-type",
                "code": true
              }
            ],
            [
              {
                "text": "Перший елемент певного типу."
              }
            ]
          ],
          [
            [
              {
                "text": ":last-of-type",
                "code": true
              }
            ],
            [
              {
                "text": "Останній елемент певного типу."
              }
            ]
          ],
          [
            [
              {
                "text": ":nth-of-type(n)",
                "code": true
              }
            ],
            [
              {
                "text": "N-ий елемент певного типу."
              }
            ]
          ],
          [
            [
              {
                "text": ":nth-last-of-type(n)",
                "code": true
              }
            ],
            [
              {
                "text": "N-ий елемент певного типу з кінця."
              }
            ]
          ],
          [
            [
              {
                "text": ":only-of-type",
                "code": true
              }
            ],
            [
              {
                "text": "Якщо елемент унікальний серед такого ж типу."
              }
            ]
          ]
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Логічні псевдокласи"
              }
            ]
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Псевдоклас"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": ":not(selector)",
                "code": true
              }
            ],
            [
              {
                "text": "Вибирає все, "
              },
              {
                "text": "крім",
                "bold": true
              },
              {
                "text": " вказаного селектора."
              }
            ]
          ],
          [
            [
              {
                "text": ":has(selector)",
                "code": true
              }
            ],
            [
              {
                "text": "Вибирає елементи, що містять інший елемент ("
              },
              {
                "text": "CSS4",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          ],
          [
            [
              {
                "text": ":where(selector)",
                "code": true
              }
            ],
            [
              {
                "text": "Як "
              },
              {
                "text": ":is()",
                "code": true
              },
              {
                "text": ", але без пріоритету."
              }
            ]
          ],
          [
            [
              {
                "text": ":is(selector)",
                "code": true
              }
            ],
            [
              {
                "text": "Спрощує складні селектори."
              }
            ]
          ]
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Псевдокласи для форм"
              }
            ]
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Псевдоклас"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": ":checked",
                "code": true
              }
            ],
            [
              {
                "text": "Позначений чекбокс або радіокнопка."
              }
            ]
          ],
          [
            [
              {
                "text": ":disabled",
                "code": true
              }
            ],
            [
              {
                "text": "Вимкнений елемент форми."
              }
            ]
          ],
          [
            [
              {
                "text": ":enabled",
                "code": true
              }
            ],
            [
              {
                "text": "Активний елемент форми."
              }
            ]
          ],
          [
            [
              {
                "text": ":required",
                "code": true
              }
            ],
            [
              {
                "text": "Поле "
              },
              {
                "text": "input",
                "code": true
              },
              {
                "text": ", що обов’язкове."
              }
            ]
          ],
          [
            [
              {
                "text": ":optional",
                "code": true
              }
            ],
            [
              {
                "text": "Поле "
              },
              {
                "text": "input",
                "code": true
              },
              {
                "text": ", що не є обов’язковим."
              }
            ]
          ],
          [
            [
              {
                "text": ":valid",
                "code": true
              }
            ],
            [
              {
                "text": "Поле форми з коректним значенням."
              }
            ]
          ],
          [
            [
              {
                "text": ":invalid",
                "code": true
              }
            ],
            [
              {
                "text": "Поле форми з некоректним значенням."
              }
            ]
          ],
          [
            [
              {
                "text": ":read-only",
                "code": true
              }
            ],
            [
              {
                "text": "Поле у режимі "
              },
              {
                "text": "readonly",
                "code": true
              },
              {
                "text": "."
              }
            ]
          ],
          [
            [
              {
                "text": ":read-write",
                "code": true
              }
            ],
            [
              {
                "text": "Поле, що можна редагувати."
              }
            ]
          ]
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдокласи допомагають стилізувати елементи без додаткових класів або JS. Використовуйте `:is()` та `:has()` для скорочення складних селекторів у CSS4.",
            "bold": true
          }
        ]
      }
    ]
  },
  {
    "question": "41. Які фільтри є у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Фільтри у CSS"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Фільтри ("
          },
          {
            "text": "filter",
            "code": true
          },
          {
            "text": ") дозволяють змінювати вигляд елементів, застосовуючи ефекти до їхнього рендерингу."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🔹 Основні фільтри"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Фільтр"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ],
          [
            {
              "text": "Приклад"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "blur(px)",
                "code": true
              }
            ],
            [
              {
                "text": "Розмиття з вказаним радіусом у пікселях."
              }
            ],
            [
              {
                "text": "filter: blur(5px);",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "brightness(%)",
                "code": true
              }
            ],
            [
              {
                "text": "Змінює яскравість (100% – без змін)."
              }
            ],
            [
              {
                "text": "filter: brightness(150%);",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "contrast(%)",
                "code": true
              }
            ],
            [
              {
                "text": "Змінює контраст (100% – без змін)."
              }
            ],
            [
              {
                "text": "filter: contrast(120%);",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "grayscale(%)",
                "code": true
              }
            ],
            [
              {
                "text": "Відтінки сірого (100% – чорно-біле)."
              }
            ],
            [
              {
                "text": "filter: grayscale(100%);",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "invert(%)",
                "code": true
              }
            ],
            [
              {
                "text": "Інвертує кольори (100% – повністю інвертоване)."
              }
            ],
            [
              {
                "text": "filter: invert(100%);",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "opacity(%)",
                "code": true
              }
            ],
            [
              {
                "text": "Прозорість (0% – повністю прозоре, 100% – непрозоре)."
              }
            ],
            [
              {
                "text": "filter: opacity(50%);",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "saturate(%)",
                "code": true
              }
            ],
            [
              {
                "text": "Насиченість (100% – без змін, 0% – ч/б)."
              }
            ],
            [
              {
                "text": "filter: saturate(200%);",
                "code": true
              }
            ]
          ],
          [
            [
              {
                "text": "sepia(%)",
                "code": true
              }
            ],
            [
              {
                "text": "Ефект сепії (100% – повністю сепія)."
              }
            ],
            [
              {
                "text": "filter: sepia(80%);",
                "code": true
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🔹 Фільтри для тіней та зміщення"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Фільтр"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ],
          [
            {
              "text": "Приклад"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "drop-shadow(x y blur color)",
                "code": true
              }
            ],
            [
              {
                "text": "Додає тінь до зображення (аналог "
              },
              {
                "text": "box-shadow",
                "code": true
              },
              {
                "text": ", але працює з прозорими PNG)."
              }
            ],
            [
              {
                "text": "filter: drop-shadow(5px 5px 10px rgba(0,0,0,0.5));",
                "code": true
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🔹 Комбінування фільтрів"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Фільтри можна комбінувати, вказуючи їх через пробіл:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "filter: brightness(120%) contrast(110%) blur(3px);"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Фільтри застосовуються до всіх елементів, але найчастіше – до зображень (img), відео та бекграундів."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "42. Навіщо використовується псевдоклас :invalid?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдоклас "
          },
          {
            "text": ":invalid",
            "code": true
          },
          {
            "text": " використовується для стилізації полів вводу ("
          },
          {
            "text": "<input>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<textarea>",
            "code": true
          },
          {
            "text": ", "
          },
          {
            "text": "<select>",
            "code": true
          },
          {
            "text": "), які не відповідають вимогам валідації."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Навіщо це потрібно?"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Підсвічувати некоректно заповнені поля."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Покращити UX, показуючи візуальний зворотний зв’язок."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Додати кастомні стилі без JavaScript."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад використання"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "input:invalid {\n  border: 2px solid red;\n  background-color: #ffe6e6;\n}"
      },
      {
        "type": "code",
        "language": "html",
        "content": "<input type=\"email\" required placeholder=\"Введіть email\" />"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Якщо поле буде пустим або міститиме некоректний email, воно підсвітиться червоним."
          }
        ]
      }
    ]
  },
  {
    "question": "43. Розкажіть про властивість display в CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Властивість "
          },
          {
            "text": "display",
            "code": true
          },
          {
            "text": " у CSS"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "display",
            "code": true
          },
          {
            "text": " визначає, як елемент відображається на сторінці та як він взаємодіє з іншими елементами."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🔹 Основні значення"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Значення"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "none",
                "code": true
              }
            ],
            [
              {
                "text": "Елемент прихований і не займає місця в макеті."
              }
            ]
          ],
          [
            [
              {
                "text": "block",
                "code": true
              }
            ],
            [
              {
                "text": "Блочний елемент, займає всю ширину батьківського контейнера."
              }
            ]
          ],
          [
            [
              {
                "text": "inline",
                "code": true
              }
            ],
            [
              {
                "text": "Вбудований елемент, займає лише необхідну ширину."
              }
            ]
          ],
          [
            [
              {
                "text": "inline-block",
                "code": true
              }
            ],
            [
              {
                "text": "Вбудований елемент, але можна змінювати ширину/висоту."
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🔹 Гнучкі макети"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Значення"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "flex",
                "code": true
              }
            ],
            [
              {
                "text": "Активація "
              },
              {
                "text": "Flexbox",
                "bold": true
              },
              {
                "text": " для гнучкого розташування дочірніх елементів."
              }
            ]
          ],
          [
            [
              {
                "text": "grid",
                "code": true
              }
            ],
            [
              {
                "text": "Використання "
              },
              {
                "text": "CSS Grid",
                "bold": true
              },
              {
                "text": " для двовимірного макету."
              }
            ]
          ],
          [
            [
              {
                "text": "inline-flex",
                "code": true
              }
            ],
            [
              {
                "text": "Flex-контейнер, але поводиться як "
              },
              {
                "text": "inline",
                "code": true
              },
              {
                "text": "."
              }
            ]
          ],
          [
            [
              {
                "text": "inline-grid",
                "code": true
              }
            ],
            [
              {
                "text": "Grid-контейнер, але поводиться як "
              },
              {
                "text": "inline",
                "code": true
              },
              {
                "text": "."
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🔹 Табличні макети"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Значення"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "table",
                "code": true
              }
            ],
            [
              {
                "text": "Елемент поводиться як таблиця."
              }
            ]
          ],
          [
            [
              {
                "text": "table-row",
                "code": true
              }
            ],
            [
              {
                "text": "Імітує рядок таблиці."
              }
            ]
          ],
          [
            [
              {
                "text": "table-cell",
                "code": true
              }
            ],
            [
              {
                "text": "Імітує комірку таблиці."
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🔹 Інші значення"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Значення"
            }
          ],
          [
            {
              "text": "Опис"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "list-item",
                "code": true
              }
            ],
            [
              {
                "text": "Елемент поводиться як "
              },
              {
                "text": "<li>",
                "code": true
              },
              {
                "text": ", додаючи маркер списку."
              }
            ]
          ],
          [
            [
              {
                "text": "inherit",
                "code": true
              }
            ],
            [
              {
                "text": "Наслідує значення "
              },
              {
                "text": "display",
                "code": true
              },
              {
                "text": " від батьківського елемента."
              }
            ]
          ],
          [
            [
              {
                "text": "initial",
                "code": true
              }
            ],
            [
              {
                "text": "Встановлює значення "
              },
              {
                "text": "display",
                "code": true
              },
              {
                "text": " за замовчуванням для браузера."
              }
            ]
          ]
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "`display: none` повністю прибирає елемент з потоку, на відміну від `visibility: hidden`, який просто приховує його, залишаючи місце.",
            "bold": true
          }
        ]
      }
    ]
  },
  {
    "question": "44. У якому випадку краще використовувати translate() замість абсолютного позиціонування?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовувати "
          },
          {
            "text": "translate()",
            "code": true
          },
          {
            "text": " краще в таких випадках:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Оптимізація продуктивності",
                "bold": true
              },
              {
                "text": " – "
              },
              {
                "text": "translate()",
                "code": true
              },
              {
                "text": " використовує GPU для обчислень, що робить анімації та переміщення плавнішими, ніж зміна "
              },
              {
                "text": "top/left",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Збереження потоку документа",
                "bold": true
              },
              {
                "text": " – "
              },
              {
                "text": "translate()",
                "code": true
              },
              {
                "text": " не впливає на положення інших елементів, на відміну від "
              },
              {
                "text": "position: absolute",
                "code": true
              },
              {
                "text": ", який змінює розташування елемента відносно найближчого позиціонованого предка."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Поліпшення продуктивності рендерингу",
                "bold": true
              },
              {
                "text": " – зміна "
              },
              {
                "text": "transform",
                "code": true
              },
              {
                "text": " не викликає рефлоу ("
              },
              {
                "text": "reflow",
                "code": true
              },
              {
                "text": "), тоді як "
              },
              {
                "text": "top/left",
                "code": true
              },
              {
                "text": " змушують браузер перераховувати макет."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Гнучке центрування",
                "bold": true
              },
              {
                "text": " – "
              },
              {
                "text": "translate(-50%, -50%)",
                "code": true
              },
              {
                "text": " часто використовується для центрування без залежності від розмірів контейнера."
              },
              {
                "type": "bulletList",
                "children": [
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Якщо потрібно перемістити елемент без зміни його поточного контексту, "
                      },
                      {
                        "text": "translate()",
                        "code": true
                      },
                      {
                        "text": " – кращий вибір."
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "45. Що таке плаваючі елементи (floats)? Як вони працюють?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Плаваючі елементи",
            "bold": true
          },
          {
            "text": " ("
          },
          {
            "text": "float",
            "code": true
          },
          {
            "text": ") — це механізм у CSS, який дозволяє елементам \"виринати\" ліворуч або праворуч усередині контейнера, при цьому текст та інші інлайн-елементи обтікають їх."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Як працюють "
          },
          {
            "text": "float",
            "code": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Обтікання текстом",
                "bold": true
              },
              {
                "text": " – якщо блок має "
              },
              {
                "text": "float: left",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "float: right",
                "code": true
              },
              {
                "text": ", інші елементи (зазвичай текст) обтікають його."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вилучення з потоку",
                "bold": true
              },
              {
                "text": " – "
              },
              {
                "text": "float",
                "code": true
              },
              {
                "text": " прибирає елемент із нормального потоку документа, але він все ще займає місце в контейнері."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Розриви потоку",
                "bold": true
              },
              {
                "text": " ("
              },
              {
                "text": "clearfix",
                "code": true
              },
              {
                "text": ") – якщо всі дочірні елементи контейнера float, він може схлопнутись. Виправляють це додаванням "
              },
              {
                "text": "overflow: hidden",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": ".clearfix (::after { content: \"\"; display: block; clear: both; })",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Обмежена керованість",
                "bold": true
              },
              {
                "text": " – "
              },
              {
                "text": "float",
                "code": true
              },
              {
                "text": " застаріває, бо не підходить для складних макетів. Замість нього зараз використовують "
              },
              {
                "text": "flexbox",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "grid",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Висновок:",
            "bold": true
          },
          {
            "text": " "
          },
          {
            "text": "float",
            "code": true
          },
          {
            "text": " був основним способом верстки до появи "
          },
          {
            "text": "flexbox",
            "code": true
          },
          {
            "text": " і "
          },
          {
            "text": "grid",
            "code": true
          },
          {
            "text": ", але зараз використовується переважно для обтікання зображень текстом."
          }
        ]
      }
    ]
  },
  {
    "question": "46. Способи завдання кольору CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Існує кілька способів задавати кольори в CSS:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Назва кольору:",
                "bold": true
              },
              {
                "text": "Наприклад:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "color: red;"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Шістнадцятковий код (Hex):",
                "bold": true
              },
              {
                "text": "Наприклад:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "color: #ff5733; /* Рожевий */"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "RGB (Red, Green, Blue):",
                "bold": true
              },
              {
                "text": "Визначається за допомогою значень для червоного, зеленого і синього каналів від 0 до 255."
              },
              {
                "text": "Наприклад:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "color: rgb(255, 87, 51);"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "RGBA (Red, Green, Blue, Alpha):",
                "bold": true
              },
              {
                "text": "Подібно до RGB, але з додаванням каналу прозорості (alpha) від 0 (повністю прозорий) до 1 (непрозорий)."
              },
              {
                "text": "Наприклад:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "color: rgba(255, 87, 51, 0.5);"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "HSL (Hue, Saturation, Lightness):",
                "bold": true
              },
              {
                "text": "Визначається за допомогою відтінку (hue), насиченості (saturation) та яскравості (lightness)."
              },
              {
                "text": "Наприклад:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "color: hsl(12, 100%, 60%);"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "HSLA (Hue, Saturation, Lightness, Alpha):",
                "bold": true
              },
              {
                "text": "Як HSL, але з каналом прозорості."
              },
              {
                "text": "Наприклад:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "color: hsla(12, 100%, 60%, 0.5);"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-Gradients:",
                "bold": true
              },
              {
                "text": "Колір може бути визначений за допомогою градієнтів."
              },
              {
                "text": "Наприклад:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "background: linear-gradient(to right, red, yellow);"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Прозорі кольори:",
                "bold": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовуємо ключові слова для заданого рівня прозорості."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Наприклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "color: transparent;"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Ці методи дозволяють задавати кольори на різні випадки та з різними рівнями контролю над прозорістю."
          }
        ]
      }
    ]
  },
  {
    "question": "47. Які CSS-властивості використовуються для створення анімацій та плавних переходів?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для створення анімацій та плавних переходів у CSS використовуються такі властивості:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Плавні переходи (`transition`)",
                "bold": true
              },
              {
                "type": "bulletList",
                "children": [
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Дозволяють змінювати значення властивостей із плавною анімацією."
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Основні властивості:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "transition-property",
                "code": true
              },
              {
                "text": " – яка властивість анімується."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "transition-duration",
                "code": true
              },
              {
                "text": " – час анімації."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "transition-timing-function",
                "code": true
              },
              {
                "text": " – крива прискорення (наприклад, "
              },
              {
                "text": "ease",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "linear",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "ease-in-out",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "transition-delay",
                "code": true
              },
              {
                "text": " – затримка перед анімацією."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "button {\n  background-color: blue;\n  transition: background-color 0.3s ease-in-out;\n}\n\nbutton:hover {\n  background-color: red;\n}"
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Анімації (`@keyframes` + `animation`)",
                "bold": true
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Дозволяють створювати складніші анімації зі зміною стилів у ключових точках."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Основні властивості:",
            "bold": true
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "animation-name",
            "code": true
          },
          {
            "text": " – ім'я анімації (відповідає @keyframes). "
          },
          {
            "text": "animation-duration",
            "code": true
          },
          {
            "text": " – тривалість анімації. "
          },
          {
            "text": "animation-timing-function",
            "code": true
          },
          {
            "text": " – крива прискорення. "
          },
          {
            "text": "animation-delay",
            "code": true
          },
          {
            "text": " – затримка перед початком. "
          },
          {
            "text": "animation-iteration-count",
            "code": true
          },
          {
            "text": " – кількість повторень (infinite для безкінечної анімації). "
          },
          {
            "text": "animation-direction",
            "code": true
          },
          {
            "text": " – напрям (normal, reverse, alternate). "
          },
          {
            "text": "animation-fill-mode",
            "code": true
          },
          {
            "text": " – визначає, чи зберігається стан анімації після завершення."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n.element {\n  animation: fadeIn 1s ease-in-out;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Що використовувати?"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "transition",
                "code": true
              },
              {
                "text": " – якщо треба просто змінювати стилі при наведенні або зміні класу."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "animation",
                "code": true
              },
              {
                "text": " – якщо потрібен складніший ефект з кількома ключовими кадрами."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "48. Різниця між псевдокласами та псевдоелементами?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Різниця між псевдокласами і псевдоелементами полягає у їхньому призначенні та способі застосування:"
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Псевдокласи"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдокласи застосовуються для вибору елементів на основі їхнього стану або взаємодії з користувачем, а не через структуру HTML. Вони дозволяють стилізувати елементи в певних умовах."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклади псевдокласів:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ":hover",
                "code": true
              },
              {
                "text": " — для елементів, на які наводиться курсор."
              },
              {
                "type": "code",
                "language": "css",
                "content": "button:hover {\n  background-color: blue;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":focus",
                "code": true
              },
              {
                "text": " — для елементів, на які надано фокус (наприклад, поля введення)."
              },
              {
                "type": "code",
                "language": "css",
                "content": "input:focus {\n  border-color: green;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":nth-child()",
                "code": true
              },
              {
                "text": " — для вибору елементів за їхнім порядковим номером серед батьків."
              },
              {
                "type": "code",
                "language": "css",
                "content": "li:nth-child(odd) {\n  background-color: lightgray;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Псевдоелементи"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдоелементи дозволяють стилізувати частини елементів або додавати вміст, який не існує в HTML. Вони створюють віртуальні елементи для маніпуляцій із частинами контенту."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклади псевдоелементів:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "::before",
                "code": true
              },
              {
                "text": "— додає вміст перед вмістом елемента."
              },
              {
                "type": "code",
                "language": "css",
                "content": "p::before {\n  content: '→ ';\n  color: green;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "::after",
                "code": true
              },
              {
                "text": " — додає вміст після вмісту елемента."
              },
              {
                "type": "code",
                "language": "css",
                "content": "p::after {\n  content: ' ←';\n  color: red;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "::first-letter",
                "code": true
              },
              {
                "text": " — для стилізації першої літери елемента."
              },
              {
                "type": "code",
                "language": "css",
                "content": "p::first-letter {\n  font-size: 2em;\n  color: blue;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Ключова різниця:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Псевдокласи працюють з станом елементів (наприклад, під час наведеного курсору або фокуса)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Псевдоелементи дозволяють додавати вміст до елементів або стилізувати їх частини (наприклад, перша буква чи передвміст)."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Важливе зауваження:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдокласи використовують один знак двокрапки (:), але для псевдоелементів традиційно використовують два знаки двокрапки (::). Тому сучасні стандарти рекомендують використовувати :: для псевдоелементів (але підтримка : для псевдоелементів залишається)."
          }
        ]
      }
    ]
  },
  {
    "question": "49. Розкажіть про псевдоклас :has()?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ":has()",
                "code": true
              },
              {
                "text": " – "
              },
              {
                "text": "потужний CSS-псевдоклас",
                "bold": true
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":has()",
                "code": true
              },
              {
                "text": " — це \"батьківський селектор\", який дозволяє стилізувати елемент, що містить певні дочірні елементи."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Як працює?"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Цей псевдоклас перевіряє, чи містить елемент певний вкладений елемент, і застосовує до нього стилі."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад: змінюємо стиль картки, якщо в ній є зображення"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".card:has(img) {\n  border: 2px solid blue;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Якщо "
          },
          {
            "text": ".card",
            "code": true
          },
          {
            "text": " містить "
          },
          {
            "text": "<img>",
            "code": true
          },
          {
            "text": ", то отримає синю рамку."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклади використання"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Виділення "
              },
              {
                "text": "<input>",
                "code": true
              },
              {
                "text": " в контейнері, що містить кнопку \""
              },
              {
                "text": "submit",
                "code": true
              },
              {
                "text": "\""
              },
              {
                "type": "code",
                "language": "css",
                "content": ".form:has(button[type='submit']) {\n  background-color: lightgray;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Сірий фон застосовується тільки до .form, якщо в ній є кнопка submit."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Приховуємо кнопку, якщо інпут порожній"
              },
              {
                "type": "code",
                "language": "css",
                "content": "button:has(+ input:placeholder-shown) {\n  display: none;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Кнопка буде схована, доки користувач не введе текст в інпут."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вибір батьківського елемента списку, якщо він містить активний пункт"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".nav:has(.active) {\n  background-color: black;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Якщо .nav містить .active елемент, змінюється фон."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Підтримка браузерами"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ Chrome, Edge, Safari (з 2023 року) ❌ Firefox (станом на 2025 рік досі немає підтримки)"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Поліфілів немає, тому варто перевіряти підтримку перед використанням."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Висновок"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ":has()",
                "code": true
              },
              {
                "text": " дає можливість змінювати батьківський елемент на основі його вмісту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Робить CSS динамічнішим, замінюючи деякі JavaScript-маніпуляції."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Потрібно враховувати обмежену підтримку в Firefox."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "50. Проблеми з використанням CSS-in-JS? Як їх вирішити?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Проблеми CSS-in-JS і способи їх вирішення",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-in-JS — потужний підхід для стилізації в React та інших фреймворках, але він має серйозні недоліки, які потрібно враховувати."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Погана продуктивність (перформанс)",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "❌ Проблема:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Динамічні стилі створюються під час рендеру, що сповільнює завантаження сторінки."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Генерація стилів на клієнті збільшує TTI (Time to Interactive)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Рішення:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати статичні стилі там, де це можливо (styled-components з as=\"tag\")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Переносити стилі на сервер (SSR) з styled-components або emotion."
              },
              {
                "type": "code",
                "language": "tsx",
                "content": "import { ServerStyleSheet } from 'styled-components';"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати CSS Modules або Tailwind для критичних стилів."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Великі розміри бандлу",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "❌ Проблема:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-in-JS додає зайвий код у JavaScript-бандл."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання бібліотек (styled-components, emotion) збільшує розмір пакета."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Рішення:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати Linaria або Astro (CSS-in-JS без рантайму)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати компіляцію під час білду (наприклад, babel-plugin-styled-components)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати css prop у emotion, який генерує мінімальний CSS."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Проблеми з специфічністю CSS",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "❌ Проблема:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-in-JS генерує унікальні класи, але бувають колізії."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Не можна легко перевизначити стилі без !important."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Рішення:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати theme-based стилі через контекст."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати as або css для стилізації без перезапису класів."
              },
              {
                "type": "code",
                "language": "tsx",
                "content": "<Button as=\"a\" href=\"/\">\n  Link\n</Button>"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Відсутність інтуїтивного автодоповнення в IDE",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "❌ Проблема:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "IDE не завжди правильно підказує стилі всередині JS."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Слабка підтримка підсвітки синтаксису в деяких редакторах."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Рішення:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати VSCode-плагіни для styled-components або emotion."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати TypeScript + CSS Variables."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Труднощі з анімаціями",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "❌ Проблема:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-in-JS не завжди добре працює з keyframes."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Анімації можуть генеруватися кожен рендер."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ Рішення:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати keyframes правильно:"
              },
              {
                "type": "code",
                "language": "tsx",
                "content": "import { keyframes } from 'styled-components';\n\nconst fadeIn = keyframes`  from { opacity: 0; }\n  to { opacity: 1; }`;\n\nconst AnimatedDiv = styled.div`\n  animation: ${fadeIn} 1s ease-in-out;\n`;"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати Framer Motion або GSAP замість CSS-in-JS анімацій."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Висновок"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "✅ CSS-in-JS зручно для компонентного підходу, але:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Має проблеми продуктивності → вирішується SSR або компіляцією."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Збільшує розмір бандлу → можна мінімізувати Linaria/Astro."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Проблеми з специфічністю → використовувати as, теми та контекст."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Автодоповнення не завжди працює → плагіни VSCode + TS."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для великих проєктів варто комбінувати CSS-in-JS з CSS Modules, Tailwind або ванільним CSS."
          }
        ]
      }
    ]
  },
  {
    "question": "51. Що означає CSS і яке його основне використання?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "CSS (Cascading Style Sheets) – це мова стилів, яка використовується для опису зовнішнього вигляду HTML-документів. Основне використання – керування стилями елементів, такими як кольори, шрифти, відступи, розміри та розташування на сторінці."
          }
        ]
      }
    ]
  },
  {
    "question": "52. Які способи підключення CSS до HTML ти знаєш?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Є три способи:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вбудований (Inline CSS)",
                "bold": true
              },
              {
                "text": " – через атрибут "
              },
              {
                "text": "style",
                "code": true
              },
              {
                "text": " в HTML-елементі:"
              },
              {
                "type": "code",
                "language": "html",
                "content": "<p style=\"color: red;\">Текст</p>"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вбудований блок (Internal CSS)",
                "bold": true
              },
              {
                "text": " – у "
              },
              {
                "text": "<style>",
                "code": true
              },
              {
                "text": " всередині "
              },
              {
                "text": "<head>",
                "code": true
              },
              {
                "text": ":"
              },
              {
                "type": "code",
                "language": "html",
                "content": "<head>\n  <style>\n    p {\n      color: red;\n    }\n  </style>\n</head>"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зовнішній файл (External CSS)",
                "bold": true
              },
              {
                "text": " – підключення окремого "
              },
              {
                "text": ".css",
                "code": true
              },
              {
                "text": " файлу через "
              },
              {
                "text": "<link>",
                "code": true
              },
              {
                "text": ":"
              },
              {
                "type": "code",
                "language": "html",
                "content": "<head>\n  <link rel=\"stylesheet\" href=\"styles.css\" />\n</head>"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "53. Яка різниця між селекторами класу та ID",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Селектор класу (`.`)",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується для стилізації групи елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Позначається крапкою ("
              },
              {
                "text": ".",
                "code": true
              },
              {
                "text": ") перед назвою класу."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Один клас можна застосувати до багатьох елементів."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<p class=\"text\">Це параграф</p>"
      },
      {
        "type": "code",
        "language": "css",
        "content": ".text {\n  color: blue;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Селектор ID (`#`)",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується для унікального елемента на сторінці."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Позначається решіткою (#) перед назвою ID."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Один ID має бути лише в одному елементі."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<p id=\"unique-text\">Це унікальний параграф</p>"
      },
      {
        "type": "code",
        "language": "css",
        "content": "#unique-text {\n  color: red;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Основні відмінності між селекторами класу та ID"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Характеристика"
            }
          ],
          [
            {
              "text": "Клас ("
            },
            {
              "text": ".",
              "code": true
            },
            {
              "text": ")"
            }
          ],
          [
            {
              "text": "ID ("
            },
            {
              "text": "#",
              "code": true
            },
            {
              "text": ")"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "Призначення",
                "bold": true
              }
            ],
            [
              {
                "text": "Група елементів"
              }
            ],
            [
              {
                "text": "Унікальний елемент"
              }
            ]
          ],
          [
            [
              {
                "text": "Повторне використання",
                "bold": true
              }
            ],
            [
              {
                "text": "Так"
              }
            ],
            [
              {
                "text": "Ні (повинен бути унікальним)"
              }
            ]
          ],
          [
            [
              {
                "text": "Специфічність",
                "bold": true
              }
            ],
            [
              {
                "text": "Менша"
              }
            ],
            [
              {
                "text": "Вища"
              }
            ]
          ]
        ]
      }
    ]
  },
  {
    "question": "54. Що таке псевдокласи в CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдокласи в CSS – це спеціальні ключові слова, які додаються до селекторів і дозволяють стилізувати елементи в залежності від їхнього стану або положення в DOM."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклади псевдокласів:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ":hover",
                "code": true
              },
              {
                "text": " – застосовується, коли користувач наводить курсор на елемент."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":focus",
                "code": true
              },
              {
                "text": " – активується, коли елемент отримує фокус."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":nth-child(n)",
                "code": true
              },
              {
                "text": " – вибирає елементи за їхньою позицією серед братніх елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":first-child",
                "code": true
              },
              {
                "text": " – вибирає перший дочірній елемент."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":last-child",
                "code": true
              },
              {
                "text": " – вибирає останній дочірній елемент."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":checked",
                "code": true
              },
              {
                "text": " – застосовується до вибраних чекбоксів або радіокнопок."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад використання:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "button:hover {\n  background-color: blue;\n  color: white;\n}\n\ninput:focus {\n  border: 2px solid green;\n}\n\nli:nth-child(2) {\n  font-weight: bold;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Важливі особливості:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Псевдокласи не змінюють HTML-структуру, а лише впливають на стилізацію."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Можна комбінувати кілька псевдокласів для одного елемента."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "55. Опишіть, як реалізувати скидання CSS і чому це корисно.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Normalize.css",
                "code": true
              },
              {
                "text": " — не прибирає все, а уніфікує:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Підключаєш файл:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<link\n  rel=\"stylesheet\"\n  href=\"https://necolas.github.io/normalize.css/latest/normalize.css\"\n/>"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Перевага — зберігає корисні стилі, робить вигляд однаковим у всіх браузерах."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Eric Meyer Reset",
                "code": true
              },
              {
                "text": " — агресивне скидання:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "html,\nbody,\ndiv,\nspan,\napplet,\nobject,\niframe,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\np,\nblockquote,\npre,\na,\nabbr,\nacronym,\naddress,\nbig,\ncite,\ncode,\n... {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Мінус: треба переписувати багато стилів з нуля."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Modern CSS Reset — компактна сучасна версія:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n  height: 100%;\n}\n\nimg,\npicture,\nvideo,\ncanvas,\nsvg {\n  display: block;\n  max-width: 100%;\n}\n\ninput,\nbutton,\ntextarea,\nselect {\n  font: inherit;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Ціль — контроль. Без скидання різні браузери дають різні стилі. Це зламає дизайн."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Користь:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Усуває розбіжності в дефолтних стилях між браузерами. Дає чисту стартову точку. Менше багів, стабільніше верстання."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "56. Як ви вибираєте елементи за атрибутами в CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Звернення до атрибутів пишемо у квадратних дужках:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "/* Всі лінки, що відкриваються в новій вкладці */\na[target='_blank'] {\n  color: red;\n}\n\n/* Всі інпути з атрибутом required */\ninput[required] {\n  border: 2px solid orange;\n}\n\n/* Всі кнопки зі специфічним типом */\nbutton[type='submit'] {\n  background-color: green;\n}\n\n/* Всі зображення з alt, що містить слово \"logo\" */\nimg[alt*='logo'] {\n  width: 150px;\n}"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "57. Що таке псевдоелементи і для чого вони використовуються?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Псевдоелементи — це спецконструкції для стилізації частин елементів, яких нема в HTML."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовуються для:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "додавання контенту ("
              },
              {
                "text": "::before",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "::after",
                "code": true
              },
              {
                "text": ")"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "стилізації першої літери або рядка ("
              },
              {
                "text": "::first-letter",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "::first-line",
                "code": true
              },
              {
                "text": ")"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "кастомізації "
              },
              {
                "text": "::placeholder",
                "code": true
              },
              {
                "text": " в інпутах"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад:",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "p::first-line {\n  font-weight: bold;\n}\n\nbutton::after {\n  content: ' →';\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Це дає гнучкість без зайвого HTML."
          }
        ]
      }
    ]
  },
  {
    "question": "58. Поясніть різницю між дочірнім комбінатором і нащадком комбінатора.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Дочірній комбінатор",
                "bold": true
              },
              {
                "text": " ("
              },
              {
                "text": ">",
                "code": true
              },
              {
                "text": ") — стилізує тільки безпосереднього потомка."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Нащадок комбінатор",
                "bold": true
              },
              {
                "text": " ("
              },
              {
                "text": "пробіл",
                "code": true
              },
              {
                "text": ") — стилізує будь-якого нащадка на будь-якій глибині."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "/* Дочірній комбінатор */\ndiv > p {\n  color: blue;\n}\n\n/* Нащадок комбінатор */\ndiv p {\n  color: red;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "У першому випадку — тільки ті "
              },
              {
                "text": "<p>",
                "code": true
              },
              {
                "text": ", що прямо всередині "
              },
              {
                "text": "<div>",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "У другому — всі "
              },
              {
                "text": "<p>",
                "code": true
              },
              {
                "text": ", навіть вкладені через кілька рівнів."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "59. Як би ви вибрали всі прямі дочірні елементи певного типу?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Через дочірній комбінатор "
              },
              {
                "text": ">",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "ul > li {\n  list-style: none;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вибере тільки ті "
              },
              {
                "text": "<li>",
                "code": true
              },
              {
                "text": ", які безпосередньо всередині "
              },
              {
                "text": "<ul>",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "60. Що таке універсальний селектор і однорідний комбінатор, і коли ви їх використаєте?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Універсальний селектор",
                "bold": true
              },
              {
                "text": " ("
              },
              {
                "text": "*",
                "code": true
              },
              {
                "text": ") — вибирає всі елементи."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Однорідний комбінатор",
                "bold": true
              },
              {
                "text": " ("
              },
              {
                "text": "+",
                "code": true
              },
              {
                "text": ") — вибирає елемент, що безпосередньо слідує за іншим."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Коли використовую:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "*",
            "code": true
          },
          {
            "text": " — для глобального скидання стилів:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "* {\n  margin: 0;\n  padding: 0;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "+",
            "code": true
          },
          {
            "text": " — для стилізації сусідніх елементів, наприклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "h1 + p {\n  margin-top: 0;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Працюють швидко, якщо не зловживати."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "61. Що таке CSS Box Model?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "CSS Box Model",
            "bold": true
          },
          {
            "text": " — це структура кожного елемента у вигляді прямокутника, що складається з чотирьох шарів:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Content",
                "code": true
              },
              {
                "text": " — сам вміст (текст, зображення)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Padding",
                "code": true
              },
              {
                "text": " — відступи всередині рамки, навколо контенту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Border",
                "code": true
              },
              {
                "text": " — рамка навколо паддінгу і контенту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Margin",
                "code": true
              },
              {
                "text": " — зовнішній відступ від інших елементів."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Без розуміння "
          },
          {
            "text": "_Box Model_",
            "bold": true
          },
          {
            "text": " верстати нормально не вийде."
          }
        ]
      }
    ]
  },
  {
    "question": "62. Поясніть що таке Margin Collapsing.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Margin Collapsing",
                "bold": true
              },
              {
                "text": " — це коли вертикальні зовнішні відступи двох елементів зливаються в один."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Бере більший з двох "
              },
              {
                "text": "margin",
                "code": true
              },
              {
                "text": ", а не сумує їх."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<div style=\"margin-bottom: 20px;\"></div>\n<div style=\"margin-top: 30px;\"></div>"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Відстань між дивами буде "
              },
              {
                "text": "30px",
                "code": true
              },
              {
                "text": ", а не "
              },
              {
                "text": "50px",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Працює тільки вертикально."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "63. Які є значення і властивості box-sizing і що вони роблять?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Властивість: box-sizing.",
                "bold": true
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Значення:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "content-box",
                "code": true
              },
              {
                "text": " — ширина і висота враховують тільки контент, "
              },
              {
                "text": "padding",
                "code": true
              },
              {
                "text": " і "
              },
              {
                "text": "border",
                "code": true
              },
              {
                "text": " додаються окремо."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "border-box",
                "code": true
              },
              {
                "text": " — ширина і висота включають контент, "
              },
              {
                "text": "padding",
                "code": true
              },
              {
                "text": " і "
              },
              {
                "text": "border",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "64. Як відцентрувати \"div\" за допомогою CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб відцентрувати "
              },
              {
                "text": "<div>",
                "code": true
              },
              {
                "text": " за допомогою "
              },
              {
                "text": "CSS",
                "code": true
              },
              {
                "text": ", можна використовувати кілька підходів. Ось найбільш популярні:"
              }
            ]
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "За допомогою "
              },
              {
                "text": "margin: auto",
                "code": true
              },
              {
                "text": " (для блочних елементів з заданою шириною):"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".element {\n  width: 50%;\n  margin: 0 auto;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Flexbox",
                "code": true
              },
              {
                "text": " (центрування в контейнері):"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n}\n\n.element {\n  width: 50%;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Grid",
                "code": true
              },
              {
                "text": " (центрування в контейнері):"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".container {\n  display: grid;\n  place-items: center;\n  height: 100vh;\n}\n\n.element {\n  width: 50%;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Абсолютне позиціонування з "
              },
              {
                "text": "transform",
                "code": true
              },
              {
                "text": " для точного центрування:"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".container {\n  position: relative;\n  height: 100vh;\n}\n\n.element {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 50%;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Ці методи дозволяють вам відцентрувати "
              },
              {
                "text": "<div>",
                "code": true
              },
              {
                "text": " по горизонталі та/або вертикалі в залежності від вимог."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "65. Яка різниця між block, inline, і inline-block  елементами?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Різниця така:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "block",
                "bold": true
              },
              {
                "text": " — займає всю ширину батьківського елемента, починається з нового рядка. Можна задавати "
              },
              {
                "text": "ширину",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "висоту",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "margin",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "padding",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "inline",
                "bold": true
              },
              {
                "text": " — займає тільки ширину свого контенту, не переноситься на новий рядок. Ширину й висоту задавати неможливо (ігноруються)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "inline-block",
                "bold": true
              },
              {
                "text": " — поводиться як "
              },
              {
                "text": "inline",
                "bold": true
              },
              {
                "text": " (на одному рядку з іншими), але дозволяє задавати "
              },
              {
                "text": "ширину",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "висоту",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "margin",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "padding",
                "code": true
              },
              {
                "text": " як "
              },
              {
                "text": "block",
                "bold": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "66. Поясніть різні значення властивості position.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Властивість position в CSS визначає метод позиціонування елемента в документі. Вона має кілька значень, кожне з яких поводиться по-різному:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "🔹 "
          },
          {
            "text": "static",
            "code": true
          },
          {
            "text": " (за замовчуванням) Опис: Елемент розташовується у нормальному потоці документу."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Не працюють: top, right, bottom, left, z-index."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  position: static;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "🔹 "
          },
          {
            "text": "relative",
            "code": true
          },
          {
            "text": " Опис: Елемент залишається у своєму звичному місці, але його можна зсунути відносно цього місця за допомогою top, left, right, bottom."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Зручно: для створення позиціонованих \"контейнерів\" для absolute."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  position: relative;\n  top: 10px; /* зсувається вниз */\n  left: 20px; /* зсувається вправо */\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "🔹 "
          },
          {
            "text": "absolute",
            "code": true
          },
          {
            "text": " Опис: Елемент вилучається з нормального потоку й позиціонується відносно найближчого предка з position: relative|absolute|fixed|sticky."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Якщо таких предків нема — позиціонується відносно body."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".wrapper {\n  position: relative;\n}\n\n.element {\n  position: absolute;\n  top: 0;\n  right: 0;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "🔹 "
          },
          {
            "text": "fixed",
            "code": true
          },
          {
            "text": " Опис: Елемент фіксується відносно вікна браузера (viewport)."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Залишається на місці при прокручуванні."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  position: fixed;\n  bottom: 0;\n  right: 0;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "🔹 "
          },
          {
            "text": "sticky",
            "code": true
          },
          {
            "text": " Опис: Гібрид relative та fixed."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елемент поводиться як relative, поки не досягне певної позиції при прокрутці — після цього стає fixed."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  position: sticky;\n  top: 0; /* стане фіксованим, коли дійде до верху */\n}"
      }
    ]
  },
  {
    "question": "67. Опишіть z-індекс і те, як порядок стекування контролюється в CSS.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "В CSS z-індекс (z-index) визначає порядок розташування елементів по осі Z — тобто, хто буде «над» ким на екрані."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🧱 Основи стекування (stacking)"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Усі елементи на сторінці утворюють stacking context (контекст накладання), де визначається порядок накладання (тобто, що зверху, а що знизу)."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "🔹 "
          },
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": " Це числове значення, яке вказує порядок стекування елементів. Чим більше значення — тим вище елемент у візуальному стеку."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".box {\n  position: absolute;\n  z-index: 10;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "⚠️ z-index працює тільки на елементах з position значенням relative, absolute, fixed, або sticky."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🔢 Як формується стек:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Контекст накладання (stacking context) починається з html, але може створюватись новими елементами за певних умов."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Новий контекст створюється, коли:"
              },
              {
                "type": "bulletList",
                "children": [
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Елемент має position (relative, absolute, fixed, sticky) + z-index, відмінний від auto."
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "opacity < 1"
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "transform, filter, perspective, will-change, mix-blend-mode і т.д."
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "📚 Приклад стекування"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<div class=\"container\">\n  <div class=\"box box--red\"></div>\n  <div class=\"box box--blue\"></div>\n</div>"
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  position: relative;\n}\n\n.box {\n  position: absolute;\n  width: 100px;\n  height: 100px;\n}\n\n.box--red {\n  background: red;\n  top: 0;\n  left: 0;\n  z-index: 1;\n}\n\n.box--blue {\n  background: blue;\n  top: 20px;\n  left: 20px;\n  z-index: 2;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "🔎 Тут синій блок буде зверху, бо має більший z-index."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "🪜 Пріоритети стекування (спрощено)"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "У межах одного stacking context елементи розташовуються так:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ": negative — позаду всіх"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ": auto (блоки без явного індексу)"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ": 0 і вище — зверху"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "📌 Поради:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Уникай зайвого використання високих z-index (типу 9999). Краще керуй контекстом."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Створюй окремі stacking context-и для складних компонентів (наприклад, модальних вікон)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуй BEM або семантичні класи, щоб зрозуміло керувати елементами в контексті."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "68. Як створити sticky footer за допомогою CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб створити sticky footer (футер, що прилипає до низу сторінки, навіть якщо контенту мало), можна скористатися Flexbox-макетом. Це сучасний, простий і стабільний підхід."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "✅ Готове рішення з поясненням:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<!DOCTYPE html>\n<html lang=\"uk\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Sticky Footer</title>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n      }\n\n      html,\n      body {\n        height: 100%;\n      }\n\n      .layout {\n        min-height: 100%;\n        display: flex;\n        flex-direction: column;\n      }\n\n      .main {\n        flex: 1;\n      }\n\n      .footer {\n        background-color: #333;\n        color: white;\n        padding: 20px;\n        text-align: center;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"layout\">\n      <main class=\"main\">\n        <p>Контент сторінки (може бути короткий)</p>\n      </main>\n      <footer class=\"footer\">\n        <p>Я — футер. Я завжди внизу!</p>\n      </footer>\n    </div>\n  </body>\n</html>"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Як це працює:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "html, body → мають height: 100% — дозволяє контейнеру .layout зайняти всю висоту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ".layout → display: flex; flex-direction: column — компоненти йдуть вертикально."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ".main → flex: 1 — займає всю доступну висоту, «виштовхує» футер вниз."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ".footer → автоматично лишається внизу, навіть коли мало контенту."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "69. Як створити фіксований header, який залишається зверху під час прокручування?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб створити фіксований header, який залишається зверху сторінки під час прокручування, можна використати властивість CSS "
              },
              {
                "text": "position: fixed",
                "code": true
              },
              {
                "text": "."
              },
              {
                "type": "code",
                "language": "html",
                "content": "<header class=\"fixed-header\">\n  <h1>Мій сайт</h1>\n</header>\n\n<main>\n  <p>Контент сторінки...</p>\n  <!-- Багато тексту, щоб зʼявився скрол -->\n</main>"
              }
            ]
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".fixed-header {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 60px; /* висота хедера */\n  background-color: #ffffff;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  z-index: 1000;\n  padding: 10px 20px;\n}\n\n/* Щоб основний контент не ховався під хедером */\nmain {\n  margin-top: 60px; /* дорівнює висоті header */\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Пояснення:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "position: fixed;",
                "code": true
              },
              {
                "text": " — фіксує елемент на місці, незалежно від прокрутки."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "top: 0;",
                "code": true
              },
              {
                "text": " — закріплює хедер до верхнього краю вікна."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "z-index: 1000;",
                "code": true
              },
              {
                "text": " — забезпечує відображення хедера поверх інших елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "margin-top: 60px;",
                "code": true
              },
              {
                "text": " — зміщує основний контент вниз, щоб його не перекрив хедер."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "70. Коли ви використовуєте position: sticky?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "position: sticky",
                "code": true
              },
              {
                "text": " використовується, коли ви хочете, щоб елемент:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "вів себе як звичайний (static або relative)",
                "bold": true
              },
              {
                "text": ", поки не досягне певної позиції (наприклад, верхнього краю екрана),"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "а потім \"прилипав\" (sticky)",
                "bold": true
              },
              {
                "text": " до цієї позиції під час прокрутки."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Коли використовувати position: sticky?"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклади використання:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Заголовки таблиць або розділів, які залишаються зверху, поки не з’явиться наступний."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Меню навігації, що \"прилипає\" після певної прокрутки, але не перекриває весь час."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Фільтри або сайдбари, які залишаються в межах свого батьківського контейнера."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Синтаксис:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".sticky-header {\n  position: sticky;\n  top: 0;\n  background: white;\n  z-index: 10;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Важливо:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Батьківський елемент не повинен мати "
              },
              {
                "text": "overflow: hidden",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "overflow: auto",
                "code": true
              },
              {
                "text": ", інакше "
              },
              {
                "text": "sticky",
                "code": true
              },
              {
                "text": " не працюватиме."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "sticky",
                "code": true
              },
              {
                "text": " працює в межах свого контейнера, тобто \"відлипає\", коли контейнер закінчується."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "71. Як змінити шрифт тексту за допомогою CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб змінити шрифт тексту в CSS, використовується властивість font-family."
              },
              {
                "type": "code",
                "language": "css",
                "content": "p {\n  font-family: 'Arial', sans-serif;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Деталі:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-family приймає список шрифтів через кому."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Перший — основний, далі — запасні (fallback)."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Якщо ні один не підтримується — браузер візьме системний з тієї ж групи (sans-serif, serif, monospace тощо)."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад з Google Fonts:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<!-- index.html -->\n<link\n  href=\"https://fonts.googleapis.com/css2?family=Roboto&display=swap\"\n  rel=\"stylesheet\"\n/>"
      },
      {
        "type": "code",
        "language": "css",
        "content": "body {\n  font-family: 'Roboto', sans-serif;\n}"
      }
    ]
  },
  {
    "question": "72. Що таке «веббезпечний» (web-safe) шрифт у CSS і чому він важливий?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Веббезпечний шрифт (англ. web-safe font) — це шрифт, який вже встановлений на більшості операційних систем (Windows, macOS, Linux). Такий шрифт відображається однаково на різних пристроях, навіть без інтернету чи зовнішнього підключення до шрифтів."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Навіщо це потрібно:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Гарантована підтримка — браузер не шукає, не завантажує, а одразу використовує локальний шрифт."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Швидше завантаження сторінки."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Немає проблем з авторським правом."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклади веббезпечних шрифтів:"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Категорія"
            }
          ],
          [
            {
              "text": "Назва"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "Sans-serif"
              }
            ],
            [
              {
                "text": "Arial, Verdana, Tahoma, Helvetica"
              }
            ]
          ],
          [
            [
              {
                "text": "Serif"
              }
            ],
            [
              {
                "text": "Times New Roman, Georgia"
              }
            ]
          ],
          [
            [
              {
                "text": "Monospace"
              }
            ],
            [
              {
                "text": "Courier New, Lucida Console"
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Як використовувати fallback (резервні шрифти):"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "body {\n  font-family: 'Helvetica', 'Arial', sans-serif;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Якщо перший недоступний — спробує другий, потім третій (системна група)."
          }
        ]
      }
    ]
  },
  {
    "question": "73. Коли доцільно використовувати скорочену (shorthand) властивість font у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Скорочену властивість font у CSS доцільно використовувати тоді, коли потрібно задати кілька параметрів шрифту одночасно, щоб:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "зменшити обсяг коду,"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "забезпечити консистентність стилів,"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "покращити читабельність і продуктивність стилізації."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад використання:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "p {\n  font: italic small-caps bold 16px/1.5 'Arial', sans-serif;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Цей запис одночасно задає:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-style: italic"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-variant: small-caps"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-weight: bold"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-size: 16px"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "line-height: 1.5"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-family: 'Arial', sans-serif"
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Обов’язкові значення:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "При використанні shorthand font треба вказати мінімум:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-size"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-family"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Без них CSS проігнорує весь запис."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Коли НЕ варто використовувати shorthand:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Коли ти хочеш перевизначити тільки одну властивість (наприклад, лише font-weight)."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Коли потрібно уникнути перезапису інших властивостей шрифту."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Підсумок:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовуй font shorthand, коли задаєш кілька параметрів одночасно — це чистіше, швидше і зручніше."
          }
        ]
      }
    ]
  },
  {
    "question": "74. Як додати та використовувати власні (кастомні) шрифти на вебсторінці за допомогою CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб додати власні шрифти (які не входять до стандартних системних), використовують директиву @font-face у CSS. Це дозволяє завантажити шрифт з локального файлу або з сервера."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Кроки для додавання локального кастомного шрифту:"
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Поклади шрифт у папку, напр.:"
              },
              {
                "type": "code",
                "language": "swift",
                "content": "/fonts/open-sans.woff2"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Оголоси шрифт у CSS:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "@font-face {\n  font-family: 'open-sans';\n  src: url('fonts/open-sans.woff2') format('woff2');\n  font-weight: normal;\n  font-style: normal;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використай його:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "body {\n  font-family: 'open-sans', sans-serif;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Пояснення:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "font-family — задає ім’я, яке потім використовуватиметься в CSS."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "src — шлях до шрифту та його формат (woff2 — найоптимальніший)."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Можна підключити кілька варіантів (bold, italic) — треба окремий @font-face для кожного."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Альтернатива — Google Fonts:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<link\n  href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap\"\n  rel=\"stylesheet\"\n/>"
      },
      {
        "type": "code",
        "language": "css",
        "content": "body {\n  font-family: 'Inter', sans-serif;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Рекомендації:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовуй формат .woff2 — мінімальний розмір + найкраща підтримка."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Завжди вказуй fallback-шрифт (наприклад, sans-serif)."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Винось кастомні шрифти у папку fonts/ і називай у kebab-case."
          }
        ]
      }
    ]
  },
  {
    "question": "75. У чому полягає різниця між одиницями em та rem у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Одиниці em та rem — це відносні одиниці вимірювання в CSS, які залежать від розміру шрифту:"
              }
            ]
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Одиниця"
            }
          ],
          [
            {
              "text": "Повна назва"
            }
          ],
          [
            {
              "text": "Залежить від"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "em"
              }
            ],
            [
              {
                "text": "element em"
              }
            ],
            [
              {
                "text": "розміру шрифту батьківського елемента"
              }
            ]
          ],
          [
            [
              {
                "text": "rem"
              }
            ],
            [
              {
                "text": "root em"
              }
            ],
            [
              {
                "text": "розміру шрифту кореневого елемента (html)"
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад: "
          },
          {
            "text": "em",
            "code": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "/* html font-size: 16px */\n\n.container {\n  font-size: 20px;\n}\n\n.container .title {\n  font-size: 2em; /* 2 × 20px = 40px */\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "2em = 2 × 20px, бо береться шрифт батька (.container)"
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад: rem"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "html {\n  font-size: 16px;\n}\n\n.title {\n  font-size: 2rem; /* 2 × 16px = 32px */\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "2rem завжди базується на html, незалежно від ієрархії."
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Коли яку краще використовувати:"
          }
        ]
      },
      {
        "type": "table",
        "header": [
          [
            {
              "text": "Випадок"
            }
          ],
          [
            {
              "text": "Краще використовувати"
            }
          ]
        ],
        "rows": [
          [
            [
              {
                "text": "Потрібна гнучка масштабованість у вкладених блоках"
              }
            ],
            [
              {
                "text": "em"
              }
            ]
          ],
          [
            [
              {
                "text": "Потрібна послідовність по всьому сайту"
              }
            ],
            [
              {
                "text": "rem"
              }
            ]
          ],
          [
            [
              {
                "text": "Margin, padding, line-height — стабільна відстань"
              }
            ],
            [
              {
                "text": "rem"
              }
            ]
          ],
          [
            [
              {
                "text": "Font-size в компонентах, що успадковуються"
              }
            ],
            [
              {
                "text": "em"
              }
            ]
          ]
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Висновок:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "em",
                "code": true
              },
              {
                "text": " — відноситься до батьківського шрифту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "rem",
                "code": true
              },
              {
                "text": " — відноситься до кореневого (html) шрифту."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "В сучасній практиці частіше використовують rem для передбачуваної верстки."
          }
        ]
      }
    ]
  },
  {
    "question": "76. Як правильно додати фонове зображення до елемента в HTML/CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб додати фонове зображення до елемента, використовуємо CSS-властивість background-image. Найчастіше це робиться через CSS-класи або стилі:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Варіант 1: Через CSS-клас",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".hero-section {\n  background-image: url('/images/hero.jpg');\n  background-size: cover; /* масштабування */\n  background-position: center; /* центрування */\n  background-repeat: no-repeat; /* відключення повторення */\n}"
      },
      {
        "type": "code",
        "language": "html",
        "content": "<div class=\"hero-section\">\n  <!-- контент -->\n</div>"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Варіант 2: Inline-стиль (не рекомендовано для масштабних проєктів)",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<div\n  style=\"background-image: url('/images/hero.jpg'); background-size: cover; background-position: center;\"\n></div>"
      }
    ]
  },
  {
    "question": "77. У чому полягає різниця між шістнадцятковим записом кольорів, RGB-форматом і іменованими значеннями в CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Шістнадцяткові коди (Hex)",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Базується на системі числення з основою 16 (від 00 до FF)."
              },
              {
                "type": "code",
                "language": "css",
                "content": "Складається з 3 або 6 символів: #RRGGBB або #RGB\n\n#ffffff — білий\n\n#000000 — чорний\n\nМожна використовувати скорочення: #f00 = #ff0000"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "⛔ Не підтримує прозорість напряму (окрім #rrggbbaa, але підтримка обмежена в старих браузерах)"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "RGB / RGBA",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Працює в десятковій системі: rgb(red, green, blue) з кожним значенням від 0 до 255"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Перевага rgba — можливість встановити прозорість (альфа-канал)"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "color: rgba(255, 0, 0, 0.5); /* напівпрозорий червоний */"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Іменовані кольори",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вбудований набір близько 140 назв кольорів:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "red, blue, green, darkslategray, transparent, тощо"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Зручно для простих UI або для швидкого прототипування"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "❗ Не підходить для складних дизайнів — обмежена палітра, неможливо точно налаштувати відтінки."
          }
        ]
      }
    ]
  },
  {
    "question": "78. Що таке альфа-прозорість у CSS і як працює формат RGBA?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Що таке альфа-прозорість? Альфа-прозорість (або alpha channel) — це параметр, який визначає ступінь прозорості кольору. Значення прозорості задається числом від 0 до 1:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "0 — повністю прозорий"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "1 — повністю непрозорий (суцільний колір)"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Наприклад: 0.5 — 50% прозорості"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "RGBA",
                "code": true
              },
              {
                "text": " — це розширення формату "
              },
              {
                "text": "RGB",
                "code": true
              },
              {
                "text": ", яке додає альфа-канал:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "color: rgba(R, G, B, A);"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "R — Red (червоний): 0–255"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "G — Green (зелений): 0–255"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "B — Blue (синій): 0–255"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "A — Alpha (прозорість): 0–1"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "📘 Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "background-color: rgba(0, 0, 255, 0.3); /* синій з 30% непрозорістю */"
      }
    ]
  },
  {
    "question": "79. Як створити градієнтний фон у CSS і які є типи градієнтів?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Лінійний градієнт (linear-gradient)",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "background: linear-gradient(to right, #ff7e5f, #feb47b);"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "to right — напрям (може бути: to left, to bottom, 45deg, тощо)"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "#ff7e5f — стартовий колір"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "#feb47b — кінцевий колір"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад для кнопки:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "button {\n  background: linear-gradient(to bottom right, #4facfe, #00f2fe);\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Радіальний градієнт (radial-gradient)",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "background: radial-gradient(circle, #ff9a9e, #fad0c4);"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Центрований круговий перехід кольорів"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Можна змінювати форму: circle, ellipse"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "div {\n  background: radial-gradient(circle at center, #ff9a9e 0%, #fad0c4 100%);\n}"
      }
    ]
  },
  {
    "question": "80. Як реалізувати кілька фонів (background layers) для одного елемента в CSS і як вони працюють?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS дозволяє використовувати кілька фонів одночасно в одному елементі, наприклад:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "градієнт + зображення"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "кілька іконок"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "шар затемнення + фонова картинка"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Синтаксис:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "background-image: url('stars.png'), linear-gradient(to bottom, #000000aa, #00000000);"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Головна ідея:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Фони вказуються через кому"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перший — верхній шар, останній — нижній (базовий)"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад — градієнт поверх зображення:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  background-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0)),\n    /* верхній шар */ url('/images/bg.jpg'); /* нижній шар */\n\n  background-size: cover, cover;\n  background-position: center, center;\n  background-repeat: no-repeat, no-repeat;\n}"
      }
    ]
  },
  {
    "question": "81. Що таке Flexbox у CSS, які його ключові властивості та основні переваги у верстці?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Flexbox — це одновимірна модель розмітки в CSS, яка дозволяє гнучко розташовувати та вирівнювати елементи в ряд або стовпчик."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Ключові властивості:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "display: flex",
                "code": true
              },
              {
                "text": " — активує флекс-контейнер"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "flex-direction",
                "code": true
              },
              {
                "text": " — напрямок (row, column)"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "justify-content",
                "code": true
              },
              {
                "text": " — вирівнювання по головній осі"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "align-items",
                "code": true
              },
              {
                "text": " — вирівнювання по поперечній осі"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "gap",
                "code": true
              },
              {
                "text": " — відстань між елементами"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "flex",
                "code": true
              },
              {
                "text": " — керує розміром елементів (grow, shrink, basis)"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Переваги:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Просте вирівнювання по обох осях"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Адаптивність без медіа-запитів"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Підтримка переносу рядків (flex-wrap)"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Менше хаків і простіший код"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "82. Як працює властивість flex-grow у CSS Flexbox?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "flex-grow",
                "code": true
              },
              {
                "text": " визначає, наскільки елемент може збільшуватись у розмірі, щоб зайняти вільний простір у флекс-контейнері."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".item {\n  flex-grow: 1;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Це означає, що елемент отримає частку вільного простору пропорційно значенню flex-grow."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Наприклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<div class=\"box\" style=\"flex-grow: 1;\"></div>\n<div class=\"box\" style=\"flex-grow: 2;\"></div>"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Другий блок займе вдвічі більше простору, ніж перший."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "83. У чому різниця між justify-content та align-items у Flexbox?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "justify-content",
                "code": true
              },
              {
                "text": " — вирівнює елементи по головній осі (горизонтальній за замовчуванням)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Напр.: flex-start, center, space-between",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "align-items",
                "code": true
              },
              {
                "text": " — вирівнює елементи по поперечній осі (вертикальній за замовчуванням)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Напр.: stretch, center, flex-end",
            "bold": true
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  display: flex;\n  justify-content: center; /* по горизонталі */\n  align-items: center; /* по вертикалі */\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Головне:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Напрям justify-content змінюється з flex-direction."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "align-items — завжди перпендикулярна до нього."
          }
        ]
      }
    ]
  },
  {
    "question": "84. У яких випадках доцільно використовувати align-self у Flexbox?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "align-self",
                "code": true
              },
              {
                "text": " дозволяє перевизначити вирівнювання одного окремого елемента по поперечній осі, незалежно від align-items контейнера."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".item {\n  align-self: flex-end;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Цей елемент буде вирівняний донизу, навіть якщо інші — по центру або розтягнуті."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Використовуйте align-self, коли:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "потрібно виділити один елемент в групі (наприклад, останній пункт у меню — вирівняти вниз);"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "елемент має іншу висоту або позицію, ніж решта;"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "потрібно точково налаштувати позицію без впливу на інші елементи."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "85. Як у Flexbox створити стовпці однакової ширини незалежно від їхнього вмісту?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб створити стовпці однакової ширини у Flexbox, кожному елементу задаємо:"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".item {\n  flex: 1;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "А контейнеру:"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".container {\n  display: flex;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Пояснення:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "flex: 1 = flex-grow: 1; flex-shrink: 1; flex-basis: 0;"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Усі елементи ділять простір порівну, незалежно від вмісту."
          }
        ]
      }
    ]
  },
  {
    "question": "86. Що таке CSS Grid Layout і чому він корисний у веброзробці?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS Grid — це система двовимірного макетування, яка дозволяє створювати складні сітки з рядками та стовпцями. Вона спрощує позиціонування елементів на сторінці без потреби у флоатах або флексах. Корисна для адаптивних і структурованих дизайнів."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "87. Як у CSS Grid визначити кількість стовпців і рядків сітки?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Стовпці задаються через "
              },
              {
                "text": "grid-template-columns",
                "code": true
              },
              {
                "text": ", а рядки — через "
              },
              {
                "text": "grid-template-rows",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Наприклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "display: grid;\ngrid-template-columns: 1fr 2fr;\ngrid-template-rows: 100px auto;"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Це створить сітку з 2 стовпцями та 2 рядками."
          }
        ]
      }
    ]
  },
  {
    "question": "88. У чому різниця між grid-template-areas та grid-template-columns?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Відповідь:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "grid-template-columns",
                "code": true
              },
              {
                "text": " задає ширину стовпців сітки (кількість і розміри)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "grid-template-areas",
                "code": true
              },
              {
                "text": " задає візуальне розміщення іменованих областей у сітці для зручного позиціонування елементів за назвами."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "grid-template-columns: 1fr 1fr;\ngrid-template-areas:\n  'header header'\n  'sidebar main';"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Це визначає 2 стовпці однакової ширини та розкладку з іменами областей."
          }
        ]
      }
    ]
  },
  {
    "question": "89. Як розмістити елементи в сітці CSS Grid?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Відповідь:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Елементи розміщуються за допомогою властивостей:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "grid-row, grid-column — для вказання позицій (наприклад, grid-column: 1 / 3)"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "grid-area — якщо використовується grid-template-areas"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Автоматично — якщо не задані координати, елементи розміщуються у вільні клітинки"
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".item {\n  grid-column: 2 / 4;\n  grid-row: 1 / 2;\n}"
      }
    ]
  },
  {
    "question": "90. Як CSS Grid обробляє перекриття елементів, якщо вони займають одні й ті самі області?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Відповідь:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Якщо кілька елементів займають одну й ту саму область сітки, вони перекриваються, і порядок їх відображення залежить від:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Порядку в "
          },
          {
            "text": "HTML",
            "code": true
          },
          {
            "text": " (останній — зверху)"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "z-index",
            "code": true
          },
          {
            "text": " — якщо заданий"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "position",
            "code": true
          },
          {
            "text": "— якщо елементи позиціоновані"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб уникнути перекриття — уникай однакових координат або використовуй z-index для керування шарами."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "91. Що таке медіа-запит?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Медіа-запит (media query) — це інструмент CSS, що дозволяє застосовувати стилі залежно від характеристик пристрою (ширини екрана, орієнтації, роздільної здатності тощо)."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@media (max-width: 768px) {\n  body {\n    background-color: lightgray;\n  }\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Цей стиль застосовується лише, якщо ширина екрана ≤ 768px."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "92. Як метатег viewport допомагає у створенні адаптивного дизайну для мобільних пристроїв?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Метатег viewport керує тим, як сторінка масштабується та відображається на мобільних пристроях. Без нього сторінка відображається з масштабом, як для десктопа."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Що робить:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "width=device-width",
                "code": true
              },
              {
                "text": " — встановлює ширину вікна відповідно до ширини пристрою."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "initial-scale=1.0",
                "code": true
              },
              {
                "text": " — встановлює початковий масштаб."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Результат: коректне масштабування і адаптивність для різних екранів."
          }
        ]
      }
    ]
  },
  {
    "question": "93. Опишіть, як створити адаптивний дизайн, орієнтований на мобільні пристрої.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб створити адаптивний мобільний дизайн:"
              }
            ]
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використай метатег viewport:"
              },
              {
                "type": "code",
                "language": "html",
                "content": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуй гнучкі одиниці виміру:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "%, vw, vh, em, rem замість px."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Застосовуй медіа-запити:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Щоб змінювати стилі під різні розміри екранів:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@media (max-width: 768px) {\n  .menu {\n    flex-direction: column;\n  }\n}"
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Flexbox або CSS Grid:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Для побудови гнучких макетів."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Уникай фіксованої ширини елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Забезпечуй адаптивні зображення:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Встановлюй max-width: 100%; height: auto;."
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Це дозволяє інтерфейсу підлаштовуватись під різні розміри екранів без горизонтальної прокрутки."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "94. Як можна створити макет, який змінюється з двоколонкового на одноколонковий, за допомогою медіа-запитів?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Створи двоколонковий макет (наприклад, з CSS Grid або Flexbox), а потім через медіа-запит змінюй його на одноколонковий при меншій ширині екрана."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад (Flexbox):"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  display: flex;\n  gap: 20px;\n}\n\n@media (max-width: 768px) {\n  .container {\n    flex-direction: column;\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад (CSS Grid):"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 20px;\n}\n\n@media (max-width: 768px) {\n  .container {\n    grid-template-columns: 1fr;\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Результат:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "На великих екранах — 2 колонки, на мобільних — 1 колонка."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "95. Поясніть використання min-width та max-width у медіа-запитах.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "min-width",
                "code": true
              },
              {
                "text": " і "
              },
              {
                "text": "max-width",
                "code": true
              },
              {
                "text": " у медіа-запитах визначають діапазон ширини екрана, на який мають застосовуватись стилі."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "min-width — стилі застосовуються від цієї ширини і вище (mobile-first підхід)."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@media (min-width: 768px) {\n  body {\n    background-color: lightblue;\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "max-width — стилі застосовуються до цієї ширини включно."
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@media (max-width: 767px) {\n  body {\n    background-color: lightgray;\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Використання:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "min-width",
                "code": true
              },
              {
                "text": " — адаптація від мобільного до десктопа."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "max-width",
                "code": true
              },
              {
                "text": " — адаптація від десктопа до мобільного."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Зазвичай рекомендується "
          },
          {
            "text": "mobile-first",
            "code": true
          },
          {
            "text": " підхід з "
          },
          {
            "text": "min-width",
            "code": true
          },
          {
            "text": "."
          }
        ]
      }
    ]
  },
  {
    "question": "96. Як створити перехід CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перехід у CSS (transition) дозволяє анімувати зміну властивостей елементів, таких як колір, розмір чи положення, коли вони змінюються."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Основний синтаксис:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  transition: property duration timing-function delay;\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  background-color: blue;\n  transition: background-color 0.3s ease;\n}\n\n.element:hover {\n  background-color: red;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "У цьому прикладі, коли елемент отримує ховер, його колір плавно змінюється з синього на червоний за 0.3 секунди."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Пояснення:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "background-color",
            "code": true
          },
          {
            "text": " — властивість, що анімується."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "0.3s",
            "code": true
          },
          {
            "text": " — тривалість анімації."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "ease",
            "code": true
          },
          {
            "text": " — функція часу для плавності."
          }
        ]
      }
    ]
  },
  {
    "question": "97. У чому різниця між переходом CSS та анімацією?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS Transition і CSS Animation обидва використовуються для створення анімацій, але є важливі відмінності в їх підході та використанні:"
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "CSS Transition:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Триггер: анімація починається тільки тоді, коли відбувається зміна стану елемента (наприклад, при ховері або кліку)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Обмеження: можна анімувати лише зміни існуючих стилів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Синтаксис: простіший, зазвичай використовується для ефектів при взаємодії з користувачем."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  background-color: blue;\n  transition: background-color 0.3s ease;\n}\n\n.element:hover {\n  background-color: red;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Тут зміна кольору відбудеться тільки при ховері."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "CSS Animation:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Триггер: анімація запускається автоматично або за заданим ключовим кадром."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Гнучкість: дозволяє задавати послідовність анімацій за допомогою @keyframes, де можна визначити кілька етапів анімації."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Без взаємодії: анімація може працювати без будь-якої взаємодії з користувачем."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@keyframes example {\n  0% {\n    background-color: blue;\n  }\n  100% {\n    background-color: red;\n  }\n}\n\n.element {\n  animation: example 2s infinite;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "У цьому прикладі анімація почнеться автоматично і повторюватиметься нескінченно."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Основні відмінності:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Transition: працює лише на зміну стану (наприклад, ховер або фокус)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Animation: дозволяє створювати складні анімації з багатьма етапами й автоматичним запуском."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "98. Які способи є для анімації появи та зникнення елемента на сторінці??",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Можна використати CSS-анімації або transition у поєднанні з класами (наприклад, opacity + transform), або бібліотеки типу Framer Motion / React Transition Group для керування станом появи/зникнення."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "99. Можете пояснити, як працює та використовується @keyframes у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "@keyframes",
                "code": true
              },
              {
                "text": " визначає проміжні стани анімації в CSS."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Синтаксис:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n.element {\n  animation: fadeIn 0.5s ease-in;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується з властивістю "
              },
              {
                "text": "animation",
                "code": true
              },
              {
                "text": " для запуску анімації."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "100. Як налаштувати функцію прискорення в CSS-анімації?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Функції синхронізації задають, як змінюється швидкість анімації протягом часу."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Встановлюються через "
          },
          {
            "text": "animation-timing-function",
            "code": true
          },
          {
            "text": ", приклади:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "linear",
                "code": true
              },
              {
                "text": " — рівномірно."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "ease",
                "code": true
              },
              {
                "text": " — повільний старт і кінець."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "ease-in",
                "code": true
              },
              {
                "text": " — повільний старт."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "ease-out",
                "code": true
              },
              {
                "text": " — повільний кінець."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "ease-in-out",
                "code": true
              },
              {
                "text": " — повільний старт і кінець, швидко посередині."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "cubic-bezier(x1, y1, x2, y2)",
                "code": true
              },
              {
                "text": " — кастомна крива."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "101. Що таке CSS-препроцесор і які його переваги?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-препроцесор — це інструмент (наприклад, Sass, LESS, Stylus), який розширює можливості CSS: змінні, вкладені селектори, міксіни, функції."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується для структурованішого, повторно використовуваного та легше підтримуваного коду."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "102. Яке значення мають CSS-змінні та чому їх варто використовувати?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-змінні "
              },
              {
                "text": "(--var-name)",
                "code": true
              },
              {
                "text": " дозволяють зберігати значення в одному місці та використовувати їх повторно по всьому проєкту."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Переваги:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Легко оновлювати тему/стиль."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Підтримують динамічні зміни через JS."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зменшують дублювання коду."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "103. Що таке CSS-модулі та як їх застосовувати?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-модулі — це підхід, де стилі автоматично обмежуються тільки тим компонентом, у якому їх імпортують (ізольований скоуп)."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Використання в React:"
          }
        ]
      },
      {
        "type": "code",
        "language": "jsx",
        "content": "import styles from './Button.module.css';\n\n<button className={styles.primary}>Click</button>;"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Переваги — уникнення конфліктів імен класів та краща підтримка коду."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "104. Що таке CSS-in-JS і які його переваги?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-in-JS",
                "code": true
              },
              {
                "text": " — це підхід, коли стилі пишуться безпосередньо в JavaScript/TypeScript-файлах, часто прив’язані до компонентів."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклади: styled-components, Emotion."
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Переваги:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Ізоляція стилів на рівні компонентів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Динамічні стилі через пропси/стан."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Спільний код JS і стилів."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "105. Які інструменти використовуються для лінтингу та форматування CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для лінтингу — Stylelint (перевірка якості та відповідності стилів стандартам)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для форматування — Prettier (автоматичне вирівнювання й оформлення коду)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Часто інтегруються разом у CI/CD та редактор."
          }
        ]
      }
    ]
  },
  {
    "question": "106. Як зробити, щоб кнопка виглядала як звичайне посилання?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Просто прибрати стандартні стилі кнопки та застосувати стилі посилання:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "button {\n  background: none;\n  border: none;\n  color: blue;\n  text-decoration: underline;\n  cursor: pointer;\n}"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "107. Як створити кастомні чекбокси та радіокнопки за допомогою CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Роблять прихований "
              },
              {
                "text": "<input type=\"checkbox/radio\">",
                "code": true
              },
              {
                "text": " і стилізують його пов’язаний "
              },
              {
                "text": "<label>",
                "code": true
              },
              {
                "text": " або псевдоелементи ("
              },
              {
                "text": "::before",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "::after",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Стан "
              },
              {
                "text": ":checked",
                "code": true
              },
              {
                "text": " використовують для зміни стилю при виборі."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "input[type='checkbox'] {\n  display: none;\n}\n\nlabel::before {\n  content: '';\n  width: 16px;\n  height: 16px;\n  border: 1px solid #000;\n  display: inline-block;\n}\n\ninput:checked + label::before {\n  background: #000;\n}"
      }
    ]
  },
  {
    "question": "108. Як можна стилізувати елемент select лише за допомогою CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовують селектор "
              },
              {
                "text": "select",
                "code": true
              },
              {
                "text": " і його внутрішні елементи, але можливості обмежені через нативний рендер браузера."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Основні прийоми:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "appearance: none;",
            "code": true
          },
          {
            "text": " / "
          },
          {
            "text": "-webkit-appearance: none;",
            "code": true
          },
          {
            "text": " — прибрати стандартну стрілку."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Додати власну іконку через "
          },
          {
            "text": "background",
            "code": true
          },
          {
            "text": " або "
          },
          {
            "text": "::after",
            "code": true
          },
          {
            "text": " у контейнері."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Стилізувати "
          },
          {
            "text": "option",
            "code": true
          },
          {
            "text": " (шрифт, колір, фон), але в різних браузерах підтримка різна."
          }
        ]
      }
    ]
  },
  {
    "question": "109. Яка найкраща практика для стилізації плейсхолдера у полі введення?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати псевдоклас "
              },
              {
                "text": "::placeholder",
                "code": true
              },
              {
                "text": " для зміни стилю заповнювача, зберігаючи достатній контраст і читабельність."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "input::placeholder {\n  color: #888;\n  font-style: italic;\n}"
      }
    ]
  },
  {
    "question": "110. Як правильно реалізувати стилі фокуса для забезпечення доступності?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовують псевдоклас "
              },
              {
                "text": ":focus",
                "code": true
              },
              {
                "text": " (і бажано "
              },
              {
                "text": ":focus-visible",
                "code": true
              },
              {
                "text": ") для чіткого візуального індикатора."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Найкраща практика — не прибирати "
              },
              {
                "text": "outline",
                "code": true
              },
              {
                "text": ", а кастомізувати його:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "button:focus-visible {\n  outline: 2px solid #000;\n  outline-offset: 2px;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Це допомагає користувачам з клавіатурною навігацією."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "111. Як діагностувати і виправити проблеми з версткою?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуй "
              },
              {
                "text": "DevTools",
                "code": true
              },
              {
                "text": " (інспектор) для перевірки стилів, розмірів, відступів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевіряй "
              },
              {
                "text": "flexbox/grid",
                "code": true
              },
              {
                "text": " налаштування, "
              },
              {
                "text": "display",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "position",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Шукай проблеми з переповненням, "
              },
              {
                "text": "z-index",
                "code": true
              },
              {
                "text": ", або невірними розмірами."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуй тимчасові кольори/рамки для візуалізації блоків."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевіряй адаптивність на різних екранах."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "112. Як виправити проблеми з пошкодженими колонками у макеті?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевір:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "чи правильно заданий "
              },
              {
                "text": "display",
                "code": true
              },
              {
                "text": " ("
              },
              {
                "text": "flex",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "grid",
                "code": true
              },
              {
                "text": ") на контейнері;"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "чи всі колонки мають коректні розміри ("
              },
              {
                "text": "flex-basis",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "width",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "grid-template-columns",
                "code": true
              },
              {
                "text": ");"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "чи немає зайвих "
              },
              {
                "text": "margin/padding",
                "code": true
              },
              {
                "text": ", що зрушують колонки;"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "чи не порушує макет "
              },
              {
                "text": "box-sizing",
                "code": true
              },
              {
                "text": " (краще "
              },
              {
                "text": "border-box",
                "code": true
              },
              {
                "text": ");"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "чи не спричиняє проблеми "
              },
              {
                "text": "overflow",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "min-width",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Часто допомагає тимчасове підсвічування меж ("
          },
          {
            "text": "outline: 1px solid red",
            "code": true
          },
          {
            "text": ")."
          }
        ]
      }
    ]
  },
  {
    "question": "113. Як вирішувати проблеми кросбраузерності у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуй префікси ("
              },
              {
                "text": "-webkit-",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "-moz-",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "-ms-",
                "code": true
              },
              {
                "text": ") для нових властивостей (через "
              },
              {
                "text": "Autoprefixer",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевіряй підтримку фіч на "
              },
              {
                "text": "Can I Use",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуй "
              },
              {
                "text": "fallbacks",
                "code": true
              },
              {
                "text": " — запасні стилі для старих браузерів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Уникай нестабільних експериментальних властивостей."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Тестуй на основних браузерах і версіях."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "За потреби — поліполіфи або JavaScript-обхідники."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "114. Як визначити, який CSS стиль переважає при конфлікті?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевіряй через "
              },
              {
                "text": "DevTools",
                "code": true
              },
              {
                "text": " вкладку "
              },
              {
                "text": "Styles",
                "code": true
              },
              {
                "text": " — показує застосовані стилі, їх пріоритет і джерело."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Пріоритет визначається специфічністю селекторів, важливістю ("
              },
              {
                "text": "!important",
                "code": true
              },
              {
                "text": ") і порядком підключення."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Правила:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Inline стилі мають вищий пріоритет."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Специфічніші селектори переважають універсальні."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Пізніші оголошення перекривають ранні."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "115. Які CSS проблеми можуть погіршувати продуктивність?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Занадто складні селектори (особливо універсальні "
              },
              {
                "text": "*",
                "code": true
              },
              {
                "text": " або глибокі вкладення)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Часті зміни "
              },
              {
                "text": "layout (reflow)",
                "code": true
              },
              {
                "text": " через властивості типу "
              },
              {
                "text": "width",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "height",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "margin",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "padding",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання "
              },
              {
                "text": "!important",
                "code": true
              },
              {
                "text": ", що ускладнює перезапис стилів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Велика кількість анімацій або трансформацій без апаратного прискорення."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Надмірний використання глобальних стилів і дублювання."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "116. Як застосовувати 3D-перетворення в CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "В CSS 3D-перетворення застосовують через властивості:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "transform: rotateX(), rotateY(), rotateZ()",
                "code": true
              },
              {
                "text": " — обертання по осях."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "transform: translateZ()",
                "code": true
              },
              {
                "text": " — переміщення по Z-ось."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "perspective",
                "code": true
              },
              {
                "text": " — задає глибину (перспективу) контейнеру."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "transform-style: preserve-3d",
                "code": true
              },
              {
                "text": " — для вкладених елементів, щоб зберегти 3D ефект."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  perspective: 600px;\n}\n\n.element {\n  transform-style: preserve-3d;\n  transform: rotateY(45deg);\n}"
      }
    ]
  },
  {
    "question": "117. Як працює і як використовувати властивість perspective у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "perspective",
                "code": true
              },
              {
                "text": " задає відстань від глядача до площини елемента, створюючи ефект глибини для 3D-перетворень."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Синтаксис:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  perspective: 500px; /* менше значення — сильніша перспектива */\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Властивість застосовується до батьківського елемента, а дочірні з transform із 3D-перетвореннями використовують цю перспективу."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "118. Що таке backface-visibility у CSS і як його використовувати?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Видимість задньої поверхні ("
              },
              {
                "text": "backface-visibility",
                "code": true
              },
              {
                "text": ") — це CSS-властивість, яка визначає, чи видно ли задню сторону елемента при його 3D-обертанні."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "visible",
                "code": true
              },
              {
                "text": " — задня сторона показується (за замовчуванням)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "hidden",
                "code": true
              },
              {
                "text": " — задня сторона прихована, не відображається при обертанні на 180°."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".element {\n  backface-visibility: hidden;\n}"
      }
    ]
  },
  {
    "question": "119. Як зробити ефект перевернутої картки (card flip) на CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Створюють контейнер з двома сторонами ("
              },
              {
                "text": "front",
                "code": true
              },
              {
                "text": " і "
              },
              {
                "text": "back",
                "code": true
              },
              {
                "text": "), використовують 3D-перетворення і "
              },
              {
                "text": "backface-visibility: hidden",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  perspective: 1000px;\n}\n\n.card {\n  width: 200px;\n  height: 300px;\n  position: relative;\n  transform-style: preserve-3d;\n  transition: transform 0.6s;\n}\n\n.card:hover {\n  transform: rotateY(180deg);\n}\n\n.front,\n.back {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  backface-visibility: hidden;\n}\n\n.back {\n  transform: rotateY(180deg);\n}"
      }
    ]
  },
  {
    "question": "120. Які візуальні ефекти можна створити за допомогою CSS-фільтрів?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-фільтри дають змогу створювати ефекти:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "blur()",
            "code": true
          },
          {
            "text": " — розмиття"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "brightness()",
            "code": true
          },
          {
            "text": " — яскравість"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "contrast()",
            "code": true
          },
          {
            "text": " — контраст"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "grayscale()",
            "code": true
          },
          {
            "text": " — відтінки сірого"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "invert()",
            "code": true
          },
          {
            "text": " — інверсія кольорів"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "sepia()",
            "code": true
          },
          {
            "text": " — сепія"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "saturate()",
            "code": true
          },
          {
            "text": " — насиченість"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "drop-shadow()",
            "code": true
          },
          {
            "text": " — тінь"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Їх можна комбінувати через пробіл:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "filter: grayscale(50%) blur(2px);"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "121. Які основні принципи адаптивного вебдизайну?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Основні принципи адаптивного вебдизайну:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Гнучка сітка (flex, grid, % замість фіксованих px)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Гнучкі зображення та медіа (max-width: 100%)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Media queries для різних розмірів екранів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Мобільний підхід спочатку (mobile-first)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Тестування на різних пристроях і орієнтаціях."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "122. Як створити сіткову систему за допомогою CSS Grid?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Створюю контейнер з display: grid."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Визначаю колонки та рядки через grid-template-columns / grid-template-rows (можна з fr, auto, %)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Додаю проміжки (gap)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для адаптивності — змінюю налаштування через @media або repeat(auto-fit, minmax())."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": ".container {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 16px;\n}"
      }
    ]
  },
  {
    "question": "123. Що таке mobile-first підхід у вебдизайні?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Mobile-first — підхід, коли дизайн і верстка спочатку створюються для мобільних пристроїв (малий екран), а потім розширюються для більших екранів через min-width media queries."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Переваги:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Оптимізація продуктивності для мобільних."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Краща доступність і зручність."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Легше масштабувати до desktop, ніж навпаки."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "124. Які способи підтримати співвідношення сторін в адаптивному дизайні?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Методи підтримки співвідношення сторін:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "aspect-ratio",
                "code": true
              },
              {
                "text": " (сучасний спосіб):"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".box {\n  aspect-ratio: 16 / 9;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Через "
              },
              {
                "text": "padding-хаки",
                "code": true
              },
              {
                "text": " (старий спосіб, "
              },
              {
                "text": "padding-top",
                "code": true
              },
              {
                "text": " у "
              },
              {
                "text": "%",
                "code": true
              },
              {
                "text": " від ширини)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "SVG",
                "code": true
              },
              {
                "text": " та "
              },
              {
                "text": "viewBox",
                "code": true
              },
              {
                "text": " для масштабованих елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Контейнер із "
              },
              {
                "text": "object-fit",
                "code": true
              },
              {
                "text": " для медіа (зображення, відео)."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "125. Як забезпечити доступність і інклюзивність вебдизайну?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для доступності та інклюзивності дотримуюсь принципів WCAG:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Контраст тексту ≥ 4.5:1."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Чіткі "
              },
              {
                "text": "focus-стилі",
                "code": true
              },
              {
                "text": " для клавіатурної навігації."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Альтернативний текст ("
              },
              {
                "text": "alt",
                "code": true
              },
              {
                "text": ") для зображень."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Семантична "
              },
              {
                "text": "HTML-розмітка",
                "code": true
              },
              {
                "text": " (заголовки, списки, "
              },
              {
                "text": "<button>",
                "code": true
              },
              {
                "text": " замість "
              },
              {
                "text": "div",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "ARIA-атрибути",
                "code": true
              },
              {
                "text": ", якщо стандартної семантики недостатньо."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевірка з екранними рідерами."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Не покладатися тільки на колір для передачі інформації."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "126. Як додати таблицю стилів для друку на вебсторінці?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Створюють окремі стилі з медіатипом print:"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "_Через окремий файл:_",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<link rel=\"stylesheet\" href=\"print.css\" media=\"print\" />"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "_Або всередині CSS:_",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "@media print {\n  body {\n    color: black;\n    background: white;\n  }\n\n  nav,\n  footer {\n    display: none;\n  }\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується для спрощення макета, видалення непотрібних елементів і оптимізації читабельності при друку."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "127. Які best practices при створенні CSS для друку?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Найкращі практики для CSS-друку:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Прибрати непотрібні елементи (nav, footer, рекламу)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зробити фон білим, текст чорним для читабельності."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати читабельний шрифт без надмірних стилів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Показувати посилання як текстові URL (a::after { content: attr(href) })."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Оптимізувати відступи та розміри для формату сторінки."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевіряти друк у різних браузерах."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "128. Як використовувати розрив сторінки в CSS для друку?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Розрив сторінки в CSS керується властивостями page-break-before, page-break-after, page-break-inside (застарілі) або їх новими аналогами — break-before, break-after, break-inside."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "h2 {\n  break-before: page; /* Почати з нової сторінки при друку */\n}\n\nsection {\n  break-inside: avoid; /* Не розривати всередині секції */\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується у друкованих стилях, щоб контролювати, де сторінка має ділитися."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "129. Як протестувати версію вебсторінки для друку?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Тестують версію для друку так:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "У браузері відкрити Print Preview (Ctrl+P / Cmd+P)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "У DevTools вибрати emulate print media (Chrome: More tools → Rendering → Emulate CSS media: print)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевірити відображення в різних браузерах (Chrome, Firefox, Edge)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "За потреби протестувати на реальному принтері або PDF-експортері."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "130. Які типові проблеми виникають при розробці CSS для друку?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Поширені труднощі при створенні CSS для друку:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Різна підтримка друкованих стилів у браузерах."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Відсутність відтворення фону або зображень за замовчуванням."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Неконтрольовані розриви сторінок у великому контенті."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Неправильні пропорції зображень чи таблиць."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Проблеми з шрифтами при друкуванні у PDF."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Важко зберегти точне позиціонування без порушення адаптивності."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "131. Для чого призначені псевдоелементи ::before і ::after у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "::before",
                "code": true
              },
              {
                "text": " і "
              },
              {
                "text": "::after",
                "code": true
              },
              {
                "text": " створюють віртуальні елементи до або після вмісту вибраного елемента. Використовуються для декоративного або додаткового контенту без зміни HTML."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "button::before {\n  content: '→ ';\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Особливості:"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Працюють тільки з властивістю content."
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Не впливають на DOM, але беруть участь у візуальному рендері."
          }
        ]
      }
    ]
  },
  {
    "question": "132. Що таке псевдоклас :hover у CSS і як він працює?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ":hover — псевдоклас, що застосовує стилі, коли користувач наводить курсор миші на елемент."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "a:hover {\n  color: red;\n}"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Працює тільки для інтерактивних пристроїв з курсором (на сенсорних — обмежено)."
          }
        ]
      }
    ]
  },
  {
    "question": "133. У чому різниця між :nth-child та :nth-of-type у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ":nth-child(n)",
                "code": true
              },
              {
                "text": " — вибирає елемент, якщо він є n-м дочірнім серед усіх елементів батька."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":nth-of-type(n)",
                "code": true
              },
              {
                "text": " — вибирає елемент, якщо він є n-м дочірнім серед елементів того ж типу."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "p:nth-child(2)      /* другий дочірній елемент, неважливо, p це чи ні */\np:nth-of-type(2)    /* другий <p> серед усіх <p> */"
      }
    ]
  },
  {
    "question": "134. Як працюють псевдокласи :first-child і :last-child у CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ":first-child",
                "code": true
              },
              {
                "text": " вибирає елемент, якщо він перший серед усіх дочірніх елементів свого батька."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": ":last-child",
                "code": true
              },
              {
                "text": " — якщо він останній серед дочірніх."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "li:first-child {\n  font-weight: bold;\n}\n\nli:last-child {\n  color: red;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Важливо: вони дивляться на позицію, а не на тип елемента (на відміну від "
              },
              {
                "text": ":first-of-type",
                "code": true
              },
              {
                "text": " / "
              },
              {
                "text": ":last-of-type",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "135. Що таке псевдоклас :not у CSS і для чого він використовується?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": ":not(селектор)",
                "code": true
              },
              {
                "text": " — псевдоклас, що вибирає елементи, які не відповідають вказаному селектору."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "css",
        "content": "button:not(.primary) {\n  background: gray;\n}"
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовується, коли треба застосувати стиль до групи елементів, крім певних винятків, щоб уникнути дублювання правил."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "136. Як складність CSS-селекторів впливає на продуктивність?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Складні селектори (глибокі вкладення, універсальний "
              },
              {
                "text": "*",
                "code": true
              },
              {
                "text": ", комбінації кількох умов) збільшують час, який браузер витрачає на обхід DOM для пошуку відповідних елементів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Хоч сучасні браузери оптимізовані, надмірно складні селектори можуть уповільнити рендеринг у великих проєктах, а також ускладнюють підтримку коду."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Найкраща практика — використовувати короткі й конкретні селектори."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "137. Які стратегії ви б використали для оптимізації шляху рендерингу CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Мінімізація блокуючого CSS",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Розміщувати критичні стилі ("
              },
              {
                "text": "critical CSS",
                "code": true
              },
              {
                "text": ") прямо в "
              },
              {
                "text": "<head>",
                "code": true
              },
              {
                "text": " — лише ті, що потрібні для початкового рендеру."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Виносити другорядні стилі в окремі файли та підключати їх асинхронно ("
              },
              {
                "text": "media=\"print\"",
                "code": true
              },
              {
                "text": " → потім "
              },
              {
                "text": "media=\"all\"",
                "code": true
              },
              {
                "text": " через JS)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Оптимізація та зменшення обсягу CSS",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Видалення невикористаних стилів ("
              },
              {
                "text": "PurifyCSS",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "UnCSS",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "purgecss",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Мініфікація ("
              },
              {
                "text": "cssnano",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "CleanCSS",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Уникати дублювання селекторів і зайвих правил."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Обмеження кількості та складності селекторів",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати класи замість універсальних або глибоких комбінацій селекторів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Не перевантажувати DOM пошуком через дуже складні селектори."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використання кешування",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Задавати довгі "
              },
              {
                "text": "cache headers",
                "code": true
              },
              {
                "text": " для CSS-файлів з рідкими змінами."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати версіонування ("
              },
              {
                "text": "hash",
                "code": true
              },
              {
                "text": " у назві файлу) для оновлень."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Порядок підключення стилів",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS-файли, що впливають на "
              },
              {
                "text": "Above-the-Fold",
                "code": true
              },
              {
                "text": " контент — якомога вище у "
              },
              {
                "text": "<head>",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Модульні стилі — підключати лише там, де вони реально потрібні."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Зменшення залежностей від зовнішніх ресурсів",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Якщо є зовнішні шрифти або бібліотеки CSS — підключати лише потрібні частини (наприклад, "
              },
              {
                "text": "font-subset",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати "
              },
              {
                "text": "preload",
                "code": true
              },
              {
                "text": " для ключових стилів ("
              },
              {
                "text": "<link rel=\"preload\" as=\"style\" href=\"...\">",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "138. Як мінімізувати перемальовування та перекомпонування CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб мінімізувати перемальовування ("
              },
              {
                "text": "repaint",
                "code": true
              },
              {
                "text": ") та перекомпонування ("
              },
              {
                "text": "reflow",
                "code": true
              },
              {
                "text": ", також називають "
              },
              {
                "text": "layout",
                "code": true
              },
              {
                "text": "), треба розуміти, що вони — найвитратніші операції в рендерингу браузера."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Reflow",
                "code": true
              },
              {
                "text": " відбувається, коли змінюється структура DOM або стилі, що впливають на розташування елементів, і браузер змушений перераховувати позиції та розміри."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Repaint",
                "code": true
              },
              {
                "text": " трапляється, коли змінюється зовнішній вигляд елемента (колір, фон тощо), але не його розташування."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Основні стратегії зменшення reflow/repaint"
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Мінімізуйте зміни в DOM",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Уникайте частого додавання/видалення елементів у циклах."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте DocumentFragment або приховування елемента ("
              },
              {
                "text": "display: none",
                "code": true
              },
              {
                "text": ") перед масовими змінами, а потім показуйте назад."
              },
              {
                "type": "code",
                "language": "javascript",
                "content": "element.style.display = 'none'; // масові зміни\nDOM element.style.display = 'block';"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Уникайте читання і запису стилів впереміш",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Читання властивостей, що викликають "
              },
              {
                "text": "reflow",
                "code": true
              },
              {
                "text": " (наприклад "
              },
              {
                "text": "offsetHeight",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "scrollTop",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "getComputedStyle",
                "code": true
              },
              {
                "text": "), після зміни стилів примушує браузер синхронно перерахувати "
              },
              {
                "text": "layout",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "❌ "
          },
          {
            "text": "Погано:",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "javascript",
        "content": "element.style.width = '200px';\nconsole.log(element.offsetHeight); // змусить layout виконатися двічі"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "✅ "
          },
          {
            "text": "Добре:",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "javascript",
        "content": "const height = element.offsetHeight;\nelement.style.width = '200px';"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовуйте CSS-трансформації замість зміни геометрії",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зміни "
              },
              {
                "text": "top",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "left",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "width",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "height",
                "code": true
              },
              {
                "text": " спричиняють "
              },
              {
                "text": "reflow",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання "
              },
              {
                "text": "transform: translate()",
                "code": true
              },
              {
                "text": " чи "
              },
              {
                "text": "scale()",
                "code": true
              },
              {
                "text": " виконується на GPU і не викликає перерахунку розташування."
              },
              {
                "type": "code",
                "language": "css",
                "content": "/* краще */\ntransform: translateX(50px);\n\n/* гірше */\nleft: 50px;"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Виносьте анімації на композитний шар",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте "
              },
              {
                "text": "will-change: transform;",
                "code": true
              },
              {
                "text": " або "
              },
              {
                "text": "transform",
                "code": true
              },
              {
                "text": " та "
              },
              {
                "text": "opacity",
                "code": true
              },
              {
                "text": " для плавних анімацій."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Не анімуйте властивості, які впливають на розміри/flow (наприклад "
              },
              {
                "text": "margin",
                "code": true
              },
              {
                "text": ", "
              },
              {
                "text": "width",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Групуйте зміни стилів",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зміни кількох властивостей через "
              },
              {
                "text": "classList.add()",
                "code": true
              },
              {
                "text": " або через "
              },
              {
                "text": "style.cssText",
                "code": true
              },
              {
                "text": " зменшують кількість "
              },
              {
                "text": "reflow",
                "code": true
              },
              {
                "text": "."
              },
              {
                "type": "code",
                "language": "javascript",
                "content": "element.classList.add('active', 'highlight');"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Оптимізуйте складні селектори",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Глибокі та складні селектори збільшують час обчислення стилів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Віддавайте перевагу простим класам замість каскаду в 5–6 рівнів."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовуйте requestAnimationFrame для оновлень у JS",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб уникнути \"рваних\" анімацій, синхронізуйте зміни стилів з кадрами анімації браузера."
              },
              {
                "type": "code",
                "language": "javascript",
                "content": "function animate() {\n  element.style.transform = `translateX(${x}px)`;\n  requestAnimationFrame(animate);\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Обмежуйте використання таблиць",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "HTML-таблиці перераховуються складніше, бо зміни в одній клітинці можуть вплинути на всю таблицю."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Кешуйте розрахунки",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Якщо потрібно кілька разів читати властивість, що викликає "
              },
              {
                "text": "reflow",
                "code": true
              },
              {
                "text": " — збережіть її в змінній."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "139. Які найкращі практики написання ефективного CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Структуруйте код і використовуйте конвенції",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Дотримуйтеся єдиного стилю написання (BEM, SMACSS, ITCSS)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте змістовні імена класів замість описових по вигляду (.btn-primary замість .blue-btn)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Логічно групуйте стилі (базові, компоненти, утиліти)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Мінімізуйте специфічність",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Уникайте довгих селекторів (header nav ul li a) — вони ускладнюють перевизначення."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевага — класи над ID:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "/* Добре */\n.card-title {\n  ...;\n}\n\n/* Погано */\n#main-content h2.title {\n  ...;\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Не зловживайте "
              },
              {
                "text": "!important",
                "code": true
              },
              {
                "text": " — він ускладнює підтримку."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовуйте каскад розумно",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Пишіть стилі так, щоб вони перевизначалися природно, без зайвих хитрощів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте успадкування для шрифтів, кольорів і загальних властивостей."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Оптимізуйте для продуктивності",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте простi селектори: браузер читає їх справа наліво, тож div ul li a гірший, ніж .nav-link."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Видаляйте непотрібні стилі — вони лише уповільнюють рендеринг."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Об’єднуйте спільні властивості у короткі записи (margin: 10px 0; замість чотирьох окремих)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Уникайте дублювання",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Виносьте повторювані значення у змінні (у SCSS або CSS Custom Properties):"
              },
              {
                "type": "code",
                "language": "css",
                "content": ":root {\n  --main-color: #3498db;\n}\n\n.btn {\n  background: var(--main-color);\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Думайте про масштабованість",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Проєктуйте стилі так, щоб додавання нового компонента не ламало існуючі."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте компонентний підхід у фреймворках (React, Vue, Angular)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Мінімізуйте вплив на перерисовку",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Уникайте частих змін layout-властивостей (width, height, margin)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для анімацій використовуйте transform та opacity — вони не викликають reflow."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Готуйте до продакшну",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Мініфікуйте CSS (через cssnano, clean-css)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте critical CSS для швидкого відображення above-the-fold контенту."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Вмикайте автопрефікси для кросбраузерності."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Тестуйте",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевіряйте сторінку в різних браузерах та на різних пристроях."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте Lighthouse/DevTools для аналізу unused CSS."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "140. Як оптимізувати CSS для критичного шляху рендерингу та швидкого завантаження?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Виділення критичного CSS",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Витягніть стилі, які потрібні для першого екрану (\"above the fold\"), і вставте їх інлайн у "
              },
              {
                "text": "<head>",
                "code": true
              },
              {
                "text": ":"
              },
              {
                "type": "code",
                "language": "html",
                "content": "<style>\n  body {\n    font-family: sans-serif;\n  }\n  header {\n    background: #333;\n    color: #fff;\n    padding: 1rem;\n  }\n</style>"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Решту стилів підвантажуйте окремим файлом асинхронно."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використання media та preload",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для неосновних стилів вказуйте медіа-умови:"
              },
              {
                "type": "code",
                "language": "html",
                "content": "<link rel=\"stylesheet\" href=\"print.css\" media=\"print\" />"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Або використовуйте preload:"
              },
              {
                "type": "code",
                "language": "html",
                "content": "<link\n  rel=\"preload\"\n  href=\"styles.css\"\n  as=\"style\"\n  onload=\"this.rel='stylesheet'\"\n/>"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Мінімізація та об’єднання",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Мінімізуйте CSS (remove spaces, comments, unused rules)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Об’єднуйте файли, щоб зменшити кількість HTTP-запитів (але не до абсурду, якщо є код для різних частин сайту)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Уникання блокуючих CSS",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Розбийте стилі на критичні (inline) і другорядні (завантаження після DOMContentLoaded)."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Наприклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<link\n  rel=\"stylesheet\"\n  href=\"main.css\"\n  media=\"print\"\n  onload=\"this.media='all'\"\n/>"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Прибирання зайвих стилів",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовуйте PurgeCSS, UnCSS або аналогічні інструменти для видалення невикористаних селекторів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Це особливо важливо при роботі з великими фреймворками (Bootstrap, Tailwind)."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Оптимізація селекторів",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Уникайте надто складних і глибоких селекторів (div ul li a span)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Віддавайте перевагу класам — вони швидші для обробки."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використання HTTP/2",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Якщо сервер підтримує HTTP/2, можна не об’єднувати файли, а завантажувати їх паралельно — це зменшує час до першого рендеру."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "141. Що таке об'єктно-орієнтований CSS (OOCSS)?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "OOCSS (Object-Oriented CSS) — це методологія написання CSS, що базується на розділенні стилів на структуру (layout) і шкіру (theme), та повторному використанні класів як «об’єктів» для зменшення дублювання і підвищення гнучкості коду."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "142. Поясніть принціпи іменування BEM, зокрема як працюють блоки, елементи та модифікатори.",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "BEM",
                "code": true
              },
              {
                "text": " — це методологія іменування CSS-класів для покращення читабельності і масштабованості коду."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Структура:",
            "bold": true
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "block — незалежний компонент (наприклад, menu)"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "block"
              },
              {
                "text": "element — частина блоку (menu",
                "bold": true
              },
              {
                "text": "item)"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "block--modifier — варіант блоку (menu--dark) або елемента (menu\\_\\_item--active)"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Це допомагає уникати конфліктів і чітко структурує стилі."
          }
        ]
      }
    ]
  },
  {
    "question": "143. Які переваги використання CSS-фреймворку, такого як Bootstrap або TailwindCSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Прискорюють розробку завдяки готовим стилям і компонентам."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Забезпечують консистентність дизайну між командами."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Мають адаптивність «з коробки» (responsive)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Підтримують кросбраузерність."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "TailwindCSS дає гнучкість через утиліти, Bootstrap — готові UI-компоненти."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Зменшують обсяг кастомного CSS і допомагають уникати помилок."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "144. Як забезпечити масштабованість та зручність підтримки CSS у великому проекті?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати методології: BEM, OOCSS, SMACSS для структуризації."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Розбивати CSS на модулі або компоненти."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використовувати препроцесори (Sass, Less) і змінні."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Мінімізувати специфічність селекторів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Документувати стилі і слідувати код-стайлу."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Писати повторно використовувані утиліти й міксіни."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Впроваджувати автоматичний лінтинг і тестування стилів."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "145. Які підходи до архітектури CSS для великомасштабних застосунків ви знаєте?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "BEM — чітке розділення блоків, елементів і модифікаторів для передбачуваності."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "OOCSS — розділення структури і стилів, повторне використання об’єктів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "SMACSS — категоризація стилів на базові, макетні, модульні, станів і теми."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "ITCSS — ієрархія шарів від глобальних до компонентних стилів для кращої організації."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Atomic CSS / Utility-first — маленькі повторно використовувані класи для швидкого стилювання."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Кожен підхід можна комбінувати залежно від потреб проекту."
          }
        ]
      }
    ]
  },
  {
    "question": "146. Як зробити гамбургер-меню лише на CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Створити гамбургер-меню на CSS можна так:"
              }
            ]
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використати чекбокс ("
              },
              {
                "text": "<input type=\"checkbox\">",
                "code": true
              },
              {
                "text": ") для контролю відкриття меню."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Стилізувати три смужки як гамбургер через псевдоелементи."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "При відміченому чекбоксі через CSS ("
              },
              {
                "text": ":checked",
                "code": true
              },
              {
                "text": ") показувати/ховати меню."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Простий приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<input type=\"checkbox\" id=\"menu-toggle\" />\n<label for=\"menu-toggle\" class=\"hamburger\">\n  <span></span><span></span><span></span>\n</label>\n<nav class=\"menu\">\n  <a href=\"#\">Home</a>\n  <a href=\"#\">About</a>\n</nav>"
      },
      {
        "type": "code",
        "language": "css",
        "content": ".hamburger span {\n  display: block;\n  width: 30px;\n  height: 3px;\n  margin: 5px 0;\n  background: black;\n  transition: 0.3s;\n}\n\n.menu {\n  display: none;\n}\n\n#menu-toggle:checked + .hamburger + .menu {\n  display: block;\n}"
      }
    ]
  },
  {
    "question": "147. Як зробити слайдер або карусель лише на CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Карусель на чистому CSS роблять через:"
              }
            ]
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання "
              },
              {
                "text": "input type=\"radio\"",
                "code": true
              },
              {
                "text": " або чекбоксів для керування слайдами."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Приховані елементи-контролери ("
              },
              {
                "text": "radio buttons",
                "code": true
              },
              {
                "text": "), стилізовані як навігація."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Позиціонування слайдів абсолютом в контейнері."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Показ слайду через CSS-селектор "
              },
              {
                "text": ":checked",
                "code": true
              },
              {
                "text": " (наприклад, #slide1:checked ~ .slides .slide1 { opacity: 1; })."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Анімації або переходи для плавності."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Простий приклад:"
          }
        ]
      },
      {
        "type": "code",
        "language": "html",
        "content": "<input type=\"radio\" name=\"slider\" id=\"slide1\" checked />\n<input type=\"radio\" name=\"slider\" id=\"slide2\" />\n<div class=\"slides\">\n  <div class=\"slide slide1\">Slide 1</div>\n  <div class=\"slide slide2\">Slide 2</div>\n</div>\n<label for=\"slide1\">1</label>\n<label for=\"slide2\">2</label>"
      },
      {
        "type": "code",
        "language": "css",
        "content": ".slides .slide {\n  opacity: 0;\n  position: absolute;\n  transition: opacity 0.5s ease;\n}\n\n#slide1:checked ~ .slides .slide1,\n#slide2:checked ~ .slides .slide2 {\n  opacity: 1;\n  position: relative;\n}"
      }
    ]
  },
  {
    "question": "148. Як реалізувати макет у стилі мура (masonry layout) за допомогою CSS?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб створити макет у стилі мура (masonry layout) на CSS, можна використовувати кілька підходів:"
              }
            ]
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS Grid із властивістю grid-auto-rows та grid-row-end"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Потрібно вручну або через JS задавати висоту рядків, щоб елементи «заповнювали» вертикальний простір без фіксованої висоти."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання CSS Columns (найпростіший спосіб)"
              },
              {
                "type": "code",
                "language": "css",
                "content": ".container {\n  column-count: 3;\n  column-gap: 1rem;\n}\n\n.item {\n  break-inside: avoid;\n  margin-bottom: 1rem;\n}"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Переваги: автоматичне «обтікання» елементів у колонки, але порядок читання зліва направо, зверху вниз."
          }
        ]
      },
      {
        "type": "numberedList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Новий спосіб — grid-template-rows: masonry (поки експериментальний, підтримка обмежена)."
              },
              {
                "type": "bulletList",
                "children": [
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Підсумок:"
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Для простих проектів — CSS Columns."
                      }
                    ]
                  },
                  {
                    "type": "listItem",
                    "children": [
                      {
                        "text": "Для складніших — поєднання Grid і JS для обчислення висот."
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "149. Як застосувати CSS до вебзастосунку, який має друкуватися, а також відображатися на екрані?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для окремого стилювання під друк і екран використовують медіа-запити:"
              },
              {
                "type": "code",
                "language": "css",
                "content": "/* Стилі для екрану */\n@media screen {\n  /* тут стилі для екрана */\n}\n\n/* Стилі для друку */\n@media print {\n  /* тут стилі для друку */\n}"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Також можна підключати окремі CSS-файли:"
              },
              {
                "type": "code",
                "language": "html",
                "content": "<link rel=\"stylesheet\" href=\"screen.css\" media=\"screen\" />\n<link rel=\"stylesheet\" href=\"print.css\" media=\"print\" />"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Це дозволяє оптимізувати вигляд для кожного режиму — приховувати меню, змінювати кольори, поліпшувати читабельність при друку."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "question": "150. Як реалізувати безперебійний каскадний потік елементів у адаптивному дизайні?",
    "category": "css",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Щоб створити безперебійний каскадний потік (flow) елементів в адаптивному дизайні, використовують:"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS Flexbox з властивістю flex-wrap: wrap; — елементи переходять на новий рядок при браку місця."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "CSS Grid з автоматичним заповненням колонок (grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Media queries для корекції кількості елементів у рядку залежно від ширини екрана."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Використання відсоткових/гнучких ширин замість фіксованих пікселів."
              }
            ]
          }
        ]
      }
    ]
  }
]
