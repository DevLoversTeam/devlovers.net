[
  {
    "category": "git",
    "order": 1,
    "translations": {
      "uk": {
        "question": "1. Що таке Git і яка його роль у розробці програмного забезпечення?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git", "bold": true },
              {
                "text": " - розподілена система контролю версій (VCS) для відстеження змін у коді."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використання:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Зберігання історії змін у проєкті." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Паралельна розробка в гілках (branches)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Об’єднання змін через merge або rebase." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відновлення попередніх версій файлів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Спільна робота команд над кодом через сервіси (GitHub, GitLab, Bitbucket)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git дозволяє безпечно керувати кодом, відстежувати зміни та ефективно співпрацювати."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "1. What is Git and what role does it play in software development?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git", "bold": true },
              {
                "text": " is a distributed version control system (VCS) used to track changes in source code."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usage:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Storing the history of changes in a project." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Parallel development using branches." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Merging changes via merge or rebase." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Restoring previous versions of files." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Team collaboration through services like GitHub, GitLab, and Bitbucket."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git enables safe code management, change tracking, and efficient collaboration."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "1. Czym jest Git i jaką rolę odgrywa w tworzeniu oprogramowania?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git", "bold": true },
              {
                "text": " to rozproszony system kontroli wersji (VCS) służący do śledzenia zmian w kodzie."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zastosowanie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Przechowywanie historii zmian w projekcie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Równoległa praca w gałęziach (branches)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Łączenie zmian za pomocą merge lub rebase." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przywracanie wcześniejszych wersji plików." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Praca zespołowa nad kodem przez serwisy (GitHub, GitLab, Bitbucket)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git umożliwia bezpieczne zarządzanie kodem, śledzenie zmian i efektywną współpracę."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 2,
    "translations": {
      "uk": {
        "question": "2. Чим Git відрізняється від інших систем контролю версій, наприклад, SVN або Mercurial?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Розподіленість:", "bold": true },
                  {
                    "text": " у Git кожен клон репозиторію містить повну історію, на відміну від централізованих VCS (SVN)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Швидкість:", "bold": true },
                  {
                    "text": " локальні операції (commit, diff, log) виконуються дуже швидко."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Гнучке керування гілками:", "bold": true },
                  {
                    "text": " lightweight branches і швидке злиття (merge/rebase)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зберігання змін:", "bold": true },
                  {
                    "text": " Git зберігає снімки (snapshots) файлів, а не лише дельти, як у SVN."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Широка інтеграція:", "bold": true },
                  {
                    "text": " популярність Git забезпечує підтримку в CI/CD, GitHub, GitLab та IDE."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Безпека:", "bold": true },
                  {
                    "text": " SHA-1 хешування гарантує цілісність історії."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git ідеально підходить для сучасних командних workflow та open-source проєктів завдяки швидкості, гнучкості та надійності."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "2. How does Git differ from other version control systems like SVN or Mercurial?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Distributed nature:", "bold": true },
                  {
                    "text": " each Git clone contains the full repository history, unlike centralized VCSs such as SVN."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Speed:", "bold": true },
                  {
                    "text": " local operations (commit, diff, log) are very fast."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Flexible branching:", "bold": true },
                  {
                    "text": " lightweight branches and fast merging (merge/rebase)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Data storage:", "bold": true },
                  {
                    "text": " Git stores snapshots of files instead of deltas like SVN."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wide integration:", "bold": true },
                  {
                    "text": " Git is widely supported by CI/CD tools, GitHub, GitLab, and IDEs."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Security:", "bold": true },
                  {
                    "text": " SHA-1 hashing ensures the integrity of the history."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git is ideal for modern team workflows and open-source projects due to its speed, flexibility, and reliability."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "2. Czym Git różni się od innych systemów kontroli wersji, takich jak SVN lub Mercurial?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Rozproszona architektura:", "bold": true },
                  {
                    "text": " każdy klon repozytorium Git zawiera pełną historię, w przeciwieństwie do scentralizowanych VCS (SVN)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Szybkość:", "bold": true },
                  {
                    "text": " operacje lokalne (commit, diff, log) są bardzo szybkie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Elastyczne zarządzanie gałęziami:",
                    "bold": true
                  },
                  {
                    "text": " lekkie gałęzie (branches) i szybkie scalanie (merge/rebase)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przechowywanie danych:", "bold": true },
                  {
                    "text": " Git przechowuje migawki (snapshots) plików, a nie tylko różnice jak SVN."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Szeroka integracja:", "bold": true },
                  {
                    "text": " popularność Git zapewnia wsparcie w CI/CD, GitHub, GitLab oraz IDE."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Bezpieczeństwo:", "bold": true },
                  {
                    "text": " haszowanie SHA-1 gwarantuje integralność historii."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git doskonale sprawdza się w nowoczesnych workflow zespołowych i projektach open-source dzięki szybkości, elastyczności i niezawodności."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 3,
    "translations": {
      "uk": {
        "question": "3. У чому відмінність між Git і GitHub?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git", "bold": true },
                  {
                    "text": " - система контролю версій (VCS) для відстеження змін у коді локально або на будь-якому сервері."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub", "bold": true },
                  {
                    "text": " - онлайн-сервіс для хостингу Git-репозиторіїв із веб-інтерфейсом, командною роботою та додатковими можливостями: pull requests, issues, CI/CD інтеграції."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коротко:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git — інструмент для роботи з версіями коду, GitHub — платформа для хостингу та командної співпраці."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git можна використовувати без GitHub, але GitHub без Git використати неможливо."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "3. What is the difference between Git and GitHub?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git", "bold": true },
                  {
                    "text": " is a version control system (VCS) used to track changes in code locally or on any server."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub", "bold": true },
                  {
                    "text": " is an online platform for hosting Git repositories with a web interface, team collaboration, and additional features such as pull requests, issues, and CI/CD integrations."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In short:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git is a tool for version control, while GitHub is a platform for hosting and collaborating on Git repositories."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You can use Git without GitHub, but you cannot use GitHub without Git."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "3. Jaka jest różnica między Git a GitHub?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git", "bold": true },
                  {
                    "text": " to system kontroli wersji (VCS) służący do śledzenia zmian w kodzie lokalnie lub na dowolnym serwerze."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub", "bold": true },
                  {
                    "text": " to internetowa platforma do hostowania repozytoriów Git z interfejsem webowym, pracą zespołową oraz dodatkowymi funkcjami: pull requests, issues, integracje CI/CD."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W skrócie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git to narzędzie do kontroli wersji, a GitHub to platforma do hostingu i współpracy zespołowej."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git można używać bez GitHub, ale GitHub nie działa bez Git."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 4,
    "translations": {
      "uk": {
        "question": "4. Що таке репозиторій у Git і яка його роль?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Репозиторій (repository, repo)", "bold": true },
              {
                "text": " — це місце зберігання всього коду проєкту та повної історії змін."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Файли проєкту (код, документацію, конфігурації)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Історію комітів із повідомленнями та авторами."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Гілки (branches) для паралельної розробки." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Репозиторій може бути локальним (на вашому комп’ютері) або віддаленим (GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Він дозволяє відстежувати зміни, працювати командою та повертатися до попередніх версій коду."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "4. What is a repository in Git and what is its role?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A repository (repo)", "bold": true },
              {
                "text": " is a storage location that contains the entire project code and its full change history."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Contains:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Project files (source code, documentation, configuration)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit history with messages and authors." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Branches for parallel development." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A repository can be local (on your computer) or remote (GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It allows you to track changes, collaborate with a team, and restore previous versions of the code."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "4. Czym jest repozytorium w Git i jaka jest jego rola?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Repozytorium (repository, repo)", "bold": true },
              {
                "text": " to miejsce przechowywania całego kodu projektu oraz pełnej historii zmian."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Pliki projektu (kod źródłowy, dokumentację, konfigurację)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Historię commitów z autorami i opisami." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Gałęzie (branches) do równoległej pracy." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Repozytorium może być lokalne (na komputerze) lub zdalne (GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Umożliwia śledzenie zmian, pracę zespołową oraz powrót do wcześniejszych wersji kodu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 5,
    "translations": {
      "uk": {
        "question": "5. Що таке коміт (commit) у Git і для чого він використовується?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Коміт (commit)", "bold": true },
              {
                "text": " — це збереження знімка змін у репозиторії разом із повідомленням."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Історію змін файлів (added, modified, deleted)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Авторство та дату зміни." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Унікальний SHA-1 хеш для ідентифікації." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Відстеження прогресу проєкту." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Повернення до попередніх станів (git checkout, git revert)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Координації роботи в команді через pull/merge."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад коміту:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add index.html\n\ngit commit -m \"feat(html): Додаю базову структуру сторінки\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Коміти формують історію проєкту, яку можна аналізувати, відновлювати і об’єднувати."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "5. What is a commit in Git and what is it used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A commit", "bold": true },
              {
                "text": " is a snapshot of changes saved in the repository along with a message."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Contains:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A history of file changes (added, modified, deleted)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Author information and timestamp." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "A unique SHA-1 hash for identification." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Used for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Tracking project progress." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Returning to previous states (git checkout, git revert)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Coordinating team work via pull/merge." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Commit example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add index.html\n\ngit commit -m \"feat(html): Add basic page structure\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Commits form the project history, which can be analyzed, restored, and merged."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "5. Czym jest commit w Git i do czego służy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Commit", "bold": true },
              {
                "text": " to zapis migawki zmian w repozytorium wraz z komunikatem."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Historię zmian plików (added, modified, deleted)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Informacje o autorze i dacie." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Unikalny hash SHA-1 do identyfikacji." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Służy do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Śledzenia postępu projektu." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Powrotu do wcześniejszych stanów (git checkout, git revert)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Koordynacji pracy zespołu poprzez pull/merge."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład commita:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add index.html\n\ngit commit -m \"feat(html): Dodanie podstawowej struktury strony\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Commity tworzą historię projektu, którą można analizować, przywracać i scalać."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 6,
    "translations": {
      "uk": {
        "question": "6. Яка різниця між робочим каталогом (working directory), стейджингом (staging area/index) і репозиторієм (repository) у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Робочий каталог (Working Directory)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Файли на диску, які ви безпосередньо редагуєте."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Містить останню версію з Git + незакомічені зміни."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Проміжна область (Staging Area / Index)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Тимчасова зона для підготовки змін до коміту."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Дозволяє обрати, які саме зміни потраплять у наступний коміт."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Команда: git add " },
                          { "text": "<file>", "code": true },
                          { "text": " додає зміни до стейджу." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Локальний репозиторій (Repository)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Збережена історія комітів у папці .git."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Містить коміти, гілки, теги та SHA-1 хеші."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Команда: git commit переносить зміни зі стейджу в репозиторій."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Схематично:" }]
          },
          {
            "type": "code",
            "language": "text",
            "content": "Working Directory -> git add -> Staging Area -> git commit -> Repository"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ця модель дозволяє гнучко контролювати, які зміни зберігати, та підтримувати чисту історію комітів."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "6. What is the difference between the working directory, the staging area (index), and the repository in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Working Directory", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Files on disk that you actively edit."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Contains the latest version from Git plus uncommitted changes."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Staging Area (Index)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "A temporary area to prepare changes for a commit."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Allows you to select which changes will be included in the next commit."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Command: git add " },
                          { "text": "<file>", "code": true },
                          { "text": " adds changes to the staging area." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Repository", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Stored commit history inside the .git directory."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Contains commits, branches, tags, and SHA-1 hashes."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Command: git commit moves changes from staging to the repository."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Diagram:" }]
          },
          {
            "type": "code",
            "language": "text",
            "content": "Working Directory -> git add -> Staging Area -> git commit -> Repository"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This model provides fine-grained control over what gets committed and helps maintain a clean commit history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "6. Jaka jest różnica między katalogiem roboczym (working directory), obszarem staging (index) a repozytorium w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Katalog roboczy (Working Directory)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Pliki na dysku, które aktualnie edytujesz."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zawiera ostatnią wersję z Git oraz niezacommitowane zmiany."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Obszar staging (Index)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Tymczasowe miejsce do przygotowania zmian do commita."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Pozwala wybrać, które zmiany trafią do następnego commita."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Polecenie: git add " },
                          { "text": "<file>", "code": true },
                          { "text": " dodaje zmiany do stagingu." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Repozytorium (Repository)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zapisana historia commitów w katalogu .git."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zawiera commity, gałęzie, tagi oraz hashe SHA-1."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Polecenie: git commit przenosi zmiany ze stagingu do repozytorium."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Schemat:" }]
          },
          {
            "type": "code",
            "language": "text",
            "content": "Working Directory -> git add -> Staging Area -> git commit -> Repository"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ten model pozwala precyzyjnie kontrolować zapisywane zmiany i utrzymywać czystą historię commitów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 7,
    "translations": {
      "uk": {
        "question": "7. Що таке розгалуження (branching) у Git і чому воно важливе?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Розгалуження (branch)", "bold": true },
              {
                "text": " — це окрема лінія розробки в репозиторії, яка дозволяє працювати над новими функціями, виправленнями або експериментами, не впливаючи на основну гілку (main/master)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Важливість:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Паралельна робота кількох розробників." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Безпечне тестування нових функцій." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Проста інтеграція змін через merge або rebase."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Чистіша історія комітів і кращий контроль змін."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад створення та перемикання гілки:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch feature-login\n\ngit checkout feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Розгалуження є основою сучасних workflow (Git Flow, GitHub Flow) для командної розробки."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "7. What is branching in Git and why is it important?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Branching", "bold": true },
              {
                "text": " is a separate line of development in a repository that allows you to work on new features, fixes, or experiments without affecting the main branch (main/master)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Why it matters:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Parallel work by multiple developers." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Safe testing of new features." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Easy integration of changes via merge or rebase."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Cleaner commit history and better change control."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Example of creating and switching a branch:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch feature-login\n\ngit checkout feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Branching is the foundation of modern workflows such as Git Flow and GitHub Flow for team development."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "7. Czym jest branching (rozgałęzianie) w Git i dlaczego jest ważne?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Branching (gałąź)", "bold": true },
              {
                "text": " to oddzielna linia rozwoju w repozytorium, która pozwala pracować nad nowymi funkcjami, poprawkami lub eksperymentami bez wpływu na główną gałąź (main/master)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dlaczego jest ważne:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Równoległa praca wielu programistów." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Bezpieczne testowanie nowych funkcji." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Łatwa integracja zmian przez merge lub rebase."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Czystsza historia commitów i lepsza kontrola zmian."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Przykład tworzenia i przełączania gałęzi:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch feature-login\n\ngit checkout feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rozgałęzianie jest podstawą nowoczesnych workflow, takich jak Git Flow i GitHub Flow, w pracy zespołowej."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 8,
    "translations": {
      "uk": {
        "question": "8. Що таке HEAD у Git і яка його роль?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "HEAD", "bold": true },
              {
                "text": " — це поточний вказівник на коміт, з яким ви зараз працюєте."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Зазвичай HEAD вказує на гілку, а гілка — на останній коміт."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Визначення поточного місця в історії комітів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перемикання між гілками (git checkout " },
                  { "text": "<branch>", "code": true },
                  { "text": ") або комітами (git checkout " },
                  { "text": "<commit>", "code": true },
                  { "text": ")." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Можливі стани HEAD:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Normal", "bold": true },
                  { "text": " — HEAD вказує на гілку." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Detached HEAD", "bold": true },
                  {
                    "text": " — HEAD тимчасово вказує на конкретний коміт, а не на гілку."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature-login\n\n# HEAD тепер вказує на гілку feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "HEAD — ключовий концепт для навігації історією Git та управління комітами."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "8. What is HEAD in Git and what is its role?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "HEAD", "bold": true },
              {
                "text": " is a pointer to the commit you are currently working on."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Usually, HEAD points to a branch, and the branch points to the latest commit."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Used for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Identifying your current position in the commit history."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Switching branches (git checkout " },
                  { "text": "<branch>", "code": true },
                  { "text": ") or commits (git checkout " },
                  { "text": "<commit>", "code": true },
                  { "text": ")." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Possible HEAD states:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Normal", "bold": true },
                  { "text": " — HEAD points to a branch." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Detached HEAD", "bold": true },
                  {
                    "text": " — HEAD temporarily points to a specific commit, not a branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature-login\n\n# HEAD now points to the feature-login branch"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "HEAD is a key concept for navigating Git history and managing commits."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "8. Czym jest HEAD w Git i jaka jest jego rola?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "HEAD", "bold": true },
              {
                "text": " to wskaźnik na commit, nad którym aktualnie pracujesz."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zazwyczaj HEAD wskazuje na gałąź, a gałąź na ostatni commit."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Służy do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Określania bieżącej pozycji w historii commitów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przełączania gałęzi (git checkout " },
                  { "text": "<branch>", "code": true },
                  { "text": ") lub commitów (git checkout " },
                  { "text": "<commit>", "code": true },
                  { "text": ")." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Możliwe stany HEAD:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Normal", "bold": true },
                  { "text": " — HEAD wskazuje na gałąź." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Detached HEAD", "bold": true },
                  {
                    "text": " — HEAD tymczasowo wskazuje na konkretny commit, a nie na gałąź."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature-login\n\n# HEAD wskazuje teraz na gałąź feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "HEAD to kluczowe pojęcie do nawigacji po historii Git i zarządzania commitami."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 9,
    "translations": {
      "uk": {
        "question": "9. Що таке операція clone у Git і для чого вона використовується?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clone", "code": true },
              {
                "text": " — створює повну копію віддаленого репозиторію на вашому локальному комп’ютері."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Копія містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Усі файли проєкту." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Повну історію комітів." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Усі гілки та теги." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Початку роботи над існуючим проєктом." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Спільної роботи команди через GitHub, GitLab або інші сервери."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone https://github.com/user/repo.git"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Результат:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Локальний репозиторій, готовий до комітів, створення гілок і синхронізації з віддаленим сервером."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "9. What is the clone operation in Git and what is it used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clone", "code": true },
              {
                "text": " creates a full copy of a remote repository on your local machine."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "The copy includes:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "All project files." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "The complete commit history." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "All branches and tags." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Used for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Starting work on an existing project." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Team collaboration via GitHub, GitLab, or other servers."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone https://github.com/user/repo.git"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Result:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A local repository ready for commits, branching, and synchronization with the remote server."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "9. Czym jest operacja clone w Git i do czego służy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clone", "code": true },
              {
                "text": " tworzy pełną kopię zdalnego repozytorium na lokalnym komputerze."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kopia zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Wszystkie pliki projektu." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Pełną historię commitów." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Wszystkie gałęzie i tagi." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Służy do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Rozpoczęcia pracy nad istniejącym projektem." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Współpracy zespołowej przez GitHub, GitLab lub inne serwery."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone https://github.com/user/repo.git"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Rezultat:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Lokalne repozytorium gotowe do commitów, tworzenia gałęzi i synchronizacji ze zdalnym serwerem."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 10,
    "translations": {
      "uk": {
        "question": "10. Як Git зберігає дані про проєкт і його історію змін?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git зберігає дані у вигляді знімків (snapshots), а не просто дельт файлів."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Кожен коміт містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Посилання на попередній коміт." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Знімок дерева файлів проєкту." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Інформацію про автора та повідомлення коміту."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні типи об’єктів Git:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Blob", "code": true },
                  { "text": " — вміст файлів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tree", "code": true },
                  { "text": " — структура каталогів і файлів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit", "code": true },
                  { "text": " — вказує на tree та попередній коміт." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Папка " },
              { "text": ".git", "code": true },
              {
                "text": " містить усі об’єкти та метадані, що дозволяє повністю відтворити історію проєкту."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Така модель робить Git швидким, надійним і ефективним для роботи з гілками та злиттями."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "10. How does Git store project data and its change history?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git stores data as snapshots rather than simple file deltas."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Each commit contains:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "A reference to the previous commit." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "A snapshot of the project file tree." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Author information and commit message." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core Git object types:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Blob", "code": true },
                  { "text": " — file contents." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tree", "code": true },
                  { "text": " — directory and file structure." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit", "code": true },
                  { "text": " — points to a tree and the previous commit." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": ".git", "code": true },
              {
                "text": " directory contains all objects and metadata needed to fully reconstruct the project history."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This model makes Git fast, reliable, and efficient for branching and merging."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "10. W jaki sposób Git przechowuje dane projektu i historię zmian?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git przechowuje dane w postaci migawek (snapshots), a nie tylko różnic plików."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Każdy commit zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Odniesienie do poprzedniego commita." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Migawkę drzewa plików projektu." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Informacje o autorze i komunikat commita." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Podstawowe typy obiektów Git:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Blob", "code": true },
                  { "text": " — zawartość plików." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tree", "code": true },
                  { "text": " — struktura katalogów i plików." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit", "code": true },
                  { "text": " — wskazuje na tree i poprzedni commit." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Katalog " },
              { "text": ".git", "code": true },
              {
                "text": " zawiera wszystkie obiekty i metadane, umożliwiając pełne odtworzenie historii projektu."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Taki model sprawia, że Git jest szybki, niezawodny i wydajny przy pracy z gałęziami i scalaniem."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 11,
    "translations": {
      "uk": {
        "question": "11. Як ініціалізувати новий репозиторій Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використати команду:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git init"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ця команда створює приховану папку .git у поточному каталозі, де зберігається історія комітів, гілки та конфігурація репозиторію."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Далі потрібно додати файли та створити перший коміт:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add .\n\ngit commit -m \"Initial commit\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Після виконання git init каталог стає повноцінним Git-репозиторієм."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "11. How do you initialize a new Git repository?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Use the command:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git init"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This command creates a hidden .git directory in the current folder, which stores the commit history, branches, and repository configuration."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Next, add files and create the first commit:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add .\n\ngit commit -m \"Initial commit\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "After running git init, the directory becomes a fully functional Git repository."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "11. Jak zainicjalizować nowe repozytorium Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Użyj polecenia:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git init"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie to tworzy ukryty katalog .git w bieżącym folderze, w którym przechowywana jest historia commitów, gałęzie oraz konfiguracja repozytorium."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Następnie należy dodać pliki i utworzyć pierwszy commit:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add .\n\ngit commit -m \"Initial commit\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Po wykonaniu git init katalog staje się pełnoprawnym repozytorium Git."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 12,
    "translations": {
      "uk": {
        "question": "12. Для чого використовується команда git status?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Показує поточний стан робочого каталогу та індексу (staging area)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Інформує про:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Які файли змінені, але ще не додані." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Які файли вже в індексі та підуть у наступний коміт."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Які файли не відслідковуються." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Поточну гілку та її відставання або випередження відносно віддаленого репозиторію."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git status"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Команда допомагає зрозуміти, що саме буде закомічено, а які зміни ще потребують виконання git add."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "12. What is the git status command used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Displays the current state of the working directory and the staging area (index)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "It informs you about:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Files that have been modified but not yet staged."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Files that are staged and will be included in the next commit."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Files that are untracked." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The current branch and whether it is ahead of or behind the remote branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git status"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It helps you understand what will be committed and which changes still need to be added using git add."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "12. Do czego służy polecenie git status?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wyświetla aktualny stan katalogu roboczego oraz obszaru staging (index)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Informuje o:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Plikach zmodyfikowanych, ale jeszcze nie dodanych do stagingu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Plikach znajdujących się w stagingu, które trafią do następnego commita."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Plikach nieśledzonych (untracked)." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Aktualnej gałęzi oraz jej wyprzedzeniu lub opóźnieniu względem repozytorium zdalnego."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git status"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie pozwala zrozumieć, co zostanie zapisane w commicie, a które zmiany wymagają jeszcze użycia git add."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 13,
    "translations": {
      "uk": {
        "question": "13. Яке призначення команди git add?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git add", "code": true },
                  {
                    "text": " додає зміни з робочого каталогу у staging area (індекс)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Це підготовчий етап перед комітом." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Можна додавати окремі файли або всі зміни." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add file.txt     # додає конкретний файл\ngit add .            # додає всі зміни в поточному каталозі\ngit add -p           # додає зміни частинами (interactive)"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Команда " },
              { "text": "git add", "code": true },
              {
                "text": " не зберігає зміни в історії — вона лише позначає їх для наступного "
              },
              { "text": "git commit", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "en": {
        "question": "13. What is the purpose of the git add command?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git add", "code": true },
                  {
                    "text": " adds changes from the working directory to the staging area (index)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "It is a preparation step before committing." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You can add individual files or all changes at once."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add file.txt     # adds a specific file\ngit add .            # adds all changes in the current directory\ngit add -p           # adds changes interactively"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": "git add", "code": true },
              {
                "text": " command does not save changes to history — it only marks them for the next "
              },
              { "text": "git commit", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "pl": {
        "question": "13. Jakie jest przeznaczenie polecenia git add?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git add", "code": true },
                  {
                    "text": " dodaje zmiany z katalogu roboczego do obszaru staging (index)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jest to etap przygotowawczy przed wykonaniem commita."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Można dodawać pojedyncze pliki lub wszystkie zmiany naraz."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add file.txt     # dodaje konkretny plik\ngit add .            # dodaje wszystkie zmiany w bieżącym katalogu\ngit add -p           # dodaje zmiany interaktywnie"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Polecenie " },
              { "text": "git add", "code": true },
              {
                "text": " nie zapisuje zmian w historii — jedynie oznacza je do następnego "
              },
              { "text": "git commit", "code": true },
              { "text": "." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 14,
    "translations": {
      "uk": {
        "question": "14. Яким чином створюється новий коміт у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Спочатку додати зміни у staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add ."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Потім створити коміт:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -m \"Опис змін\""
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Ключ ", "children": [] },
                  { "text": "-m", "code": true },
                  { "text": " додає повідомлення коміту." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо параметр не вказати, відкриється текстовий редактор для введення повідомлення."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Коміт зберігає знімок (snapshot) поточного стану індексу в історії репозиторію."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Рекомендується писати короткі та зрозумілі повідомлення комітів, щоб легко відстежувати зміни."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "14. How is a new commit created in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "First, add changes to the staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add ."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Then create the commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -m \"Describe changes\""
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "The ", "children": [] },
                  { "text": "-m", "code": true },
                  { "text": " flag adds a commit message." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If it is not provided, a text editor will open to enter the message."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A commit saves a snapshot of the current staging area state into the repository history."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It is recommended to write short and clear commit messages to easily track changes."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "14. W jaki sposób tworzy się nowy commit w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Najpierw dodaj zmiany do obszaru staging:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add ."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Następnie utwórz commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -m \"Opis zmian\""
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Opcja ", "children": [] },
                  { "text": "-m", "code": true },
                  { "text": " dodaje komunikat commita." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli nie zostanie podana, otworzy się edytor tekstu do wpisania komunikatu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Commit zapisuje migawkę (snapshot) aktualnego stanu stagingu w historii repozytorium."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zaleca się pisanie krótkich i zrozumiałych komunikatów commitów, aby łatwo śledzić zmiany."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 15,
    "translations": {
      "uk": {
        "question": "15. Які дані зберігає об’єкт коміту в Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Об’єкт коміту містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Хеш (SHA-1/SHA-256) — унікальний ідентифікатор."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Посилання на tree-об’єкт (структура файлів і папок на момент коміту)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Посилання на parent-коміти (зв’язок в історії; у merge їх може бути кілька)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Автор (ім’я, email, час створення)." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Комітер (той, хто зафіксував зміни; може відрізнятися від автора)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Commit message (опис змін)." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Таким чином Git зберігає не окремі файли, а знімки стану разом із метаданими, що дозволяє легко відновлювати та порівнювати історію."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "15. What data does a commit object store in Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "A commit object contains:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A hash (SHA-1/SHA-256) — a unique identifier."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A reference to a tree object (the file and directory structure at the time of the commit)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "References to parent commits (history linkage; there can be multiple parents in a merge)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Author information (name, email, creation time)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Committer information (the person who recorded the commit; may differ from the author)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit message (description of changes)." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "As a result, Git stores snapshots of the project state along with metadata, which makes it easy to restore and compare history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "15. Jakie dane przechowuje obiekt commita w Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Obiekt commita zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Hash (SHA-1/SHA-256) — unikalny identyfikator."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Odwołanie do obiektu tree (struktura plików i katalogów w momencie commita)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Odwołania do commitów nadrzędnych (powiązania w historii; przy merge może być ich kilka)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Autor (imię, email, czas utworzenia)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Committer (osoba zapisująca commit; może różnić się od autora)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Commit message (opis zmian)." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Dzięki temu Git przechowuje migawki stanu projektu wraz z metadanymi, co ułatwia odtwarzanie i porównywanie historii."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 16,
    "translations": {
      "uk": {
        "question": "16. Яка різниця між командами git push і git fetch?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git push", "code": true },
                  {
                    "text": " — відправляє локальні коміти у віддалений репозиторій (оновлює remote-гілку)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "text": " — отримує нові дані з віддаленого репозиторію, але не зливає їх у локальну гілку (оновлює лише refs/remotes)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Тобто:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "push", "code": true },
                  { "text": " — викласти свої зміни." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "fetch", "code": true },
                  {
                    "text": " — завантажити чужі зміни для перегляду або подальшого злиття."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "16. What is the difference between git push and git fetch?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git push", "code": true },
                  {
                    "text": " sends local commits to the remote repository (updates the remote branch)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "text": " retrieves new data from the remote repository but does not merge it into the local branch (updates refs/remotes only)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In short:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "push", "code": true },
                  { "text": " = publish your changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "fetch", "code": true },
                  {
                    "text": " = download others’ changes for review or later merging."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "16. Jaka jest różnica między poleceniami git push i git fetch?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git push", "code": true },
                  {
                    "text": " wysyła lokalne commity do zdalnego repozytorium (aktualizuje gałąź zdalną)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "text": " pobiera nowe dane ze zdalnego repozytorium, ale nie scala ich z lokalną gałęzią (aktualizuje tylko refs/remotes)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Czyli:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "push", "code": true },
                  { "text": " = publikacja własnych zmian." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "fetch", "code": true },
                  {
                    "text": " = pobranie cudzych zmian do wglądu lub późniejszego scalenia."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 17,
    "translations": {
      "uk": {
        "question": "17. Яке призначення команди git pull?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  { "text": " = " },
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " (або " },
                  { "text": "rebase", "code": true },
                  { "text": ", якщо вказано відповідну опцію)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Команда завантажує останні зміни з віддаленого репозиторію та одразу інтегрує їх у поточну гілку."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Використовується для синхронізації локальної гілки з віддаленою (remote)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git pull origin main"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Команда отримає оновлення з origin/main і зіллє їх у вашу локальну гілку main."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Якщо потрібен лише перегляд змін без злиття, краще використовувати git fetch."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "17. What is the purpose of the git pull command?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  { "text": " = " },
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " (or " },
                  { "text": "rebase", "code": true },
                  { "text": " if the option is specified)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "It downloads the latest changes from the remote repository and immediately integrates them into the current branch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Used to synchronize the local branch with the remote one."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git pull origin main"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This command fetches updates from origin/main and merges them into your local main branch."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "If you only want to review changes without merging, it is better to use git fetch."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "17. Jakie jest przeznaczenie polecenia git pull?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  { "text": " = " },
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " (lub " },
                  { "text": "rebase", "code": true },
                  { "text": ", jeśli użyto odpowiedniej opcji)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Polecenie pobiera najnowsze zmiany ze zdalnego repozytorium i od razu scala je z bieżącą gałęzią."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Służy do synchronizacji lokalnej gałęzi ze zdalną (remote)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git pull origin main"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie pobierze aktualizacje z origin/main i scali je z lokalną gałęzią main."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jeśli chcesz jedynie przejrzeć zmiany bez scalania, lepiej użyć git fetch."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 18,
    "translations": {
      "uk": {
        "question": "18. Яке призначення та варіанти використання команди git branch?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " керує гілками в репозиторії. Основні сценарії:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд усіх гілок:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Створення нової гілки:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch feature/login"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Видалення гілки (локально):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -d feature/login   # безпечне (якщо змерджено)\ngit branch -D feature/login   # примусове"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перейменування гілки:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -m old-name new-name"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд віддалених гілок:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -r"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Важливо:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " не перемикає гілки, а лише створює та керує ними. Для перемикання використовується "
              },
              { "text": "git checkout", "code": true },
              { "text": " або " },
              { "text": "git switch", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "en": {
        "question": "18. What is the purpose and usage of the git branch command?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " is used to manage branches in a repository. Common use cases:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "List all branches:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Create a new branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch feature/login"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Delete a branch (locally):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -d feature/login   # safe (if merged)\ngit branch -D feature/login   # force delete"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Rename a branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -m old-name new-name"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "View remote branches:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -r"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Important:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " does not switch branches — it only creates and manages them. To switch branches, use "
              },
              { "text": "git checkout", "code": true },
              { "text": " or " },
              { "text": "git switch", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "pl": {
        "question": "18. Jakie jest przeznaczenie i sposoby użycia polecenia git branch?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " służy do zarządzania gałęziami w repozytorium. Główne scenariusze:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wyświetlenie wszystkich gałęzi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Utworzenie nowej gałęzi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch feature/login"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Usunięcie gałęzi (lokalnie):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -d feature/login   # bezpieczne (jeśli scalona)\ngit branch -D feature/login   # wymuszone"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zmiana nazwy gałęzi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -m old-name new-name"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wyświetlenie gałęzi zdalnych:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -r"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ważne:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " nie przełącza gałęzi — jedynie je tworzy i nimi zarządza. Do przełączania używa się "
              },
              { "text": "git checkout", "code": true },
              { "text": " lub " },
              { "text": "git switch", "code": true },
              { "text": "." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 19,
    "translations": {
      "uk": {
        "question": "19. Як використовувати git checkout для перемикання між гілками?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Команда " },
              { "text": "git checkout <branch>", "code": true },
              {
                "text": " змінює поточну гілку на вказану, оновлюючи робочий каталог до стану цієї гілки."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "HEAD тепер вказує на feature/login, і всі файли відображають її стан."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Створення нової гілки та одночасне перемикання:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b feature/signup"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Це дозволяє швидко почати роботу в новій гілці без втрати змін (якщо вони закомічені або в staging area)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У сучасних workflow рекомендують використовувати "
              },
              { "text": "git switch", "code": true },
              { "text": " для перемикання гілок (" },
              { "text": "git switch feature/login", "code": true },
              { "text": "), оскільки це більш інтуїтивно." }
            ]
          }
        ]
      },
      "en": {
        "question": "19. How do you use git checkout to switch between branches?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": "git checkout <branch>", "code": true },
              {
                "text": " command switches the current branch to the specified one, updating the working directory to match that branch."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "HEAD now points to feature/login, and all files reflect the state of that branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Create a new branch and switch to it:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b feature/signup"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "This allows you to quickly start working on a new branch without losing changes (if they are committed or staged)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "In modern workflows, it is recommended to use " },
              { "text": "git switch", "code": true },
              { "text": " for switching branches (" },
              { "text": "git switch feature/login", "code": true },
              { "text": "), as it is more intuitive." }
            ]
          }
        ]
      },
      "pl": {
        "question": "19. Jak używać git checkout do przełączania się między gałęziami?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Polecenie " },
              { "text": "git checkout <branch>", "code": true },
              {
                "text": " przełącza bieżącą gałąź na wskazaną, aktualizując katalog roboczy do jej stanu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "HEAD wskazuje teraz na feature/login, a wszystkie pliki odzwierciedlają stan tej gałęzi."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Utworzenie nowej gałęzi i jednoczesne przełączenie:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b feature/signup"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Umożliwia to szybkie rozpoczęcie pracy w nowej gałęzi bez utraty zmian (jeśli są zapisane lub w stagingu)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "W nowoczesnych workflow zaleca się używanie " },
              { "text": "git switch", "code": true },
              { "text": " do przełączania gałęzi (" },
              { "text": "git switch feature/login", "code": true },
              { "text": "), ponieważ jest to bardziej intuicyjne." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 20,
    "translations": {
      "uk": {
        "question": "20. Для чого використовується команда git merge?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge <branch>", "code": true },
                  { "text": " об’єднує зміни з іншої гілки у поточну." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Застосовується для інтеграції роботи над фічами або виправленнями в основну гілку (main/develop)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Типи злиття:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fast-forward", "code": true },
                  {
                    "text": " — просто переміщує вказівник гілки, якщо історія лінійна."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Three-way merge", "code": true },
                  {
                    "text": " — створює новий коміт злиття, якщо гілки розійшлися."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після цього всі зміни з feature/login будуть інтегровані в main."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge дозволяє безпечно інтегрувати паралельні гілки без втрати історії змін."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "20. What is the git merge command used for?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge <branch>", "code": true },
                  {
                    "text": " merges changes from another branch into the current one."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "It is used to integrate feature or bugfix work into the main branch (main/develop)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Merge types:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fast-forward", "code": true },
                  {
                    "text": " — simply moves the branch pointer forward if the history is linear."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Three-way merge", "code": true },
                  {
                    "text": " — creates a new merge commit when branches have diverged."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After this, all changes from feature/login will be integrated into main."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge allows safe integration of parallel branches without losing history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "20. Do czego służy polecenie git merge?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge <branch>", "code": true },
                  { "text": " scala zmiany z innej gałęzi z bieżącą." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Służy do integracji pracy nad funkcjami lub poprawkami z główną gałęzią (main/develop)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Typy scalania:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fast-forward", "code": true },
                  {
                    "text": " — przesuwa wskaźnik gałęzi, jeśli historia jest liniowa."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Three-way merge", "code": true },
                  {
                    "text": " — tworzy nowy commit scalający, gdy gałęzie się rozeszły."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po tym wszystkie zmiany z feature/login zostaną scalone z main."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge umożliwia bezpieczną integrację równoległych gałęzi bez utraty historii."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 21,
    "translations": {
      "uk": {
        "question": "21. Який Git workflow ви зазвичай використовуєте в роботі?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Найчастіше використовую Git Flow / Feature Branch Workflow:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  { "text": " — завжди стабільна продакшн-версія." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " — інтеграційна гілка для нових фіч." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Для кожної задачі створюється окрема " },
                  { "text": "feature", "code": true },
                  { "text": "-гілка." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Після завершення — " },
                  { "text": "pull request", "code": true },
                  { "text": " → " },
                  { "text": "code review", "code": true },
                  { "text": " → " },
                  { "text": "merge у develop", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перед релізом створюється " },
                  { "text": "release", "code": true },
                  { "text": "-гілка, після тестування — " },
                  { "text": "merge у main", "code": true },
                  { "text": " та створення тега." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Термінові виправлення виконуються у " },
                  { "text": "hotfix", "code": true },
                  { "text": "-гілках від main." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Такий workflow забезпечує дисципліну, прозорість процесу та повний контроль над релізами."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "21. Which Git workflow do you usually use in your work?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "I usually use Git Flow / Feature Branch Workflow:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  {
                    "text": " — always contains the stable production version."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " — an integration branch for new features." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Each task is developed in a separate " },
                  { "text": "feature", "code": true },
                  { "text": " branch." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "After completion — " },
                  { "text": "pull request", "code": true },
                  { "text": " → " },
                  { "text": "code review", "code": true },
                  { "text": " → " },
                  { "text": "merge into develop", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Before a release, a " },
                  { "text": "release", "code": true },
                  { "text": " branch is created; after testing — " },
                  { "text": "merge into main", "code": true },
                  { "text": " and tagging." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Critical fixes are handled in " },
                  { "text": "hotfix", "code": true },
                  { "text": " branches from main." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This workflow provides structure, transparency, and strong control over releases."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "21. Jaki workflow Git najczęściej stosujesz w pracy?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Najczęściej korzystam z Git Flow / Feature Branch Workflow:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  {
                    "text": " — zawsze zawiera stabilną wersję produkcyjną."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " — gałąź integracyjna dla nowych funkcji." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Każde zadanie realizowane jest w osobnej gałęzi "
                  },
                  { "text": "feature", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Po zakończeniu — " },
                  { "text": "pull request", "code": true },
                  { "text": " → " },
                  { "text": "code review", "code": true },
                  { "text": " → " },
                  { "text": "merge do develop", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przed wydaniem tworzona jest gałąź " },
                  { "text": "release", "code": true },
                  { "text": ", po testach — " },
                  { "text": "merge do main", "code": true },
                  { "text": " oraz tag." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Pilne poprawki realizowane są w gałęziach " },
                  { "text": "hotfix", "code": true },
                  { "text": " od main." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Taki workflow zapewnia dyscyplinę, przejrzystość procesu oraz pełną kontrolę nad wydaniami."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 22,
    "translations": {
      "uk": {
        "question": "22. Опишіть кроки створення нової гілки та її злиття в main.",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Переконуюсь, що локальна гілка main оновлена:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main\n\ngit pull origin main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Створюю нову гілку від main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -b feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Працюю над задачею та комічу зміни:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\n\ngit commit -m \"Implement feature X\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Пушу гілку на віддалений репозиторій:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Відкриваю Pull Request → проходить code review → перевіряється CI."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Мерджу гілку в main (зазвичай через squash або rebase для чистої історії)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Видаляю feature-гілку локально та на remote."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "22. Describe the steps to create a new branch and merge it into main.",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Make sure the local main branch is up to date:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main\n\ngit pull origin main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Create a new branch from main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -b feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Work on the task and commit changes:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\n\ngit commit -m \"Implement feature X\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Push the branch to the remote repository:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Open a Pull Request → go through code review → run CI checks."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Merge the branch into main (usually using squash or rebase to keep history clean)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Delete the feature branch locally and on the remote."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "22. Opisz kroki tworzenia nowej gałęzi i jej scalenia z main.",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Upewniam się, że lokalna gałąź main jest aktualna:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main\n\ngit pull origin main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tworzę nową gałąź na podstawie main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -b feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Pracuję nad zadaniem i wykonuję commity:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\n\ngit commit -m \"Implement feature X\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wysyłam gałąź do repozytorium zdalnego:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Otwieram Pull Request → przeprowadzany jest code review → uruchamiane są testy CI."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Scalam gałąź z main (zwykle przez squash lub rebase, aby zachować czystą historię)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Usuwam gałąź feature lokalnie oraz na remote."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 23,
    "translations": {
      "uk": {
        "question": "23. Що таке merge conflict у Git і як його вирішують?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Merge conflict виникає, коли дві гілки змінюють один і той самий рядок коду або файл у несумісний спосіб, і Git не може автоматично об’єднати ці зміни."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Рішення:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Виконати merge або rebase — Git повідомить про конфліктні файли."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відкрити конфліктний файл і знайти маркери " },
                  { "text": "<<<<<<<", "code": true },
                  { "text": ", " },
                  { "text": "=======", "code": true },
                  { "text": ", " },
                  { "text": ">>>>>>>", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вручну вибрати або об’єднати потрібні зміни." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити файл як вирішений:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Завершити merge або rebase комітом:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "23. What is a merge conflict in Git and how is it resolved?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A merge conflict occurs when two branches modify the same line of code or file in incompatible ways, and Git cannot automatically merge the changes."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Resolution steps:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Run merge or rebase — Git will report the conflicting files."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Open the conflicted file and locate the markers "
                  },
                  { "text": "<<<<<<<", "code": true },
                  { "text": ", " },
                  { "text": "=======", "code": true },
                  { "text": ", " },
                  { "text": ">>>>>>>", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Manually choose or combine the correct changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark the file as resolved:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Finish the merge or rebase with a commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "23. Czym jest konflikt scalania (merge conflict) w Git i jak się go rozwiązuje?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Merge conflict występuje, gdy dwie gałęzie modyfikują ten sam fragment kodu lub plik w niekompatybilny sposób, a Git nie jest w stanie automatycznie scalić zmian."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Rozwiązanie:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wykonać merge lub rebase — Git wskaże pliki z konfliktami."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Otworzyć plik i znaleźć znaczniki " },
                  { "text": "<<<<<<<", "code": true },
                  { "text": ", " },
                  { "text": "=======", "code": true },
                  { "text": ", " },
                  { "text": ">>>>>>>", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ręcznie wybrać lub połączyć właściwe zmiany." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć plik jako rozwiązany:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zakończyć scalanie lub rebase commitem:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 24,
    "translations": {
      "uk": {
        "question": "24. Що таке fast-forward merge у Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Fast-forward merge — це злиття, коли гілка-ціль (наприклад main) не має нових комітів після відгалуження feature-гілки. У такому випадку Git просто пересуває вказівник main на останній коміт feature-гілки без створення merge-коміту."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/my-task --ff"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Це «чисте» злиття без створення додаткових комітів в історії."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "24. What is a fast-forward merge in Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A fast-forward merge occurs when the target branch (for example, main) has no new commits since the feature branch was created. In this case, Git simply moves the main pointer forward to the latest commit of the feature branch without creating a merge commit."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/my-task --ff"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This results in a clean history without additional merge commits."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "24. Czym jest fast-forward merge w Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Fast-forward merge to scalanie, w którym gałąź docelowa (np. main) nie ma nowych commitów od momentu utworzenia gałęzi feature. Git przesuwa wtedy wskaźnik main do ostatniego commita gałęzi feature bez tworzenia commita scalającego."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/my-task --ff"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jest to „czyste” scalanie bez dodatkowych commitów w historii."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 25,
    "translations": {
      "uk": {
        "question": "25. Що таке three-way merge у Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Three-way merge — це тип злиття, під час якого Git використовує три точки для об’єднання змін:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "common ancestor", "code": true },
                  {
                    "text": " — спільний базовий коміт, від якого розійшлися гілки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "HEAD", "code": true },
                  {
                    "text": " — останній коміт у цільовій гілці (наприклад, main)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "branch tip", "code": true },
                  {
                    "text": " — останній коміт у гілці, яка зливається (наприклад, feature)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git порівнює зміни відносно спільного предка та створює новий merge-коміт, який має двох батьківських коміти."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Такий тип злиття використовується, коли fast-forward merge неможливий, тобто в обох гілках з’явилися нові коміти."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "25. What is a three-way merge in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A three-way merge is a merge strategy where Git uses three reference points to combine changes:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "common ancestor", "code": true },
                  {
                    "text": " — the base commit from which the branches diverged."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "HEAD", "code": true },
                  {
                    "text": " — the latest commit in the target branch (for example, main)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "branch tip", "code": true },
                  {
                    "text": " — the latest commit in the branch being merged (for example, feature)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git compares changes relative to the common ancestor and creates a new merge commit that has two parent commits."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This approach is used when a fast-forward merge is not possible, meaning both branches contain new commits."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "25. Czym jest three-way merge w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Three-way merge to strategia scalania, w której Git wykorzystuje trzy punkty odniesienia do połączenia zmian:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "common ancestor", "code": true },
                  {
                    "text": " — wspólny commit bazowy, od którego rozeszły się gałęzie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "HEAD", "code": true },
                  {
                    "text": " — ostatni commit w gałęzi docelowej (np. main)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "branch tip", "code": true },
                  {
                    "text": " — ostatni commit w scalanej gałęzi (np. feature)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git porównuje zmiany względem wspólnego przodka i tworzy nowy commit scalający z dwoma commitami nadrzędnymi."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ten typ scalania jest stosowany, gdy fast-forward merge nie jest możliwy, czyli gdy obie gałęzie zawierają nowe commity."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 26,
    "translations": {
      "uk": {
        "question": "26. Які кроки виконати, щоб перебазувати (rebase) гілку в Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перейти у свою гілку:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Виконати rebase на актуальну main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin\n\ngit rebase origin/main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо виникають конфлікти — вирішити їх і додати файли:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>\n\ngit rebase --continue"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після завершення оновити remote (з форсом, оскільки історія була переписана):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task --force"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rebase робить історію комітів лінійною, на відміну від merge."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "26. What steps are required to rebase a branch in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Switch to your feature branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Rebase it onto the latest main branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin\n\ngit rebase origin/main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If conflicts occur, resolve them and stage the files:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>\n\ngit rebase --continue"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After completion, update the remote branch (force push is required because history was rewritten):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task --force"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rebase creates a linear commit history, unlike merge."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "26. Jakie kroki należy wykonać, aby wykonać rebase gałęzi w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Przełączyć się na swoją gałąź:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wykonać rebase na aktualną gałąź main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin\n\ngit rebase origin/main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli pojawią się konflikty — rozwiązać je i dodać pliki:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>\n\ngit rebase --continue"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po zakończeniu zaktualizować gałąź zdalną (wymagany force push, ponieważ historia została zmieniona):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task --force"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rebase tworzy liniową historię commitów, w przeciwieństwie do merge."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 27,
    "translations": {
      "uk": {
        "question": "27. Які плюси й мінуси rebase у порівнянні з merge?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Лінійна, чиста історія без merge-комітів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зручніше читати git log, легше дебажити." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Кожен коміт виглядає так, ніби зроблений поверх останнього main."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Переписує історію (особливо небезпечно для спільних гілок)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Потребує force push, що може створити проблеми іншим розробникам."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вимагає більшої дисципліни в команді." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Зберігає повну історію розробки без переписування."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Безпечний для командної роботи." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Простий і зрозумілий у використанні." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Менш чистий git log з великою кількістю merge-комітів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Історію складніше аналізувати та відстежувати."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Загалом:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge безпечніший для командної роботи, тоді як rebase краще підходить для підтримки чистої історії."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "27. What are the pros and cons of rebase compared to merge?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages of rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Clean, linear history without merge commits." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Easier to read git log and debug changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Each commit appears as if it was created on top of the latest main branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Disadvantages of rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Rewrites history (dangerous for shared branches)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Requires force push, which may disrupt others."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Requires more discipline within the team." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages of merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Preserves the complete development history." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Safe for collaborative team workflows." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Simple and straightforward to use." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Disadvantages of merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Messier git log with many merge commits." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "History can be harder to analyze." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Overall:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge is safer for teams, while rebase is better for maintaining a clean history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "27. Jakie są zalety i wady rebase w porównaniu do merge?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Czysta, liniowa historia bez commitów scalających."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Łatwiejsze czytanie git log i debugowanie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Każdy commit wygląda, jakby został wykonany na aktualnej gałęzi main."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Przepisuje historię (niebezpieczne dla współdzielonych gałęzi)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wymaga force push, co może powodować problemy innym."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wymaga większej dyscypliny zespołowej." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Zachowuje pełną historię rozwoju projektu." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Bezpieczne dla pracy zespołowej." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Proste i intuicyjne w użyciu." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Mniej czytelna historia z wieloma commitami scalającymi."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Trudniejsza analiza historii zmian." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Podsumowanie:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge jest bezpieczniejszy dla zespołów, natomiast rebase lepiej sprawdza się przy utrzymaniu czystej historii."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 28,
    "translations": {
      "uk": {
        "question": "28. Для чого використовуються теги в Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Теги в Git — це фіксовані маркери, що вказують на конкретні коміти, зазвичай для позначення релізів (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight tag", "code": true },
                  {
                    "text": " — проста вказівка на коміт без додаткових метаданих."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated tag", "code": true },
                  {
                    "text": " — містить автора, дату, повідомлення та може бути підписаний GPG."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Теги зручні для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Відстеження версій у продакшені." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Швидкого переходу до конкретного релізу:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Також теги часто використовуються в CI/CD для автоматичного деплою."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "28. What are Git tags used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git tags are fixed references to specific commits, commonly used to mark releases (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight tag", "code": true },
                  {
                    "text": " — a simple pointer to a commit without additional metadata."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated tag", "code": true },
                  {
                    "text": " — stores author, date, message and can be GPG-signed."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tags are useful for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Tracking production versions." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Quickly checking out a specific release:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tags are also widely used in CI/CD pipelines for automated deployments."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "28. Do czego służą tagi w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tagi w Git to stałe wskaźniki na konkretne commity, najczęściej używane do oznaczania wydań (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight tag", "code": true },
                  {
                    "text": " — proste wskazanie na commit bez dodatkowych informacji."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated tag", "code": true },
                  {
                    "text": " — zawiera autora, datę, opis i może być podpisany GPG."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tagi są przydatne do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Śledzenia wersji na produkcji." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Szybkiego przejścia do konkretnego wydania:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tagi są również często wykorzystywane w CI/CD do automatycznych wdrożeń."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 29,
    "translations": {
      "uk": {
        "question": "29. Як скасувати коміт, який вже запушено на remote?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо потрібно повністю видалити коміт (історія переписується, небезпечно для інших):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git reset --hard <commit_before>\n\ngit push origin <branch> --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо потрібно зберегти історію, створивши «відкат» без переписування:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git revert <commit_hash>\n\ngit push origin <branch>"
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reset --hard", "code": true },
                  { "text": " + " },
                  { "text": "force push", "code": true },
                  {
                    "text": " — змінює історію комітів (небезпечно для спільних гілок)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "revert", "code": true },
                  {
                    "text": " — створює новий коміт, який відміняє зміни, без переписування історії (безпечніше для команди)."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "29. How can you undo a commit that has already been pushed to a remote repository?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If you need to completely remove the commit (history is rewritten, dangerous for others):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git reset --hard <commit_before>\n\ngit push origin <branch> --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If you want to keep the history and safely undo the changes:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git revert <commit_hash>\n\ngit push origin <branch>"
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reset --hard", "code": true },
                  { "text": " + " },
                  { "text": "force push", "code": true },
                  {
                    "text": " rewrites commit history (unsafe for shared branches)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "revert", "code": true },
                  {
                    "text": " creates a new commit that undoes the changes without rewriting history (safer for teams)."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "29. Jak cofnąć commit, który został już wypchnięty (push) do repozytorium zdalnego?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli trzeba całkowicie usunąć commit (historia zostaje przepisana, niebezpieczne dla innych):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git reset --hard <commit_before>\n\ngit push origin <branch> --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli chcesz zachować historię i bezpiecznie cofnąć zmiany:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git revert <commit_hash>\n\ngit push origin <branch>"
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reset --hard", "code": true },
                  { "text": " + " },
                  { "text": "force push", "code": true },
                  {
                    "text": " przepisuje historię commitów (niebezpieczne dla wspólnych gałęzi)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "revert", "code": true },
                  {
                    "text": " tworzy nowy commit cofający zmiany bez przepisywania historii (bezpieczniejsze dla zespołów)."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 30,
    "translations": {
      "uk": {
        "question": "30. Яке призначення головної гілки (main/master) у Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Головна гілка (main або раніше master) — це стабільна, завжди робоча версія проєкту, на яку орієнтуються всі інші гілки."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Від неї створюють feature-, release- та hotfix-гілки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вона слугує базою для формування релізів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Зазвичай саме з неї запускається CI/CD та деплой у продакшн."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "30. What is the purpose of the main (master) branch in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The main branch (formerly master) represents the stable, production-ready version of the project that all other branches are based on."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Feature, release, and hotfix branches are created from it."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "It serves as the foundation for releases." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "CI/CD pipelines and production deployments usually run from this branch."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "30. Jakie jest przeznaczenie głównej gałęzi (main/master) w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Główna gałąź (main lub dawniej master) to stabilna, zawsze działająca wersja projektu, na której opierają się pozostałe gałęzie."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Na jej podstawie tworzy się gałęzie feature, release i hotfix."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Służy jako baza do przygotowywania wydań." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zazwyczaj z tej gałęzi uruchamiane są procesy CI/CD oraz wdrożenia na produkcję."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 31,
    "translations": {
      "uk": {
        "question": "31. Що таке розподілена система контролю версій і як Git реалізує цей підхід?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Розподілена система контролю версій (DVCS) — це система, у якій кожен розробник має повну копію репозиторію разом з усією історією комітів, а не лише робочі файли."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git реалізує підхід DVCS таким чином:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Під час клонування репозиторію розробник отримує всю історію змін локально."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Коміти, гілки та теги створюються локально й не потребують постійного підключення до сервера."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Синхронізація між розробниками відбувається через push і pull у віддалений репозиторій (наприклад, GitHub)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Такий підхід забезпечує високу швидкість, автономність і можливість працювати офлайн."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "31. What is a distributed version control system and how does Git implement this approach?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A distributed version control system (DVCS) is a system in which every developer has a full copy of the repository, including the complete commit history, not just the working files."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Git implements the DVCS approach as follows:" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "When cloning a repository, the entire history is downloaded locally."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Commits, branches, and tags are created locally and do not require a constant server connection."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Synchronization between developers happens via push and pull operations to a remote repository (for example, GitHub)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "This provides high performance, autonomy, and the ability to work offline."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "31. Czym jest rozproszony system kontroli wersji i jak Git realizuje to podejście?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rozproszony system kontroli wersji (DVCS) to system, w którym każdy programista posiada pełną kopię repozytorium wraz z całą historią commitów, a nie tylko pliki robocze."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Git realizuje podejście DVCS w następujący sposób:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Podczas klonowania repozytorium pobierana jest cała historia zmian lokalnie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Commity, gałęzie i tagi są tworzone lokalnie i nie wymagają stałego połączenia z serwerem."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Synchronizacja między programistami odbywa się poprzez operacje push i pull do zdalnego repozytorium (np. GitHub)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Takie podejście zapewnia szybkość, autonomię oraz możliwość pracy offline."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 32,
    "translations": {
      "uk": {
        "question": "32. Що таке Git Feature Branch Workflow і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Feature Branch Workflow", "bold": true },
              {
                "text": " — це підхід до розробки, за якого для кожної нової задачі або фічі створюється окрема гілка."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Від main або develop відгалужується гілка " },
                  { "text": "feature/", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Розробка та всі коміти виконуються лише в цій гілці."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після завершення роботи відкривається Pull Request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після code review та проходження CI зміни зливаються назад у develop або main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Feature-гілка видаляється." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ізоляція змін, можливість паралельної роботи без конфліктів та чиста, контрольована історія."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "32. What is the Git Feature Branch Workflow and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Feature Branch Workflow", "bold": true },
              {
                "text": " is a development approach where a separate branch is created for each new task or feature."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "A " },
                  { "text": "feature/", "code": true },
                  { "text": " branch is created from main or develop." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "All development and commits happen only in this branch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Once the feature is complete, a Pull Request is opened."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After code review and successful CI checks, changes are merged back into develop or main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "The feature branch is deleted." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Isolation of changes, parallel development without conflicts, and a clean, controlled history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "32. Czym jest Git Feature Branch Workflow i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Feature Branch Workflow", "bold": true },
              {
                "text": " to podejście, w którym dla każdego nowego zadania lub funkcji tworzona jest osobna gałąź."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Od gałęzi main lub develop tworzona jest gałąź "
                  },
                  { "text": "feature/", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Cała praca i commity odbywają się wyłącznie w tej gałęzi."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po zakończeniu pracy otwierany jest Pull Request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po code review i przejściu CI zmiany są scalane z powrotem do develop lub main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Gałąź feature jest usuwana." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Izolacja zmian, równoległa praca bez konfliktów oraz czysta i kontrolowana historia."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 33,
    "translations": {
      "uk": {
        "question": "33. Що таке Gitflow Workflow і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Gitflow", "bold": true },
              {
                "text": " — це модель роботи з Git із чіткими правилами для різних типів гілок."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  { "text": " — завжди стабільна продакшн-версія." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " — інтеграційна гілка для активної розробки." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "feature/", "code": true },
                  {
                    "text": " — створюються від develop і після завершення зливаються назад у develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "release/", "code": true },
                  {
                    "text": " — відгалужуються від develop для підготовки релізу, після тестування зливаються в main і develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "hotfix/", "code": true },
                  {
                    "text": " — створюються від main для термінових виправлень і потім зливаються як у main, так і в develop."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Плюси:", "bold": true },
              {
                "text": " чітка структура, контрольована розробка та керовані релізи."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Мінуси:", "bold": true },
              {
                "text": " громіздкий процес для маленьких команд або підходів з continuous delivery."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "33. What is the Gitflow Workflow and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Gitflow", "bold": true },
              {
                "text": " is a Git workflow model with clearly defined rules for different branch types."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  {
                    "text": " — always represents the stable production version."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  {
                    "text": " — the integration branch for active development."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "feature/", "code": true },
                  {
                    "text": " — created from develop and merged back into develop after completion."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "release/", "code": true },
                  {
                    "text": " — branched from develop to prepare a release, then merged into both main and develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "hotfix/", "code": true },
                  {
                    "text": " — branched from main for urgent fixes and merged back into both main and develop."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Pros:", "bold": true },
              {
                "text": " clear structure, controlled development, and predictable releases."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Cons:", "bold": true },
              {
                "text": " can be overly complex for small teams or continuous delivery workflows."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "33. Czym jest Gitflow Workflow i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Gitflow", "bold": true },
              {
                "text": " to model pracy z Git z jasno określonymi zasadami dla różnych typów gałęzi."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  {
                    "text": " — zawsze reprezentuje stabilną wersję produkcyjną."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " — gałąź integracyjna dla aktywnego rozwoju." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "feature/", "code": true },
                  {
                    "text": " — tworzone z develop i po zakończeniu scalane z powrotem do develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "release/", "code": true },
                  {
                    "text": " — odgałęziane z develop w celu przygotowania wydania, następnie scalane do main i develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "hotfix/", "code": true },
                  {
                    "text": " — tworzone z main dla pilnych poprawek i scalane do main oraz develop."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Zalety:", "bold": true },
              {
                "text": " jasno określona struktura, kontrolowany rozwój i przewidywalne wydania."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Wady:", "bold": true },
              {
                "text": " zbyt rozbudowany proces dla małych zespołów lub podejścia continuous delivery."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 34,
    "translations": {
      "uk": {
        "question": "34. Що таке Forking Workflow у Git і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Forking Workflow", "bold": true },
              {
                "text": " — це підхід, за якого кожен розробник працює не напряму з основним репозиторієм, а зі своєю власною копією (fork)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Процес:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Розробник створює fork головного репозиторію у своєму GitHub або GitLab."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Клонує свій fork локально та створює окрему гілку для змін."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після завершення роботи пушить зміни у власний fork."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Відкриває Pull Request зі свого fork у головний (upstream) репозиторій."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після code review та схвалення зміни зливаються в upstream."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Цей workflow зазвичай використовується у великих open-source проєктах, де стороннім контриб’юторам не надається прямий доступ до основного репозиторію."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "34. What is the Forking Workflow in Git and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Forking Workflow", "bold": true },
              {
                "text": " is an approach where each developer works with their own copy (fork) of the repository instead of pushing directly to the main repository."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Process:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The developer creates a fork of the main repository on GitHub or GitLab."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "They clone their fork locally and create a separate branch for changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After completing the work, they push changes to their fork."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "They open a Pull Request from their fork to the main (upstream) repository."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After review and approval, the changes are merged into the upstream repository."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This workflow is commonly used in large open-source projects where external contributors do not have direct write access to the main repository."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "34. Czym jest Forking Workflow w Git i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Forking Workflow", "bold": true },
              {
                "text": " to podejście, w którym każdy programista pracuje na własnej kopii repozytorium (fork), zamiast bezpośrednio na repozytorium głównym."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Proces:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Programista tworzy fork głównego repozytorium na GitHubie lub GitLabie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Klonuje swój fork lokalnie i tworzy osobną gałąź na zmiany."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po zakończeniu pracy wysyła zmiany (push) do własnego fork’a."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Otwiera Pull Request z własnego fork’a do głównego repozytorium (upstream)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po review i akceptacji zmiany są scalane z repozytorium upstream."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ten workflow jest powszechnie stosowany w dużych projektach open-source, gdzie zewnętrzni kontrybutorzy nie mają bezpośredniego dostępu do głównego repozytorium."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 35,
    "translations": {
      "uk": {
        "question": "35. Що таке Centralized Workflow у Git і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Centralized Workflow", "bold": true },
              {
                "text": " — це модель роботи, у якій є одна головна гілка (зазвичай main), і всі розробники працюють безпосередньо з нею або створюють короткоживучі гілки для невеликих задач."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Процес:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Усі розробники клонують один спільний remote-репозиторій."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Роблять зміни локально та одразу пушать їх у гілку main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "У разі конфліктів їх потрібно вирішити перед пушем."
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Нагадує класичні централізовані системи (SVN), але з перевагами Git: локальна історія та робота офлайн."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Простий процес і мінімальна кількість гілок." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Погано масштабується для великих команд: часті конфлікти та відсутність ізоляції фіч."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "35. What is the Centralized Workflow in Git and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Centralized Workflow", "bold": true },
              {
                "text": " is a model where there is a single main branch (usually main), and all developers work directly on it or create very short-lived branches for small tasks."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Process:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "All developers clone the same shared remote repository."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "They make changes locally and push them directly to the main branch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Any conflicts must be resolved before pushing."
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Similar to traditional centralized systems (SVN), but with Git advantages such as local history and offline work."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Simple process with minimal branching." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Hard to scale for larger teams due to frequent conflicts and lack of feature isolation."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "35. Czym jest Centralized Workflow w Git i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Centralized Workflow", "bold": true },
              {
                "text": " to model pracy, w którym istnieje jedna główna gałąź (zwykle main), a wszyscy programiści pracują bezpośrednio na niej lub tworzą bardzo krótkotrwałe gałęzie dla małych zadań."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Proces:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wszyscy programiści klonują jedno wspólne repozytorium zdalne."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wprowadzają zmiany lokalnie i wysyłają je bezpośrednio do gałęzi main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wszelkie konflikty muszą zostać rozwiązane przed wykonaniem push."
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Przypomina klasyczne systemy scentralizowane (SVN), ale z zaletami Git, takimi jak lokalna historia i praca offline."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Prosty proces i minimalna liczba gałęzi." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Słabo skaluje się w większych zespołach z powodu częstych konfliktów i braku izolacji funkcji."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 36,
    "translations": {
      "uk": {
        "question": "36. Що таке remote repository у Git і для чого він потрібен?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Віддалений репозиторій (remote) — це версія Git-репозиторію, що зберігається на сервері (наприклад, GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Призначення:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Спільна робота команди через push і pull змін."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Централізоване зберігання коду та повної історії комітів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Інтеграція з CI/CD пайплайнами та інструментами перевірки коду."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади команд:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git remote -v              # переглянути підключені remote\n\ngit remote add origin URL  # додати віддалений репозиторій\n\ngit push origin main       # відправити зміни\n\ngit pull origin main       # отримати зміни"
          }
        ]
      },
      "en": {
        "question": "36. What is a remote repository in Git and what is it used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A remote repository is a version of a Git repository hosted on a server (for example, GitHub, GitLab, or Bitbucket)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Purpose:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Enables team collaboration via push and pull operations."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Provides centralized storage of code and full commit history."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Integrates with CI/CD pipelines and code review tools."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example commands:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git remote -v              # list configured remotes\n\ngit remote add origin URL  # add a remote repository\n\ngit push origin main       # push changes\n\ngit pull origin main       # fetch and merge changes"
          }
        ]
      },
      "pl": {
        "question": "36. Czym jest zdalne repozytorium (remote repository) w Git i do czego służy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zdalne repozytorium (remote) to wersja repozytorium Git przechowywana na serwerze (np. GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przeznaczenie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Umożliwia współpracę zespołową poprzez operacje push i pull."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zapewnia centralne przechowywanie kodu i pełnej historii commitów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Integruje się z pipeline’ami CI/CD oraz narzędziami do code review."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykładowe polecenia:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git remote -v              # wyświetl skonfigurowane remote\n\ngit remote add origin URL  # dodaj zdalne repozytorium\n\ngit push origin main       # wyślij zmiany\n\ngit pull origin main       # pobierz i scal zmiany"
          }
        ]
      }
    }
  },
  {
    "question": "37. Як змінити URL remote-репозиторію в Git?",
    "category": "git",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для оновлення URL використовують команду:"
              },
              {
                "type": "code",
                "language": "bash",
                "content": "git remote set-url origin <новий_URL>"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Перевірити зміни можна так:"
              },
              {
                "type": "code",
                "language": "bash",
                "content": "git remote -v"
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Або замінити remote повністю:"
              },
              {
                "type": "code",
                "language": "bash",
                "content": "git remote remove origin\ngit remote add origin <новий_URL>"
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Використовується, наприклад, при переході з HTTPS на SSH чи зміні репозиторію на GitHub/GitLab."
          }
        ]
      }
    ]
  },
  {
    "category": "git",
    "order": 38,
    "translations": {
      "uk": {
        "question": "38. Які команди використовуються, щоб синхронізувати локальний репозиторій з remote у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Отримати останні зміни з remote:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Об’єднати з локальною гілкою:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git pull origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "(еквівалент fetch + merge)." }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Відправити свої зміни на remote:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коротко:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "pull → підтягнути зміни, push → відправити свої." }
            ]
          }
        ]
      },
      "en": {
        "question": "38. Which commands are used to synchronize a local repository with a remote in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Fetch the latest changes from the remote repository:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Merge changes into the local branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git pull origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "(equivalent to fetch + merge)." }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Push your local changes to the remote repository:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In short:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "pull → fetch and integrate changes, push → send your changes."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "38. Jakie polecenia służą do synchronizacji lokalnego repozytorium z repozytorium zdalnym w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Pobranie najnowszych zmian z repozytorium zdalnego:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Scalenie zmian z lokalną gałęzią:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git pull origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "(odpowiednik fetch + merge)." }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wysłanie własnych zmian do repozytorium zdalnego:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W skrócie:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "pull → pobrać i scalić zmiany, push → wysłać własne zmiany."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 39,
    "translations": {
      "uk": {
        "question": "39. Як видалити невикористані (застарілі) гілки локально й на remote у Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Локально:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch -d branch_name      # видалити вже злиту гілку\n\ngit branch -D branch_name      # примусово видалити"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Віддалено:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git push origin --delete branch_name"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Очистити локальний список remote-гілок (які вже видалені на сервері):"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fetch --prune"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Практика:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Після merge у main видаляють feature-гілки, щоб не захаращувати репозиторій."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "39. How can you delete unused (obsolete) branches locally and on a remote in Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Locally:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch -d branch_name      # delete a branch that has already been merged\n\ngit branch -D branch_name      # force delete"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Remotely:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git push origin --delete branch_name"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Clean up the local list of remote branches (already deleted on the server):"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fetch --prune"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Best practice:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "After merging into main, feature branches should be deleted to keep the repository clean."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "39. Jak usunąć nieużywane (przestarzałe) gałęzie lokalnie i na zdalnym repozytorium w Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Lokalnie:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch -d branch_name      # usuń gałąź, która została już scalona\n\ngit branch -D branch_name      # wymuś usunięcie"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zdalnie:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git push origin --delete branch_name"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Wyczyścić lokalną listę gałęzi zdalnych (usuniętych już na serwerze):"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fetch --prune"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Praktyka:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Po scaleniu z main usuwa się gałęzie feature, aby nie zaśmiecać repozytorium."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 40,
    "translations": {
      "uk": {
        "question": "40. Які кроки потрібно виконати для вирішення merge conflict у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Спробувати злиття або rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git повідомляє про конфлікти. Перевірити файли:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git status"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відкрити конфліктні файли, знайти маркери:" },
                  {
                    "type": "code",
                    "language": "text",
                    "content": "<<<<<<< HEAD\n...\n=======\n...\n>>>>>>> feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Вирішити конфлікт вручну (залишити або об’єднати потрібні зміни)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити файли як вирішені:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Продовжити merge або rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit            # якщо merge\n\ngit rebase --continue # якщо rebase"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Перевірити, що все працює, і запушити зміни:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "40. What steps are required to resolve a merge conflict in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Attempt a merge or rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git reports conflicts. Check the affected files:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git status"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Open the conflicted files and locate conflict markers:"
                  },
                  {
                    "type": "code",
                    "language": "text",
                    "content": "<<<<<<< HEAD\n...\n=======\n...\n>>>>>>> feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Resolve the conflict manually by keeping or combining the correct changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark the files as resolved:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Continue the merge or rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit            # for merge\n\ngit rebase --continue # for rebase"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Verify everything works and push the changes:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "40. Jakie kroki należy wykonać, aby rozwiązać konflikt scalania (merge conflict) w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Spróbować wykonać merge lub rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git zgłasza konflikty. Sprawdzić pliki:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git status"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Otworzyć pliki konfliktowe i znaleźć znaczniki:"
                  },
                  {
                    "type": "code",
                    "language": "text",
                    "content": "<<<<<<< HEAD\n...\n=======\n...\n>>>>>>> feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Rozwiązać konflikt ręcznie, zachowując lub łącząc właściwe zmiany."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć pliki jako rozwiązane:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontynuować merge lub rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit            # dla merge\n\ngit rebase --continue # dla rebase"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sprawdzić działanie i wypchnąć zmiany:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 41,
    "translations": {
      "uk": {
        "question": "41. Для чого призначена команда git stash?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git stash", "code": true },
              {
                "text": " дозволяє тимчасово сховати незавершені зміни (modified / staged файли) у локальному репозиторії, щоб переключитися на іншу гілку або виконати інші операції без створення коміту."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash           # сховати зміни\n\ngit stash pop       # повернути сховані зміни\n\ngit stash list      # переглянути список схованих змін"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовується, коли потрібно швидко переключитися на main для виправлення багу або підтягнути останні зміни."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "41. What is the purpose of the git stash command?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git stash", "code": true },
              {
                "text": " temporarily saves unfinished changes (modified / staged files) in the local repository, allowing you to switch branches or perform other operations without committing them."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash           # save changes\n\ngit stash pop       # restore saved changes\n\ngit stash list      # list saved stashes"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It is commonly used when you need to quickly switch to main to fix a bug or pull the latest changes."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "41. Do czego służy polecenie git stash?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git stash", "code": true },
              {
                "text": " pozwala tymczasowo ukryć niezakończone zmiany (pliki modified / staged) w lokalnym repozytorium, aby przełączyć się na inną gałąź lub wykonać inne operacje bez tworzenia commita."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash           # ukryj zmiany\n\ngit stash pop       # przywróć zapisane zmiany\n\ngit stash list      # lista zapisanych zmian"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Używane, gdy trzeba szybko przełączyć się na main, aby naprawić błąd lub pobrać najnowsze zmiany."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 42,
    "translations": {
      "uk": {
        "question": "42. Як переглянути зміни у файлах, які ще не закомічені, або історію комітів у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Зміни в робочому каталозі (не staged):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зміни, які вже додані до staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff --staged"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Історія комітів:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Коротка та наочна історія:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline --graph --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд змін конкретного файлу:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff <file>\n\ngit log -p <file>"
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "42. How can you view uncommitted file changes or the commit history in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Changes in the working directory (not staged):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Changes already added to the staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff --staged"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit history:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Compact and visual history:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline --graph --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "View changes of a specific file:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff <file>\n\ngit log -p <file>"
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "42. Jak sprawdzić niezacommitowane zmiany w plikach lub historię commitów w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zmiany w katalogu roboczym (nie dodane do stage):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zmiany dodane do staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff --staged"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Historia commitów:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Krótka i czytelna historia:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline --graph --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podgląd zmian w konkretnym pliku:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff <file>\n\ngit log -p <file>"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 43,
    "translations": {
      "uk": {
        "question": "43. Чи можна застосувати зміни з Git stash, не видаляючи їх зі списку?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [{ "text": "Так, для цього використовують команду:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Застосовує вибрану сховану зміну до поточної робочої гілки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Не видаляє її зі списку stash." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Якщо потрібно одночасно застосувати зміни і видалити їх зі списку, використовують:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash pop"
          }
        ]
      },
      "en": {
        "question": "43. Can you apply changes from Git stash without removing them from the list?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Yes, this can be done using the following command:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Applies the selected stashed changes to the current working branch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Does not remove the stash entry from the stash list."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "If you want to apply the changes and remove them from the list at the same time, use:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash pop"
          }
        ]
      },
      "pl": {
        "question": "43. Czy można zastosować zmiany z Git stash bez usuwania ich z listy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [{ "text": "Tak, w tym celu używa się polecenia:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Stosuje wybrane zapisane zmiany do bieżącej gałęzi roboczej."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Nie usuwa ich z listy stash." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jeśli chcesz jednocześnie zastosować zmiany i usunąć je z listy, użyj:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash pop"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 44,
    "translations": {
      "uk": {
        "question": "44. Що робить команда git clean?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clean", "code": true },
              {
                "text": " видаляє незатрековані файли та каталоги з робочого каталогу, тобто ті, що не відслідковуються Git."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clean -n       # показати, що буде видалено (dry-run)\n\ngit clean -f       # видалити незатрековані файли\n\ngit clean -fd      # видалити файли та каталоги\n\ngit clean -fx      # видалити файли, включаючи ті, що в .gitignore"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовується для очищення робочого каталогу перед збіркою або тестуванням, коли потрібен повністю чистий стан."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "44. What does the git clean command do?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clean", "code": true },
              {
                "text": " removes untracked files and directories from the working directory, meaning files that are not tracked by Git."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clean -n       # show what would be removed (dry-run)\n\ngit clean -f       # remove untracked files\n\ngit clean -fd      # remove files and directories\n\ngit clean -fx      # remove files including those in .gitignore"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It is used to clean the working directory before builds or tests when a completely clean state is required."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "44. Co robi polecenie git clean?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clean", "code": true },
              {
                "text": " usuwa nieśledzone pliki i katalogi z katalogu roboczego, czyli te, które nie są śledzone przez Git."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clean -n       # pokaż, co zostanie usunięte (dry-run)\n\ngit clean -f       # usuń nieśledzone pliki\n\ngit clean -fd      # usuń pliki i katalogi\n\ngit clean -fx      # usuń pliki, w tym te z .gitignore"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie jest używane do czyszczenia katalogu roboczego przed budowaniem lub testami, gdy wymagany jest całkowicie czysty stan."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 45,
    "translations": {
      "uk": {
        "question": "45. Як видалити файл з відслідковування Git, але залишити його в локальному робочому каталозі?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Для цього використовують команду:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Файл видаляється з індексу (staging area), але залишається у робочому каталозі."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після коміту і пушу Git більше не буде відслідковувати цей файл."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Типовий сценарій — прибрати конфіг або секрети з репозиторію, залишивши файл локально."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>\n\ngit commit -m \"Stop tracking file\""
          }
        ]
      },
      "en": {
        "question": "45. How can you stop tracking a file in Git while keeping it in the local working directory?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Use the following command:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The file is removed from the index (staging area) but remains in the working directory."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After committing and pushing, Git will no longer track this file."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This is commonly used to remove configuration or secret files from version control while keeping them locally."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>\n\ngit commit -m \"Stop tracking file\""
          }
        ]
      },
      "pl": {
        "question": "45. Jak przestać śledzić plik w Git, pozostawiając go w lokalnym katalogu roboczym?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W tym celu używa się polecenia:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Plik zostaje usunięty z indeksu (staging area), ale pozostaje w katalogu roboczym."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po wykonaniu commita i pusha Git przestaje śledzić ten plik."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Często stosowane do usuwania plików konfiguracyjnych lub sekretów z repozytorium."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>\n\ngit commit -m \"Stop tracking file\""
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 46,
    "translations": {
      "uk": {
        "question": "46. Як переглянути історію комітів у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Базовий перегляд:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Коротка форма:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Графічне відображення гілок:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --graph --oneline --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд змін у конкретному коміті:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -p\n\ngit show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Фільтрація історії по файлу:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ці команди використовуються для аналізу історії, пошуку змін і розуміння того, хто та коли зробив певний коміт."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "46. How can you view the commit history in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Basic view:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Short format:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Graphical view of branches:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --graph --oneline --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "View changes inside commits:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -p\n\ngit show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Filter history by file:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "These commands are used to analyze history, track changes, and see who made specific commits and when."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "46. Jak wyświetlić historię commitów w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Podstawowy widok:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Krótka forma:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Graficzne przedstawienie gałęzi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --graph --oneline --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podgląd zmian w commitach:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -p\n\ngit show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Filtrowanie historii według pliku:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenia te służą do analizy historii, wyszukiwania zmian oraz sprawdzania, kto i kiedy wykonał dany commit."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 47,
    "translations": {
      "uk": {
        "question": "47. Як знайти всі коміти певного автора у Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Використовують команду git log з опцією " },
                  { "text": "--author", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Ім'я або email автора\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Додатково можна скоротити вивід до одного рядка:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Ім'я\" --oneline"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Це дозволяє переглянути всі коміти конкретного розробника в межах проєкту."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "47. How can you find all commits made by a specific author in Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Use the git log command with the " },
                  { "text": "--author", "code": true },
                  { "text": " option:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Author name or email\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You can also shorten the output to a single line per commit:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Name\" --oneline"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This makes it easy to review all commits created by a specific developer in the project."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "47. Jak znaleźć wszystkie commity wykonane przez konkretnego autora w Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Używa się polecenia git log z opcją " },
                  { "text": "--author", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Imię lub email autora\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Można również skrócić wynik do jednej linii na commit:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Imię\" --oneline"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Dzięki temu można łatwo przejrzeć wszystkie commity wykonane przez danego programistę w projekcie."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 48,
    "translations": {
      "uk": {
        "question": "48. Як переглянути зміни, внесені конкретним комітом у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд повних змін коміту:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Короткий варіант:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --stat <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд змін конкретного файлу в коміті:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash> -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовується для аналізу змін, перевірки перед злиттям або дебагу проблем."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "48. How can you view the changes introduced by a specific commit in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "View full commit changes:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Short summary view:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --stat <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "View changes of a specific file in a commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash> -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This is used for analysis, reviewing changes before merging, or debugging issues."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "48. Jak sprawdzić zmiany wprowadzone przez konkretny commit w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wyświetlenie pełnych zmian commita:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wersja skrócona:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --stat <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podgląd zmian konkretnego pliku w commicie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash> -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenia te służą do analizy zmian, przeglądu przed scaleniem oraz debugowania."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 49,
    "translations": {
      "uk": {
        "question": "49. Як переглянути список файлів, змінених у конкретному коміті Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Використовують команду git show з параметром " },
                  { "text": "--name-only", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-only <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Показує лише імена файлів без відображення diff." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Або використати " },
                  { "text": "--name-status", "code": true },
                  {
                    "text": " для перегляду статусу змін (додано, змінено, видалено):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-status <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Для перегляду diff разом зі списком файлів:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Корисно для швидкого огляду змін у коміті без детального аналізу коду."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "49. How can you view the list of files changed in a specific Git commit?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Use the git show command with the " },
                  { "text": "--name-only", "code": true },
                  { "text": " option:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-only <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This displays only the file names without showing the diff."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Or use " },
                  { "text": "--name-status", "code": true },
                  {
                    "text": " to see file change statuses (added, modified, deleted):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-status <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "To view both file list and diff:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This is useful for quickly reviewing what changed in a commit without analyzing the full diff."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "49. Jak wyświetlić listę plików zmienionych w konkretnym commicie Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Użyj polecenia git show z opcją " },
                  { "text": "--name-only", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-only <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Wyświetla tylko nazwy plików bez diffów." }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Można też użyć " },
                  { "text": "--name-status", "code": true },
                  {
                    "text": ", aby zobaczyć status zmian (dodany, zmodyfikowany, usunięty):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-status <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aby zobaczyć listę plików razem z diffem:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Przydatne do szybkiego sprawdzenia, co zostało zmienione w danym commicie."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 50,
    "translations": {
      "uk": {
        "question": "50. Що робить команда git blame у Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Команда " },
              { "text": "git blame <file>", "code": true },
              {
                "text": " показує, хто і коли вніс кожен рядок у вказаному файлі."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Для кожного рядка відображається коміт, автор і дата змін."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Допомагає швидко знайти відповідального за зміну або зрозуміти історію конкретного рядка коду."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git blame app.js\ngit blame -L 10,20 app.js   # лише рядки з 10 по 20"
          }
        ]
      },
      "en": {
        "question": "50. What does the git blame command do in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": "git blame <file>", "code": true },
              {
                "text": " command shows who and when modified each line in a file."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "For each line, it displays the commit hash, author, and date."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Helps quickly identify who introduced a change or understand the history of a specific line of code."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git blame app.js\ngit blame -L 10,20 app.js   # show only lines 10 to 20"
          }
        ]
      },
      "pl": {
        "question": "50. Co robi polecenie git blame w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Polecenie " },
              { "text": "git blame <file>", "code": true },
              {
                "text": " pokazuje, kto i kiedy zmodyfikował każdą linię w pliku."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Dla każdej linii wyświetlany jest commit, autor i data."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Pomaga szybko znaleźć osobę odpowiedzialną za zmianę lub zrozumieć historię konkretnej linii kodu."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git blame app.js\ngit blame -L 10,20 app.js   # tylko linie od 10 do 20"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 51,
    "translations": {
      "uk": {
        "question": "51. Що таке теги в Git і чим вони відрізняються від гілок?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Тег", "bold": true },
              {
                "text": " — це фіксована позначка на конкретному коміті, зазвичай для позначення релізів (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Гілка", "bold": true },
              {
                "text": " — це рухомий вказівник на останній коміт у лінії розробки, куди постійно додаються нові коміти."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні відмінності:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Характеристика" }],
              [{ "text": "Тег" }],
              [{ "text": "Гілка" }]
            ],
            "rows": [
              [
                [{ "text": "Рухливість" }],
                [{ "text": "Нерухомий" }],
                [{ "text": "Рухливий" }]
              ],
              [
                [{ "text": "Призначення" }],
                [{ "text": "Позначення релізів" }],
                [{ "text": "Активна розробка" }]
              ],
              [
                [{ "text": "Нові коміти" }],
                [{ "text": "Не додаються" }],
                [{ "text": "Додаються постійно" }]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад створення тега:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git tag v1.0\ngit push origin v1.0"
          }
        ]
      },
      "en": {
        "question": "51. What are tags in Git and how do they differ from branches?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A tag", "bold": true },
              {
                "text": " is a fixed reference to a specific commit, commonly used to mark releases (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "A branch", "bold": true },
              {
                "text": " is a movable pointer to the latest commit in a line of development, where new commits are continuously added."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key differences:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Characteristic" }],
              [{ "text": "Tag" }],
              [{ "text": "Branch" }]
            ],
            "rows": [
              [
                [{ "text": "Movability" }],
                [{ "text": "Immutable" }],
                [{ "text": "Movable" }]
              ],
              [
                [{ "text": "Purpose" }],
                [{ "text": "Release marking" }],
                [{ "text": "Active development" }]
              ],
              [
                [{ "text": "New commits" }],
                [{ "text": "Not added" }],
                [{ "text": "Added continuously" }]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example of creating a tag:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git tag v1.0\ngit push origin v1.0"
          }
        ]
      },
      "pl": {
        "question": "51. Czym są tagi w Git i czym różnią się od gałęzi?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Tag", "bold": true },
              {
                "text": " to stałe oznaczenie konkretnego commita, zwykle używane do oznaczania wydań (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Gałąź", "bold": true },
              {
                "text": " to ruchomy wskaźnik na ostatni commit w linii rozwoju, do którego stale dodawane są nowe commity."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne różnice:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Cecha" }],
              [{ "text": "Tag" }],
              [{ "text": "Gałąź" }]
            ],
            "rows": [
              [
                [{ "text": "Ruchomość" }],
                [{ "text": "Nieruchomy" }],
                [{ "text": "Ruchomy" }]
              ],
              [
                [{ "text": "Zastosowanie" }],
                [{ "text": "Oznaczanie wydań" }],
                [{ "text": "Aktywny rozwój" }]
              ],
              [
                [{ "text": "Nowe commity" }],
                [{ "text": "Nie są dodawane" }],
                [{ "text": "Są dodawane" }]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład tworzenia taga:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git tag v1.0\ngit push origin v1.0"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 52,
    "translations": {
      "uk": {
        "question": "52. Як у Git створювати, видаляти та пушити теги?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Створення тегів:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight тег:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated тег (з повідомленням):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0 -m \"Release version 1.0\""
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Видалення тегів:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Локально:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -d v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Віддалено:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --delete v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Надсилання тегів на remote:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Один тег:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Всі теги:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --tags"
                  }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "52. How do you create, delete, and push tags in Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Creating tags:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight tag:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated tag (with message):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0 -m \"Release version 1.0\""
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Deleting tags:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Locally:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -d v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Remotely:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --delete v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Pushing tags to remote:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Single tag:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "All tags:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --tags"
                  }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "52. Jak w Git tworzyć, usuwać i wysyłać tagi?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tworzenie tagów:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lekki tag (lightweight):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tag opisowy (annotated):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0 -m \"Release version 1.0\""
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usuwanie tagów:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lokalnie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -d v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zdalnie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --delete v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wysyłanie tagów na remote:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Pojedynczy tag:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wszystkie tagi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --tags"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 53,
    "translations": {
      "uk": {
        "question": "53. Що таке семантичне версіонування і як його використовують у Git-тегах?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Семантичне версіонування (SemVer) — це система нумерації версій у форматі "
              },
              {
                "text": "MAJOR.MINOR.PATCH",
                "code": true
              },
              {
                "text": ", яка відображає характер змін у релізі:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "MAJOR", "code": true },
                  { "text": " — несумісні зміни API." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MINOR", "code": true },
                  { "text": " — новий функціонал без порушення сумісності." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PATCH", "code": true },
                  { "text": " — виправлення багів без зміни функціоналу." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "У Git-тегах SemVer використовують для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначення релізів (наприклад v1.2.3)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Розуміння стабільності та сумісності версій." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Автоматизації CI/CD деплою за тегами." }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "53. What is semantic versioning and how is it used in Git tags?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Semantic Versioning (SemVer) is a versioning scheme using the format "
              },
              {
                "text": "MAJOR.MINOR.PATCH",
                "code": true
              },
              {
                "text": " to communicate the type of changes in a release:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "MAJOR", "code": true },
                  { "text": " — incompatible API changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MINOR", "code": true },
                  { "text": " — backward-compatible new features." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PATCH", "code": true },
                  { "text": " — backward-compatible bug fixes." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "In Git tags, SemVer is used to:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Mark releases (e.g. v1.2.3)." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Clearly indicate compatibility and stability." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Trigger CI/CD pipelines based on version tags." }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "53. Czym jest wersjonowanie semantyczne i jak jest używane w tagach Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wersjonowanie semantyczne (SemVer) to system numerowania wersji w formacie "
              },
              {
                "text": "MAJOR.MINOR.PATCH",
                "code": true
              },
              {
                "text": ", który opisuje charakter zmian w wydaniu:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "MAJOR", "code": true },
                  { "text": " — niekompatybilne zmiany API." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MINOR", "code": true },
                  { "text": " — nowe funkcje zachowujące kompatybilność." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PATCH", "code": true },
                  { "text": " — poprawki błędów bez zmiany funkcjonalności." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "W tagach Git SemVer służy do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Oznaczania wydań (np. v1.2.3)." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Łatwego określenia stabilności i kompatybilności."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Integracji z CI/CD do automatycznych wdrożeń." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 54,
    "translations": {
      "uk": {
        "question": "54. Як у Git перейти на конкретний тег?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Теги не є гілками, тому перехід на тег переводить репозиторій у стан "
              },
              {
                "text": "detached HEAD",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout v1.0"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Або з використанням сучасного синтаксису:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git switch --detach v1.0"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У цьому режимі можна переглядати, збирати або тестувати код, але нові коміти не будуть прив’язані до жодної гілки."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Щоб продовжити роботу з тегу як із гілки:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b release-1.0 v1.0"
          }
        ]
      },

      "en": {
        "question": "54. How can you switch to a specific tag in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tags are not branches, so checking out a tag puts the repository into a "
              },
              {
                "text": "detached HEAD",
                "code": true
              },
              {
                "text": " state."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout v1.0"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Or using the newer syntax:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git switch --detach v1.0"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In this mode you can inspect, build, or test the code, but new commits will not belong to any branch."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "To continue working from a tag as a branch:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b release-1.0 v1.0"
          }
        ]
      },

      "pl": {
        "question": "54. Jak przełączyć się na konkretny tag w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tagi nie są gałęziami, dlatego przejście na tag powoduje stan "
              },
              {
                "text": "detached HEAD",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout v1.0"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Lub z użyciem nowszej składni:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git switch --detach v1.0"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W tym trybie można przeglądać, budować lub testować kod, ale nowe commity nie będą przypisane do żadnej gałęzi."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Aby kontynuować pracę z tagu jako z gałęzi:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b release-1.0 v1.0"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 55,
    "translations": {
      "uk": {
        "question": "55. Як у Git створити реліз на основі тегу?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Створити тег на потрібному коміті:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0.0 -m \"Release 1.0.0\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Надіслати тег у віддалений репозиторій:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Або надіслати всі теги одразу:"
              },
              {
                "type": "code",
                "language": "bash",
                "content": "git push origin --tags"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "У системі керування кодом (GitHub / GitLab / Bitbucket) створити реліз на основі тега:"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "GitHub: вкладка " },
                          { "text": "Releases", "code": true },
                          { "text": " → Draft a new release → вибрати тег." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Додати опис змін (changelog)." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Опублікувати реліз." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Релізи на основі тегів зручні для CI/CD — можна автоматично запускати збірку та деплой при появі нового тега."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "55. How can you create a release from a tag in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Create a tag on the desired commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0.0 -m \"Release 1.0.0\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Push the tag to the remote repository:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Or push all tags at once:" },
              {
                "type": "code",
                "language": "bash",
                "content": "git push origin --tags"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "In a code hosting platform (GitHub / GitLab / Bitbucket), create a release based on the tag:"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "GitHub: go to " },
                          { "text": "Releases", "code": true },
                          { "text": " → Draft a new release → select the tag." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Add release notes or a changelog." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Publish the release." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tag-based releases work well with CI/CD pipelines, enabling automated builds and deployments triggered by version tags."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "55. Jak utworzyć release na podstawie taga w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Utworzyć tag na odpowiednim commicie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0.0 -m \"Release 1.0.0\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wysłać tag do zdalnego repozytorium:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Lub wysłać wszystkie tagi jednocześnie:" },
              {
                "type": "code",
                "language": "bash",
                "content": "git push origin --tags"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "W systemie hostującym kod (GitHub / GitLab / Bitbucket) utworzyć release na podstawie taga:"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "GitHub: zakładka " },
                          { "text": "Releases", "code": true },
                          { "text": " → Draft a new release → wybrać tag." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Dodać opis zmian (changelog)." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Opublikować release." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Release’y oparte na tagach są wygodne w CI/CD — pozwalają automatycznie uruchamiać buildy i wdrożenia."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 56,
    "translations": {
      "uk": {
        "question": "56. Що таке Git submodule і в яких випадках його доцільно використовувати?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git submodule", "bold": true },
              {
                "text": " — це механізм, що дозволяє вбудовувати один Git-репозиторій в інший як залежність. Основний репозиторій зберігає посилання на конкретний коміт підмодуля."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується, коли:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Є спільна бібліотека або модуль, що використовується в кількох проєктах."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Потрібно зафіксувати залежність на конкретному коміті, а не на останній версії."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Потрібно уникнути дублювання коду між репозиторіями."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад додавання підмодуля:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git submodule add https://github.com/example/lib.git libs/lib\ngit submodule update --init --recursive"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Складніший workflow: підмодулі потрібно оновлювати вручну, а при клонуванні репозиторію слід використовувати прапорець --recursive."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "56. What is a Git submodule and when should it be used?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git submodule", "bold": true },
              {
                "text": " is a mechanism that allows you to embed one Git repository inside another as a dependency. The parent repository stores a reference to a specific commit of the submodule."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "It is useful when:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You have a shared library or module used across multiple projects."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You need to lock a dependency to a specific commit rather than the latest version."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You want to avoid copying code between repositories."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example of adding a submodule:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git submodule add https://github.com/example/lib.git libs/lib\ngit submodule update --init --recursive"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Drawbacks:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Submodules introduce a more complex workflow: updates must be done manually, and repositories should be cloned using the --recursive flag."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "56. Czym jest Git submodule i kiedy warto go używać?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git submodule", "bold": true },
              {
                "text": " to mechanizm pozwalający osadzić jedno repozytorium Git w innym jako zależność. Repozytorium nadrzędne przechowuje odwołanie do konkretnego commita podmodułu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Stosuje się, gdy:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Istnieje wspólna biblioteka lub moduł używany w wielu projektach."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Trzeba przypiąć zależność do konkretnego commita, a nie do najnowszej wersji."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Chce się uniknąć kopiowania kodu między repozytoriami."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład dodania podmodułu:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git submodule add https://github.com/example/lib.git libs/lib\ngit submodule update --init --recursive"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Bardziej złożony workflow — podmoduły trzeba aktualizować ręcznie, a klonowanie repozytorium wymaga użycia opcji --recursive."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 57,
    "translations": {
      "uk": {
        "question": "57. Що таке Git hooks і для чого вони потрібні?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git hooks", "bold": true },
              {
                "text": " — це скрипти, які автоматично виконуються при певних подіях у Git-репозиторії (наприклад, перед комітом, перед пушем або після злиття). Вони зберігаються в каталозі "
              },
              { "text": ".git/hooks", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовуються для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Перевірки стилю коду або запуску лінтерів перед комітом ("
                  },
                  { "text": "pre-commit", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Заборони прямого пушу в " },
                  { "text": "main", "code": true },
                  { "text": " (" },
                  { "text": "pre-push", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Автоматичного оновлення залежностей або документації після злиття ("
                  },
                  { "text": "post-merge", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Генерації changelog або перевірки повідомлень комітів."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Приклад pre-commit hook для перевірки ESLint:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "#!/bin/sh\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"Lint errors found. Commit aborted.\"\n  exit 1\nfi"
          }
        ]
      },

      "en": {
        "question": "57. What are Git hooks and what are they used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git hooks", "bold": true },
              {
                "text": " are scripts that automatically run on specific Git events (such as before a commit, before a push, or after a merge). They are stored in the "
              },
              { "text": ".git/hooks", "code": true },
              { "text": " directory." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "They are commonly used to:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Run linters or code style checks before committing ("
                  },
                  { "text": "pre-commit", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Prevent direct pushes to " },
                  { "text": "main", "code": true },
                  { "text": " (" },
                  { "text": "pre-push", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Automatically update dependencies or documentation after merges ("
                  },
                  { "text": "post-merge", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Generate changelogs or validate commit messages." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example of a pre-commit hook for ESLint:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "#!/bin/sh\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"Lint errors found. Commit aborted.\"\n  exit 1\nfi"
          }
        ]
      },

      "pl": {
        "question": "57. Czym są Git hooks i do czego służą?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git hooks", "bold": true },
              {
                "text": " to skrypty uruchamiane automatycznie przy określonych zdarzeniach w repozytorium Git (np. przed commitem, przed pushem lub po merge). Znajdują się w katalogu "
              },
              { "text": ".git/hooks", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Są wykorzystywane do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Uruchamiania linterów lub sprawdzania stylu kodu przed commitem ("
                  },
                  { "text": "pre-commit", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Blokowania bezpośredniego pusha do " },
                  { "text": "main", "code": true },
                  { "text": " (" },
                  { "text": "pre-push", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Automatycznego aktualizowania zależności lub dokumentacji po merge ("
                  },
                  { "text": "post-merge", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Generowania changelogów lub walidacji wiadomości commitów."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład hooka pre-commit dla ESLint:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "#!/bin/sh\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"Lint errors found. Commit aborted.\"\n  exit 1\nfi"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 58,
    "translations": {
      "uk": {
        "question": "58. Як у Git об’єднати кілька комітів у один (squash)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Squash", "bold": true },
              {
                "text": " — це об’єднання кількох комітів у один. Найчастіше використовується перед злиттям гілки в "
              },
              { "text": "main", "code": true },
              { "text": " або " },
              { "text": "develop", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основний спосіб — interactive rebase:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rebase -i HEAD~N"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "де " },
              { "text": "N", "code": true },
              {
                "text": " — кількість останніх комітів, які потрібно об’єднати."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "У відкритому редакторі:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перший коміт залишаєш як " },
                  { "text": "pick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Для наступних змінюєш " },
                  { "text": "pick", "code": true },
                  { "text": " на " },
                  { "text": "squash (s)", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Після збереження Git об’єднає коміти та запропонує відредагувати фінальне повідомлення."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коли використовують squash:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Очищення історії перед merge." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Формування зрозумілого changelog." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Приховування дрібних або проміжних комітів." }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "58. How can you squash multiple commits into one in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Squash", "bold": true },
              {
                "text": " means combining several commits into a single one. It is commonly used before merging a branch into "
              },
              { "text": "main", "code": true },
              { "text": " or " },
              { "text": "develop", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "The main approach is interactive rebase:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rebase -i HEAD~N"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "where " },
              { "text": "N", "code": true },
              {
                "text": " is the number of recent commits you want to combine."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In the editor:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Keep the first commit as " },
                  { "text": "pick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Change the following commits from " },
                  { "text": "pick", "code": true },
                  { "text": " to " },
                  { "text": "squash (s)", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "After saving, Git will combine the commits and prompt you to edit the final commit message."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "When squash is used:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Cleaning up history before merging." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Creating a clear and readable changelog." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hiding noisy or intermediate commits." }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "58. Jak w Git połączyć kilka commitów w jeden (squash)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Squash", "bold": true },
              {
                "text": " to połączenie kilku commitów w jeden. Najczęściej stosowane przed scaleniem gałęzi do "
              },
              { "text": "main", "code": true },
              { "text": " lub " },
              { "text": "develop", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Podstawowa metoda — interactive rebase:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rebase -i HEAD~N"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "gdzie " },
              { "text": "N", "code": true },
              { "text": " oznacza liczbę ostatnich commitów do połączenia." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W edytorze:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Pierwszy commit zostawiasz jako " },
                  { "text": "pick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dla kolejnych zmieniasz " },
                  { "text": "pick", "code": true },
                  { "text": " na " },
                  { "text": "squash (s)", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Po zapisaniu Git połączy commity i pozwoli edytować końcową wiadomość."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kiedy stosować squash:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Czyszczenie historii przed merge." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Tworzenie czytelnego changelogu." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ukrywanie drobnych commitów technicznych." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 59,
    "translations": {
      "uk": {
        "question": "59. Що таке git bisect і як із ним працювати?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git bisect", "code": true },
              {
                "text": " — це інструмент Git для бінарного пошуку коміту, який ввів баг. Він автоматично звужує діапазон між "
              },
              { "text": "good", "code": true },
              { "text": " і " },
              { "text": "bad", "code": true },
              { "text": " комітами." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основний workflow:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Запустити bisect:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect start"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити поточний стан як " },
                  { "text": "bad", "code": true },
                  { "text": " (баг присутній):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect bad"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вказати коміт, де все працювало:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git автоматично переключається на середній коміт. Ви тестуєте код і повідомляєте результат:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good   # якщо багу немає\ngit bisect bad    # якщо баг присутній"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Процес повторюється, доки Git не знайде проблемний коміт."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Завершити та повернутись у початковий стан:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect reset"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "git bisect особливо корисний у великих проєктах з довгою історією комітів, коли вручну знайти джерело багу складно."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "59. What is git bisect and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git bisect", "code": true },
              {
                "text": " is a Git tool for performing a binary search to find the commit that introduced a bug. It automatically narrows the range between "
              },
              { "text": "good", "code": true },
              { "text": " and " },
              { "text": "bad", "code": true },
              { "text": " commits." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Typical workflow:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Start bisect mode:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect start"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark the current commit as " },
                  { "text": "bad", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect bad"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Specify a known good commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git checks out a midpoint commit. You test it and report the result:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good   # bug not present\ngit bisect bad    # bug present"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The process repeats until the faulty commit is identified."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Exit bisect mode and return to the original state:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect reset"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "git bisect is especially useful in large projects with long histories where manual debugging would be too slow."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "59. Czym jest git bisect i jak z niego korzystać?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git bisect", "code": true },
              {
                "text": " to narzędzie Git do wyszukiwania commitów metodą binarną w celu znalezienia tego, który wprowadził błąd. Automatycznie zawęża zakres między "
              },
              { "text": "good", "code": true },
              { "text": " a " },
              { "text": "bad", "code": true },
              { "text": " commitami." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Typowy workflow:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Uruchomić tryb bisect:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect start"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć bieżący commit jako " },
                  { "text": "bad", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect bad"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wskazać commit, w którym wszystko działało poprawnie:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git przełącza się na commit pośredni. Testujesz i zgłaszasz wynik:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good   # błąd nie występuje\ngit bisect bad    # błąd występuje"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Proces trwa do momentu znalezienia problematycznego commita."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zakończyć bisect i wrócić do poprzedniego stanu:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect reset"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "git bisect jest bardzo przydatny w dużych projektach z długą historią commitów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 60,
    "translations": {
      "uk": {
        "question": "60. Як вручну вирішити конфлікт при злитті в Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge conflict виникає, коли Git не може автоматично об’єднати зміни з двох гілок. У такому випадку конфлікт потрібно вирішити вручну."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Кроки вирішення:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Запустити злиття гілок:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git зупиниться та повідомить про файли з конфліктами."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Відкрити конфліктні файли — вони міститимуть маркери:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "<<<<<<< HEAD\nкод з поточної гілки\n=======\nкод з feature-branch\n>>>>>>> feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Вибрати або об’єднати потрібні зміни вручну та видалити маркери конфлікту."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити файл як вирішений:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Завершити злиття:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Якщо merge-коміт не створився автоматично, його потрібно зробити вручну."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для зручності можна використовувати графічні інструменти злиття (VS Code, IntelliJ, Meld)."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "60. How can you manually resolve a merge conflict in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A merge conflict occurs when Git cannot automatically combine changes from two branches. In this case, the conflict must be resolved manually."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Resolution steps:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Start the merge:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git stops and reports files with conflicts." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Open the conflicted files — they will contain conflict markers:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "<<<<<<< HEAD\ncode from current branch\n=======\ncode from feature-branch\n>>>>>>> feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Manually choose or merge the correct changes and remove the conflict markers."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark the conflict as resolved:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Finish the merge:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "If Git does not create the merge commit automatically, you need to commit it manually."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Graphical merge tools such as VS Code, IntelliJ, or Meld can simplify conflict resolution."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "60. Jak ręcznie rozwiązać konflikt scalania w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Konflikt scalania występuje, gdy Git nie może automatycznie połączyć zmian z dwóch gałęzi. Wtedy konflikt trzeba rozwiązać ręcznie."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kroki rozwiązania:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Rozpocząć scalanie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git zatrzyma się i wskaże pliki z konfliktami." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Otworzyć pliki z konfliktami — zawierają znaczniki:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "<<<<<<< HEAD\nkod z bieżącej gałęzi\n=======\nkod z feature-branch\n>>>>>>> feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Ręcznie wybrać lub połączyć poprawne zmiany i usunąć znaczniki konfliktu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć konflikt jako rozwiązany:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zakończyć scalanie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jeśli commit scalania nie został utworzony automatycznie, należy go wykonać ręcznie."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Graficzne narzędzia do scalania (VS Code, IntelliJ, Meld) znacznie ułatwiają pracę."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 61,
    "translations": {
      "uk": {
        "question": "61. Як налаштувати ім’я користувача та email у Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Для глобальних налаштувань (усі репозиторії):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global user.name \"Ваше Ім’я\"\ngit config --global user.email \"ваш@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Для конкретного репозиторію (тільки в поточному):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config user.name \"Ваше Ім’я\"\ngit config user.email \"ваш@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Перевірка налаштувань:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --list"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Email використовується для зв’язку комітів із профілем GitHub/GitLab."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "61. How do you configure user name and email in Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Global configuration (for all repositories):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global user.name \"Your Name\"\ngit config --global user.email \"your@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Repository-specific configuration (current repo only):"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config user.name \"Your Name\"\ngit config user.email \"your@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Check configuration:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --list"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The email is used to associate commits with your GitHub or GitLab account."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "61. Jak skonfigurować nazwę użytkownika i email w Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Konfiguracja globalna (dla wszystkich repozytoriów):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global user.name \"Twoje Imię\"\ngit config --global user.email \"twoj@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Konfiguracja tylko dla bieżącego repozytorium:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config user.name \"Twoje Imię\"\ngit config user.email \"twoj@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Sprawdzenie ustawień:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --list"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Adres email służy do powiązania commitów z kontem GitHub lub GitLab."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 62,
    "translations": {
      "uk": {
        "question": "62. Які рівні конфігурації Git існують і яка їхня область дії?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git має три рівні конфігурації:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "System", "bold": true },
                  {
                    "text": " (/etc/gitconfig) — застосовується для всіх користувачів і всіх репозиторіїв на машині."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --system ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Global", "bold": true },
                  {
                    "text": " (~/.gitconfig або ~/.config/git/config) — застосовується для поточного користувача у всіх його репозиторіях."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Local", "bold": true },
                  {
                    "text": " (.git/config у репозиторії) — застосовується лише для конкретного репозиторію та має найвищий пріоритет."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config ..."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Пріоритет застосування:" }]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "local > global > system" }]
          }
        ]
      },

      "en": {
        "question": "62. What Git configuration levels exist and what is their scope?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git has three configuration levels:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "System", "bold": true },
                  {
                    "text": " (/etc/gitconfig) — applies to all users and all repositories on the machine."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --system ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Global", "bold": true },
                  {
                    "text": " (~/.gitconfig or ~/.config/git/config) — applies to the current user across all repositories."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Local", "bold": true },
                  {
                    "text": " (.git/config in a repository) — applies only to that repository and has the highest priority."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config ..."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Priority order:" }]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "local > global > system" }]
          }
        ]
      },

      "pl": {
        "question": "62. Jakie poziomy konfiguracji Git istnieją i jaki jest ich zakres?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git posiada trzy poziomy konfiguracji:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "System", "bold": true },
                  {
                    "text": " (/etc/gitconfig) — obowiązuje wszystkich użytkowników i wszystkie repozytoria na danej maszynie."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --system ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Global", "bold": true },
                  {
                    "text": " (~/.gitconfig lub ~/.config/git/config) — dotyczy bieżącego użytkownika we wszystkich jego repozytoriach."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Local", "bold": true },
                  {
                    "text": " (.git/config w repozytorium) — dotyczy tylko jednego repozytorium i ma najwyższy priorytet."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config ..."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kolejność priorytetów:" }]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "local > global > system" }]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 63,
    "translations": {
      "uk": {
        "question": "63. Як у Git створити alias (псевдонім) для команди?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Псевдоніми в Git дозволяють створювати короткі імена для часто використовуваних команд. Вони налаштовуються через "
              },
              { "text": "git config", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Приклади (глобально, для всіх репозиторіїв):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.cm \"commit -m\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Для конкретного репозиторію:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config alias.lg \"log --oneline --graph --all --decorate\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використання:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git st\ngit co main\ngit lg"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Псевдоніми зберігаються у файлах " },
              { "text": "~/.gitconfig", "code": true },
              { "text": " або " },
              { "text": ".git/config", "code": true },
              { "text": "." }
            ]
          }
        ]
      },

      "en": {
        "question": "63. How can you create an alias for a Git command?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git aliases allow you to create short names for frequently used commands. They are configured using "
              },
              { "text": "git config", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples (global, for all repositories):" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.cm \"commit -m\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "For a specific repository:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config alias.lg \"log --oneline --graph --all --decorate\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usage:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git st\ngit co main\ngit lg"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Aliases are stored in " },
              { "text": "~/.gitconfig", "code": true },
              { "text": " or " },
              { "text": ".git/config", "code": true },
              { "text": "." }
            ]
          }
        ]
      },

      "pl": {
        "question": "63. Jak utworzyć alias (skrót) dla polecenia w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Aliasy w Git pozwalają tworzyć krótkie nazwy dla często używanych poleceń. Konfiguruje się je za pomocą "
              },
              { "text": "git config", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Przykłady (globalnie, dla wszystkich repozytoriów):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.cm \"commit -m\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dla konkretnego repozytorium:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config alias.lg \"log --oneline --graph --all --decorate\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Użycie:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git st\ngit co main\ngit lg"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Aliasy są zapisywane w plikach " },
              { "text": "~/.gitconfig", "code": true },
              { "text": " lub " },
              { "text": ".git/config", "code": true },
              { "text": "." }
            ]
          }
        ]
      }
    }
  }
]
