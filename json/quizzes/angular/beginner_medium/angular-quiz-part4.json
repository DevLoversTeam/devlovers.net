{
  "questions": [
    {
      "id": "angular-q31",
      "order": 31,
      "difficulty": "medium",
      "uk": {
        "q": "Яке значення ViewEncapsulation використовується за замовчуванням?",
        "exp": "За замовчуванням використовується ViewEncapsulation.Emulated — Angular імітує Shadow DOM, додаючи унікальні атрибути до елементів для ізоляції стилів."
      },
      "en": {
        "q": "Which ViewEncapsulation value is used by default?",
        "exp": "By default, ViewEncapsulation.Emulated is used — Angular emulates Shadow DOM by adding unique attributes to elements for style isolation."
      },
      "pl": {
        "q": "Która wartość ViewEncapsulation jest używana domyślnie?",
        "exp": "Domyślnie używane jest ViewEncapsulation.Emulated — Angular emuluje Shadow DOM, dodając unikalne atrybuty do elementów dla izolacji stylów."
      },
      "answers": [
        {
          "uk": "ViewEncapsulation.None",
          "en": "ViewEncapsulation.None",
          "pl": "ViewEncapsulation.None",
          "correct": false
        },
        {
          "uk": "ViewEncapsulation.ShadowDom",
          "en": "ViewEncapsulation.ShadowDom",
          "pl": "ViewEncapsulation.ShadowDom",
          "correct": false
        },
        {
          "uk": "ViewEncapsulation.Emulated",
          "en": "ViewEncapsulation.Emulated",
          "pl": "ViewEncapsulation.Emulated",
          "correct": true
        },
        {
          "uk": "ViewEncapsulation.Global",
          "en": "ViewEncapsulation.Global",
          "pl": "ViewEncapsulation.Global",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q32",
      "order": 32,
      "difficulty": "medium",
      "uk": {
        "q": "Для чого використовується BehaviorSubject у сервісах Angular?",
        "exp": "BehaviorSubject зберігає останнє значення і автоматично надає його новим підписникам. Ідеально підходить для поточного стану (авторизація, вибраний користувач)."
      },
      "en": {
        "q": "What is BehaviorSubject used for in Angular services?",
        "exp": "BehaviorSubject stores the latest value and automatically provides it to new subscribers. Ideal for current state (auth, selected user)."
      },
      "pl": {
        "q": "Do czego służy BehaviorSubject w serwisach Angular?",
        "exp": "BehaviorSubject przechowuje ostatnią wartość i automatycznie przekazuje ją nowym subskrybentom. Idealny do bieżącego stanu (autoryzacja, wybrany użytkownik)."
      },
      "answers": [
        {
          "uk": "Для одноразової передачі даних",
          "en": "For one-time data transmission",
          "pl": "Do jednorazowej transmisji danych",
          "correct": false
        },
        {
          "uk": "Для зберігання та передачі останнього значення новим підписникам",
          "en": "For storing and providing the latest value to new subscribers",
          "pl": "Do przechowywania i przekazywania ostatniej wartości nowym subskrybentom",
          "correct": true
        },
        {
          "uk": "Для валідації форм",
          "en": "For form validation",
          "pl": "Do walidacji formularzy",
          "correct": false
        },
        {
          "uk": "Для HTTP-запитів",
          "en": "For HTTP requests",
          "pl": "Do żądań HTTP",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q33",
      "order": 33,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке Zone.js і яку роль він відіграє в Angular?",
        "exp": "Zone.js перехоплює асинхронні операції (події, таймери, проміси) і автоматично запускає change detection. У нових версіях замінюється на Signals."
      },
      "en": {
        "q": "What is Zone.js and what role does it play in Angular?",
        "exp": "Zone.js intercepts async operations (events, timers, promises) and automatically triggers change detection. Being replaced by Signals in newer versions."
      },
      "pl": {
        "q": "Czym jest Zone.js i jaką rolę pełni w Angular?",
        "exp": "Zone.js przechwytuje operacje asynchroniczne (zdarzenia, timery, promisy) i automatycznie wyzwala change detection. W nowszych wersjach zastępowany przez Signals."
      },
      "answers": [
        {
          "uk": "Бібліотека для роботи з часовими зонами",
          "en": "A library for working with time zones",
          "pl": "Biblioteka do pracy ze strefami czasowymi",
          "correct": false
        },
        {
          "uk": "Механізм перехоплення асинхронних операцій для автозапуску change detection",
          "en": "A mechanism for intercepting async operations to auto-trigger change detection",
          "pl": "Mechanizm przechwytywania operacji asynchronicznych do automatycznego wyzwalania change detection",
          "correct": true
        },
        {
          "uk": "Інструмент для тестування",
          "en": "A testing tool",
          "pl": "Narzędzie do testowania",
          "correct": false
        },
        {
          "uk": "CSS-фреймворк",
          "en": "A CSS framework",
          "pl": "Framework CSS",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q34",
      "order": 34,
      "difficulty": "medium",
      "uk": {
        "q": "Яка різниця між AOT та JIT компіляцією?",
        "exp": "AOT компілює шаблони під час збірки (швидший старт, менший бандл). JIT компілює в браузері під час виконання (зручно для розробки)."
      },
      "en": {
        "q": "What is the difference between AOT and JIT compilation?",
        "exp": "AOT compiles templates during build (faster startup, smaller bundle). JIT compiles in browser at runtime (convenient for development)."
      },
      "pl": {
        "q": "Jaka jest różnica między kompilacją AOT i JIT?",
        "exp": "AOT kompiluje szablony podczas budowania (szybszy start, mniejszy bundle). JIT kompiluje w przeglądarce w czasie wykonania (wygodne do rozwoju)."
      },
      "answers": [
        {
          "uk": "AOT швидше компілює, JIT дає менший бандл",
          "en": "AOT compiles faster, JIT gives smaller bundle",
          "pl": "AOT kompiluje szybciej, JIT daje mniejszy bundle",
          "correct": false
        },
        {
          "uk": "AOT компілює при збірці (production), JIT — у браузері (development)",
          "en": "AOT compiles at build (production), JIT in browser (development)",
          "pl": "AOT kompiluje przy budowaniu (production), JIT — w przeglądarce (development)",
          "correct": true
        },
        {
          "uk": "JIT використовується тільки для тестування",
          "en": "JIT is only used for testing",
          "pl": "JIT jest używany tylko do testowania",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "There is no difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q35",
      "order": 35,
      "difficulty": "beginner",
      "uk": {
        "q": "Яка команда Angular CLI використовується для створення нового компонента?",
        "exp": "Команда ng generate component (або ng g c) створює новий компонент з усіма необхідними файлами: клас, шаблон, стилі, тест."
      },
      "en": {
        "q": "Which Angular CLI command is used to create a new component?",
        "exp": "The ng generate component (or ng g c) command creates a new component with all necessary files: class, template, styles, test."
      },
      "pl": {
        "q": "Która komenda Angular CLI służy do tworzenia nowego komponentu?",
        "exp": "Komenda ng generate component (lub ng g c) tworzy nowy komponent ze wszystkimi niezbędnymi plikami: klasa, szablon, style, test."
      },
      "answers": [
        {
          "uk": "ng new component",
          "en": "ng new component",
          "pl": "ng new component",
          "correct": false
        },
        {
          "uk": "ng create component",
          "en": "ng create component",
          "pl": "ng create component",
          "correct": false
        },
        {
          "uk": "ng generate component",
          "en": "ng generate component",
          "pl": "ng generate component",
          "correct": true
        },
        {
          "uk": "ng add component",
          "en": "ng add component",
          "pl": "ng add component",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q36",
      "order": 36,
      "difficulty": "medium",
      "uk": {
        "q": "Для чого використовується Renderer2 замість прямого доступу до DOM?",
        "exp": "Renderer2 — безпечна абстракція над DOM. Він захищає від XSS, працює з SSR і є кросплатформенним, на відміну від прямого nativeElement."
      },
      "en": {
        "q": "Why use Renderer2 instead of direct DOM access?",
        "exp": "Renderer2 is a safe DOM abstraction. It protects against XSS, works with SSR, and is cross-platform, unlike direct nativeElement access."
      },
      "pl": {
        "q": "Dlaczego używać Renderer2 zamiast bezpośredniego dostępu do DOM?",
        "exp": "Renderer2 to bezpieczna abstrakcja nad DOM. Chroni przed XSS, działa z SSR i jest wieloplatformowy, w przeciwieństwie do bezpośredniego nativeElement."
      },
      "answers": [
        {
          "uk": "Renderer2 швидший",
          "en": "Renderer2 is faster",
          "pl": "Renderer2 jest szybszy",
          "correct": false
        },
        {
          "uk": "Для безпеки (XSS), SSR-сумісності та кросплатформенності",
          "en": "For security (XSS), SSR compatibility, and cross-platform support",
          "pl": "Dla bezpieczeństwa (XSS), kompatybilności z SSR i wieloplatformowości",
          "correct": true
        },
        {
          "uk": "Renderer2 простіший у використанні",
          "en": "Renderer2 is easier to use",
          "pl": "Renderer2 jest łatwiejszy w użyciu",
          "correct": false
        },
        {
          "uk": "Прямий доступ до DOM заборонений в Angular",
          "en": "Direct DOM access is forbidden in Angular",
          "pl": "Bezpośredni dostęp do DOM jest zabroniony w Angular",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q37",
      "order": 37,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке NgRx і коли його варто використовувати?",
        "exp": "NgRx — бібліотека для управління станом на основі Redux та RxJS. Підходить для великих застосунків зі складним shared-state та багатьма асинхронними операціями."
      },
      "en": {
        "q": "What is NgRx and when should it be used?",
        "exp": "NgRx is a state management library based on Redux and RxJS. Suitable for large applications with complex shared state and many async operations."
      },
      "pl": {
        "q": "Czym jest NgRx i kiedy należy go używać?",
        "exp": "NgRx to biblioteka do zarządzania stanem oparta na Redux i RxJS. Nadaje się do dużych aplikacji ze złożonym współdzielonym stanem i wieloma operacjami asynchronicznymi."
      },
      "answers": [
        {
          "uk": "CSS-фреймворк для Angular",
          "en": "A CSS framework for Angular",
          "pl": "Framework CSS dla Angular",
          "correct": false
        },
        {
          "uk": "Бібліотека для управління станом у великих застосунках",
          "en": "A state management library for large applications",
          "pl": "Biblioteka do zarządzania stanem w dużych aplikacjach",
          "correct": true
        },
        {
          "uk": "Інструмент для тестування",
          "en": "A testing tool",
          "pl": "Narzędzie do testowania",
          "correct": false
        },
        {
          "uk": "Система маршрутизації",
          "en": "A routing system",
          "pl": "System routingu",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q38",
      "order": 38,
      "difficulty": "medium",
      "uk": {
        "q": "Як trackBy оптимізує роботу @for (ngFor)?",
        "exp": "trackBy дозволяє Angular ідентифікувати елементи за унікальним ключем, запобігаючи повному перерендеру списку при змінах — оновлюються тільки змінені елементи."
      },
      "en": {
        "q": "How does trackBy optimize @for (ngFor) performance?",
        "exp": "trackBy allows Angular to identify elements by unique key, preventing full list re-render on changes — only changed elements are updated."
      },
      "pl": {
        "q": "Jak trackBy optymalizuje działanie @for (ngFor)?",
        "exp": "trackBy pozwala Angular identyfikować elementy przez unikalny klucz, zapobiegając pełnemu re-renderowi listy przy zmianach — aktualizowane są tylko zmienione elementy."
      },
      "answers": [
        {
          "uk": "Сортує елементи автоматично",
          "en": "Sorts elements automatically",
          "pl": "Sortuje elementy automatycznie",
          "correct": false
        },
        {
          "uk": "Кешує дані списку",
          "en": "Caches list data",
          "pl": "Cache'uje dane listy",
          "correct": false
        },
        {
          "uk": "Ідентифікує елементи за ключем для точкового оновлення",
          "en": "Identifies elements by key for targeted updates",
          "pl": "Identyfikuje elementy po kluczu dla punktowych aktualizacji",
          "correct": true
        },
        {
          "uk": "Завантажує елементи асинхронно",
          "en": "Loads elements asynchronously",
          "pl": "Ładuje elementy asynchronicznie",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q39",
      "order": 39,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке @HostBinding та @HostListener?",
        "exp": "@HostBinding прив'язує властивість до host-елемента (наприклад, клас). @HostListener підписується на події host-елемента. Використовуються в директивах."
      },
      "en": {
        "q": "What are @HostBinding and @HostListener?",
        "exp": "@HostBinding binds a property to the host element (e.g., class). @HostListener subscribes to host element events. Used in directives."
      },
      "pl": {
        "q": "Czym są @HostBinding i @HostListener?",
        "exp": "@HostBinding wiąże właściwość z elementem host (np. klasę). @HostListener subskrybuje zdarzenia elementu host. Używane w dyrektywach."
      },
      "answers": [
        {
          "uk": "Декоратори для HTTP-запитів",
          "en": "Decorators for HTTP requests",
          "pl": "Dekoratory do żądań HTTP",
          "correct": false
        },
        {
          "uk": "Декоратори для прив'язки властивостей та подій до host-елемента",
          "en": "Decorators for binding properties and events to host element",
          "pl": "Dekoratory do wiązania właściwości i zdarzeń z elementem host",
          "correct": true
        },
        {
          "uk": "Декоратори для роботи з формами",
          "en": "Decorators for working with forms",
          "pl": "Dekoratory do pracy z formularzami",
          "correct": false
        },
        {
          "uk": "Декоратори для маршрутизації",
          "en": "Decorators for routing",
          "pl": "Dekoratory do routingu",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-q40",
      "order": 40,
      "difficulty": "medium",
      "uk": {
        "q": "Як увімкнути SSR в Angular за допомогою Angular Universal?",
        "exp": "SSR вмикається командою ng add @angular/ssr, яка автоматично налаштовує сервер, bootstrap і hydration для серверного рендерингу."
      },
      "en": {
        "q": "How do you enable SSR in Angular using Angular Universal?",
        "exp": "SSR is enabled with ng add @angular/ssr command, which automatically configures server, bootstrap, and hydration for server-side rendering."
      },
      "pl": {
        "q": "Jak włączyć SSR w Angular używając Angular Universal?",
        "exp": "SSR włącza się komendą ng add @angular/ssr, która automatycznie konfiguruje serwer, bootstrap i hydration do renderowania po stronie serwera."
      },
      "answers": [
        {
          "uk": "ng add @angular/http",
          "en": "ng add @angular/http",
          "pl": "ng add @angular/http",
          "correct": false
        },
        {
          "uk": "ng add @angular/ssr",
          "en": "ng add @angular/ssr",
          "pl": "ng add @angular/ssr",
          "correct": true
        },
        {
          "uk": "ng generate ssr",
          "en": "ng generate ssr",
          "pl": "ng generate ssr",
          "correct": false
        },
        {
          "uk": "SSR налаштовується тільки вручну",
          "en": "SSR is only configured manually",
          "pl": "SSR konfiguruje się tylko ręcznie",
          "correct": false
        }
      ]
    }
  ]
}
