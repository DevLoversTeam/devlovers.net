{
  "questions": [
    {
      "id": "angular-adv-q31",
      "order": 31,
      "difficulty": "advanced",
      "uk": {
        "q": "Що таке Hydration у контексті Angular SSR?",
        "exp": "Hydration — процес, коли Angular \"підхоплює\" серверний HTML і робить його інтерактивним без повного перерендеру. provideClientHydration() активує цю функцію."
      },
      "en": {
        "q": "What is Hydration in the context of Angular SSR?",
        "exp": "Hydration is the process where Angular 'picks up' server-rendered HTML and makes it interactive without full re-render. provideClientHydration() enables this."
      },
      "pl": {
        "q": "Czym jest Hydration w kontekście Angular SSR?",
        "exp": "Hydration to proces, gdzie Angular 'podchwytuje' HTML wyrenderowany na serwerze i czyni go interaktywnym bez pełnego re-renderu. provideClientHydration() włącza tę funkcję."
      },
      "answers": [
        {
          "uk": "Процес завантаження CSS",
          "en": "CSS loading process",
          "pl": "Proces ładowania CSS",
          "correct": false
        },
        {
          "uk": "Підхоплення серверного HTML без повного перерендеру",
          "en": "Picking up server HTML without full re-render",
          "pl": "Podchwytywanie serwerowego HTML bez pełnego re-renderu",
          "correct": true
        },
        {
          "uk": "Кешування даних",
          "en": "Data caching",
          "pl": "Cache'owanie danych",
          "correct": false
        },
        {
          "uk": "Стиснення зображень",
          "en": "Image compression",
          "pl": "Kompresja obrazów",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q32",
      "order": 32,
      "difficulty": "advanced",
      "uk": {
        "q": "Для чого використовується TransferState у SSR?",
        "exp": "TransferState передає дані з сервера в браузер, уникаючи повторних API-запитів. Сервер зберігає дані в state, браузер їх читає при hydration."
      },
      "en": {
        "q": "What is TransferState used for in SSR?",
        "exp": "TransferState passes data from server to browser, avoiding duplicate API calls. Server stores data in state, browser reads it during hydration."
      },
      "pl": {
        "q": "Do czego służy TransferState w SSR?",
        "exp": "TransferState przekazuje dane z serwera do przeglądarki, unikając duplikacji żądań API. Serwer zapisuje dane w state, przeglądarka czyta je podczas hydration."
      },
      "answers": [
        {
          "uk": "Для анімації переходів між сторінками",
          "en": "For page transition animations",
          "pl": "Do animacji przejść między stronami",
          "correct": false
        },
        {
          "uk": "Для передачі даних з сервера в браузер без повторних API-запитів",
          "en": "For passing data from server to browser without duplicate API calls",
          "pl": "Do przekazywania danych z serwera do przeglądarki bez duplikacji żądań API",
          "correct": true
        },
        {
          "uk": "Для стилізації компонентів",
          "en": "For component styling",
          "pl": "Do stylizacji komponentów",
          "correct": false
        },
        {
          "uk": "Для валідації форм",
          "en": "For form validation",
          "pl": "Do walidacji formularzy",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q33",
      "order": 33,
      "difficulty": "medium",
      "uk": {
        "q": "Як перевірити, чи код виконується в браузері чи на сервері при SSR?",
        "exp": "Використовується функція isPlatformBrowser(platformId) або isPlatformServer(platformId). PLATFORM_ID інжектується через DI."
      },
      "en": {
        "q": "How do you check if code runs in browser or server during SSR?",
        "exp": "Use isPlatformBrowser(platformId) or isPlatformServer(platformId) functions. PLATFORM_ID is injected via DI."
      },
      "pl": {
        "q": "Jak sprawdzić czy kod działa w przeglądarce czy na serwerze przy SSR?",
        "exp": "Używa się funkcji isPlatformBrowser(platformId) lub isPlatformServer(platformId). PLATFORM_ID jest wstrzykiwany przez DI."
      },
      "answers": [
        {
          "uk": "Через window !== undefined",
          "en": "Via window !== undefined",
          "pl": "Przez window !== undefined",
          "correct": false
        },
        {
          "uk": "Через isPlatformBrowser(platformId) або isPlatformServer(platformId)",
          "en": "Via isPlatformBrowser(platformId) or isPlatformServer(platformId)",
          "pl": "Przez isPlatformBrowser(platformId) lub isPlatformServer(platformId)",
          "correct": true
        },
        {
          "uk": "Angular робить це автоматично",
          "en": "Angular does this automatically",
          "pl": "Angular robi to automatycznie",
          "correct": false
        },
        {
          "uk": "Неможливо перевірити",
          "en": "Not possible to check",
          "pl": "Niemożliwe do sprawdzenia",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q34",
      "order": 34,
      "difficulty": "medium",
      "uk": {
        "q": "Чому не можна напряму використовувати window або document при SSR?",
        "exp": "На сервері немає браузерних API (window, document, localStorage). Прямий доступ викличе помилку. Потрібно перевіряти платформу або використовувати Renderer2."
      },
      "en": {
        "q": "Why can't you directly use window or document in SSR?",
        "exp": "Server doesn't have browser APIs (window, document, localStorage). Direct access causes errors. Check platform or use Renderer2."
      },
      "pl": {
        "q": "Dlaczego nie można bezpośrednio używać window lub document w SSR?",
        "exp": "Serwer nie ma API przeglądarki (window, document, localStorage). Bezpośredni dostęp powoduje błędy. Sprawdzaj platformę lub używaj Renderer2."
      },
      "answers": [
        {
          "uk": "Вони працюють повільно",
          "en": "They work slowly",
          "pl": "Działają wolno",
          "correct": false
        },
        {
          "uk": "На сервері немає браузерних API — буде помилка",
          "en": "Server doesn't have browser APIs — will cause error",
          "pl": "Serwer nie ma API przeglądarki — będzie błąd",
          "correct": true
        },
        {
          "uk": "Angular забороняє їх використання",
          "en": "Angular forbids their use",
          "pl": "Angular zabrania ich użycia",
          "correct": false
        },
        {
          "uk": "Вони застарілі",
          "en": "They are deprecated",
          "pl": "Są przestarzałe",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q35",
      "order": 35,
      "difficulty": "medium",
      "uk": {
        "q": "Яка різниця між route parameters та query parameters?",
        "exp": "Route parameters (/user/:id) — частина шляху, обов'язкові. Query parameters (?sort=asc) — опціональні, передаються після ?. Доступ через paramMap та queryParamMap."
      },
      "en": {
        "q": "What is the difference between route parameters and query parameters?",
        "exp": "Route parameters (/user/:id) are path parts, required. Query parameters (?sort=asc) are optional, after ?. Access via paramMap and queryParamMap."
      },
      "pl": {
        "q": "Jaka jest różnica między route parameters a query parameters?",
        "exp": "Route parameters (/user/:id) to części ścieżki, wymagane. Query parameters (?sort=asc) są opcjonalne, po ?. Dostęp przez paramMap i queryParamMap."
      },
      "answers": [
        {
          "uk": "Різниці немає",
          "en": "No difference",
          "pl": "Nie ma różnicy",
          "correct": false
        },
        {
          "uk": "Route params — частина шляху, query params — опціональні після ?",
          "en": "Route params are path parts, query params are optional after ?",
          "pl": "Route params to części ścieżki, query params są opcjonalne po ?",
          "correct": true
        },
        {
          "uk": "Query parameters швидші",
          "en": "Query parameters are faster",
          "pl": "Query parameters są szybsze",
          "correct": false
        },
        {
          "uk": "Route parameters працюють тільки з SSR",
          "en": "Route parameters only work with SSR",
          "pl": "Route parameters działają tylko z SSR",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q36",
      "order": 36,
      "difficulty": "medium",
      "uk": {
        "q": "Як отримати query parameters з URL в Angular?",
        "exp": "Через ActivatedRoute.queryParamMap (Observable) або snapshot.queryParamMap. Метод get('paramName') повертає значення параметра."
      },
      "en": {
        "q": "How do you get query parameters from URL in Angular?",
        "exp": "Via ActivatedRoute.queryParamMap (Observable) or snapshot.queryParamMap. The get('paramName') method returns the parameter value."
      },
      "pl": {
        "q": "Jak pobrać query parameters z URL w Angular?",
        "exp": "Przez ActivatedRoute.queryParamMap (Observable) lub snapshot.queryParamMap. Metoda get('paramName') zwraca wartość parametru."
      },
      "answers": [
        {
          "uk": "Через window.location.search",
          "en": "Via window.location.search",
          "pl": "Przez window.location.search",
          "correct": false
        },
        {
          "uk": "Через ActivatedRoute.queryParamMap",
          "en": "Via ActivatedRoute.queryParamMap",
          "pl": "Przez ActivatedRoute.queryParamMap",
          "correct": true
        },
        {
          "uk": "Через Router.params",
          "en": "Via Router.params",
          "pl": "Przez Router.params",
          "correct": false
        },
        {
          "uk": "Query parameters недоступні в Angular",
          "en": "Query parameters are not available in Angular",
          "pl": "Query parameters nie są dostępne w Angular",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q37",
      "order": 37,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке Preloading Strategy і для чого вона потрібна?",
        "exp": "Preloading Strategy визначає, які lazy-loaded модулі завантажити заздалегідь. PreloadAllModules завантажує всі після старту, можна створити custom strategy."
      },
      "en": {
        "q": "What is Preloading Strategy and what is it for?",
        "exp": "Preloading Strategy determines which lazy-loaded modules to load in advance. PreloadAllModules loads all after startup, can create custom strategy."
      },
      "pl": {
        "q": "Czym jest Preloading Strategy i do czego służy?",
        "exp": "Preloading Strategy określa, które lazy-loaded moduły załadować z wyprzedzeniem. PreloadAllModules ładuje wszystkie po starcie, można stworzyć custom strategy."
      },
      "answers": [
        {
          "uk": "Стратегія кешування даних",
          "en": "Data caching strategy",
          "pl": "Strategia cache'owania danych",
          "correct": false
        },
        {
          "uk": "Визначає, які lazy-модулі завантажити заздалегідь",
          "en": "Determines which lazy modules to preload",
          "pl": "Określa które lazy moduły załadować z wyprzedzeniem",
          "correct": true
        },
        {
          "uk": "Стратегія валідації форм",
          "en": "Form validation strategy",
          "pl": "Strategia walidacji formularzy",
          "correct": false
        },
        {
          "uk": "Метод стилізації компонентів",
          "en": "Component styling method",
          "pl": "Metoda stylizacji komponentów",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q38",
      "order": 38,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке inject() функція і чим вона краща за constructor injection?",
        "exp": "inject() — функціональний спосіб DI без constructor. Працює в функціях, guards, resolvers. Чистіший код, менше boilerplate, краща типізація."
      },
      "en": {
        "q": "What is the inject() function and how is it better than constructor injection?",
        "exp": "inject() is a functional DI approach without constructor. Works in functions, guards, resolvers. Cleaner code, less boilerplate, better typing."
      },
      "pl": {
        "q": "Czym jest funkcja inject() i czym jest lepsza od constructor injection?",
        "exp": "inject() to funkcjonalne podejście do DI bez konstruktora. Działa w funkcjach, guards, resolvers. Czystszy kod, mniej boilerplate, lepsza typizacja."
      },
      "answers": [
        {
          "uk": "inject() швидша за constructor",
          "en": "inject() is faster than constructor",
          "pl": "inject() jest szybsze niż konstruktor",
          "correct": false
        },
        {
          "uk": "Функціональний DI без constructor, працює в guards/resolvers",
          "en": "Functional DI without constructor, works in guards/resolvers",
          "pl": "Funkcjonalne DI bez konstruktora, działa w guards/resolvers",
          "correct": true
        },
        {
          "uk": "inject() працює тільки з HTTP",
          "en": "inject() only works with HTTP",
          "pl": "inject() działa tylko z HTTP",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "No difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q39",
      "order": 39,
      "difficulty": "advanced",
      "uk": {
        "q": "Коли використовувати effect() з Signals?",
        "exp": "effect() виконує side-effects при зміні сигналів (логування, DOM-операції, синхронізація). Автоматично відстежує залежності та реагує на зміни."
      },
      "en": {
        "q": "When should you use effect() with Signals?",
        "exp": "effect() performs side effects when signals change (logging, DOM operations, sync). Automatically tracks dependencies and reacts to changes."
      },
      "pl": {
        "q": "Kiedy używać effect() z Signals?",
        "exp": "effect() wykonuje efekty uboczne przy zmianie sygnałów (logowanie, operacje DOM, synchronizacja). Automatycznie śledzi zależności i reaguje na zmiany."
      },
      "answers": [
        {
          "uk": "Для HTTP-запитів",
          "en": "For HTTP requests",
          "pl": "Do żądań HTTP",
          "correct": false
        },
        {
          "uk": "Для виконання side-effects при зміні сигналів",
          "en": "For executing side effects when signals change",
          "pl": "Do wykonywania efektów ubocznych przy zmianie sygnałów",
          "correct": true
        },
        {
          "uk": "Для валідації форм",
          "en": "For form validation",
          "pl": "Do walidacji formularzy",
          "correct": false
        },
        {
          "uk": "effect() застарілий",
          "en": "effect() is deprecated",
          "pl": "effect() jest przestarzały",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q40",
      "order": 40,
      "difficulty": "advanced",
      "uk": {
        "q": "Що таке computed() у Signals і чим він відрізняється від звичайного signal()?",
        "exp": "computed() створює похідний сигнал, що автоматично перераховується при зміні залежностей. На відміну від signal(), не можна встановити значення напряму — воно завжди обчислюється."
      },
      "en": {
        "q": "What is computed() in Signals and how does it differ from signal()?",
        "exp": "computed() creates a derived signal that auto-recalculates when dependencies change. Unlike signal(), you can't set value directly — it's always calculated."
      },
      "pl": {
        "q": "Czym jest computed() w Signals i czym różni się od signal()?",
        "exp": "computed() tworzy pochodny sygnał, który automatycznie przelicza się przy zmianie zależności. W przeciwieństwie do signal(), nie można ustawić wartości bezpośrednio — jest zawsze obliczana."
      },
      "answers": [
        {
          "uk": "computed() швидший за signal()",
          "en": "computed() is faster than signal()",
          "pl": "computed() jest szybszy niż signal()",
          "correct": false
        },
        {
          "uk": "computed() — похідний сигнал, що автоматично перераховується",
          "en": "computed() is a derived signal that auto-recalculates",
          "pl": "computed() to pochodny sygnał, który automatycznie się przelicza",
          "correct": true
        },
        {
          "uk": "computed() працює тільки з HTTP",
          "en": "computed() only works with HTTP",
          "pl": "computed() działa tylko z HTTP",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "No difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    }
  ]
}
