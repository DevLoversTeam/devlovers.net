{
  "questions": [
    {
      "id": "angular-adv-q11",
      "order": 11,
      "difficulty": "advanced",
      "uk": {
        "q": "Для чого використовується декоратор @Optional() у DI?",
        "exp": "@Optional() позначає залежність як необов'язкову. Якщо Angular не знайде провайдера, він поверне null замість викидання помилки."
      },
      "en": {
        "q": "What is the @Optional() decorator used for in DI?",
        "exp": "@Optional() marks a dependency as optional. If Angular can't find a provider, it returns null instead of throwing an error."
      },
      "pl": {
        "q": "Do czego służy dekorator @Optional() w DI?",
        "exp": "@Optional() oznacza zależność jako opcjonalną. Jeśli Angular nie znajdzie providera, zwróci null zamiast rzucać błąd."
      },
      "answers": [
        {
          "uk": "Для створення singleton-сервісу",
          "en": "For creating a singleton service",
          "pl": "Do tworzenia serwisu singleton",
          "correct": false
        },
        {
          "uk": "Для позначення залежності як необов'язкової (null якщо не знайдено)",
          "en": "For marking a dependency as optional (null if not found)",
          "pl": "Do oznaczenia zależności jako opcjonalnej (null jeśli nie znaleziono)",
          "correct": true
        },
        {
          "uk": "Для lazy loading сервісу",
          "en": "For lazy loading a service",
          "pl": "Do lazy loading serwisu",
          "correct": false
        },
        {
          "uk": "Для кешування залежності",
          "en": "For caching a dependency",
          "pl": "Do cache'owania zależności",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q12",
      "order": 12,
      "difficulty": "advanced",
      "uk": {
        "q": "Яка різниця між @Self() та @SkipSelf() у DI?",
        "exp": "@Self() шукає залежність тільки в локальному інжекторі компонента. @SkipSelf() пропускає локальний інжектор і шукає в батьківських."
      },
      "en": {
        "q": "What is the difference between @Self() and @SkipSelf() in DI?",
        "exp": "@Self() looks for dependency only in the component's local injector. @SkipSelf() skips the local injector and looks in parent injectors."
      },
      "pl": {
        "q": "Jaka jest różnica między @Self() a @SkipSelf() w DI?",
        "exp": "@Self() szuka zależności tylko w lokalnym injektorze komponentu. @SkipSelf() pomija lokalny injektor i szuka w injektorach nadrzędnych."
      },
      "answers": [
        {
          "uk": "@Self() — для сервісів, @SkipSelf() — для компонентів",
          "en": "@Self() for services, @SkipSelf() for components",
          "pl": "@Self() dla serwisów, @SkipSelf() dla komponentów",
          "correct": false
        },
        {
          "uk": "@Self() шукає локально, @SkipSelf() пропускає локальний і шукає в батьківських",
          "en": "@Self() looks locally, @SkipSelf() skips local and looks in parents",
          "pl": "@Self() szuka lokalnie, @SkipSelf() pomija lokalny i szuka w nadrzędnych",
          "correct": true
        },
        {
          "uk": "@SkipSelf() швидший за @Self()",
          "en": "@SkipSelf() is faster than @Self()",
          "pl": "@SkipSelf() jest szybszy niż @Self()",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "No difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q13",
      "order": 13,
      "difficulty": "medium",
      "uk": {
        "q": "Для чого використовується декоратор @Inject()?",
        "exp": "@Inject() дозволяє явно вказати токен для інжекції, особливо корисний для інжекції примітивних значень або InjectionToken."
      },
      "en": {
        "q": "What is the @Inject() decorator used for?",
        "exp": "@Inject() allows explicitly specifying the injection token, especially useful for injecting primitive values or InjectionToken."
      },
      "pl": {
        "q": "Do czego służy dekorator @Inject()?",
        "exp": "@Inject() pozwala jawnie określić token do iniekcji, szczególnie przydatny do wstrzykiwania wartości prymitywnych lub InjectionToken."
      },
      "answers": [
        {
          "uk": "Для створення нового сервісу",
          "en": "For creating a new service",
          "pl": "Do tworzenia nowego serwisu",
          "correct": false
        },
        {
          "uk": "Для явного вказання токена інжекції (примітиви, InjectionToken)",
          "en": "For explicitly specifying injection token (primitives, InjectionToken)",
          "pl": "Do jawnego określenia tokena iniekcji (prymitywy, InjectionToken)",
          "correct": true
        },
        {
          "uk": "Для валідації залежностей",
          "en": "For validating dependencies",
          "pl": "Do walidacji zależności",
          "correct": false
        },
        {
          "uk": "Для логування інжекцій",
          "en": "For logging injections",
          "pl": "Do logowania iniekcji",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q14",
      "order": 14,
      "difficulty": "medium",
      "uk": {
        "q": "Яка різниця між Subject та BehaviorSubject?",
        "exp": "Subject не має початкового значення і не передає останнє значення новим підписникам. BehaviorSubject зберігає останнє значення і одразу передає його новим підписникам."
      },
      "en": {
        "q": "What is the difference between Subject and BehaviorSubject?",
        "exp": "Subject has no initial value and doesn't pass the last value to new subscribers. BehaviorSubject stores the last value and immediately passes it to new subscribers."
      },
      "pl": {
        "q": "Jaka jest różnica między Subject a BehaviorSubject?",
        "exp": "Subject nie ma wartości początkowej i nie przekazuje ostatniej wartości nowym subskrybentom. BehaviorSubject przechowuje ostatnią wartość i natychmiast przekazuje ją nowym subskrybentom."
      },
      "answers": [
        {
          "uk": "Subject швидший за BehaviorSubject",
          "en": "Subject is faster than BehaviorSubject",
          "pl": "Subject jest szybszy niż BehaviorSubject",
          "correct": false
        },
        {
          "uk": "BehaviorSubject зберігає та передає останнє значення новим підписникам",
          "en": "BehaviorSubject stores and passes the last value to new subscribers",
          "pl": "BehaviorSubject przechowuje i przekazuje ostatnią wartość nowym subskrybentom",
          "correct": true
        },
        {
          "uk": "Subject працює тільки з HTTP",
          "en": "Subject only works with HTTP",
          "pl": "Subject działa tylko z HTTP",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "No difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q15",
      "order": 15,
      "difficulty": "advanced",
      "uk": {
        "q": "Коли варто використовувати ReplaySubject замість BehaviorSubject?",
        "exp": "ReplaySubject передає новим підписникам N останніх значень (конфігурується). Корисний для історії подій або кешування кількох значень."
      },
      "en": {
        "q": "When should you use ReplaySubject instead of BehaviorSubject?",
        "exp": "ReplaySubject passes N last values to new subscribers (configurable). Useful for event history or caching multiple values."
      },
      "pl": {
        "q": "Kiedy używać ReplaySubject zamiast BehaviorSubject?",
        "exp": "ReplaySubject przekazuje N ostatnich wartości nowym subskrybentom (konfigurowalne). Przydatny dla historii zdarzeń lub cache'owania wielu wartości."
      },
      "answers": [
        {
          "uk": "Коли потрібно передати тільки перше значення",
          "en": "When you need to pass only the first value",
          "pl": "Kiedy trzeba przekazać tylko pierwszą wartość",
          "correct": false
        },
        {
          "uk": "Коли потрібно передати N останніх значень новим підписникам",
          "en": "When you need to pass N last values to new subscribers",
          "pl": "Kiedy trzeba przekazać N ostatnich wartości nowym subskrybentom",
          "correct": true
        },
        {
          "uk": "Коли працюєте з формами",
          "en": "When working with forms",
          "pl": "Kiedy pracujesz z formularzami",
          "correct": false
        },
        {
          "uk": "ReplaySubject застарілий",
          "en": "ReplaySubject is deprecated",
          "pl": "ReplaySubject jest przestarzały",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q16",
      "order": 16,
      "difficulty": "advanced",
      "uk": {
        "q": "Як створити кастомну структурну директиву?",
        "exp": "Структурна директива створюється через @Directive з інжекцією TemplateRef та ViewContainerRef. ViewContainerRef керує вставкою/видаленням шаблону."
      },
      "en": {
        "q": "How do you create a custom structural directive?",
        "exp": "A structural directive is created via @Directive with TemplateRef and ViewContainerRef injection. ViewContainerRef manages template insertion/removal."
      },
      "pl": {
        "q": "Jak stworzyć niestandardową dyrektywę strukturalną?",
        "exp": "Dyrektywa strukturalna tworzona jest przez @Directive z iniekcją TemplateRef i ViewContainerRef. ViewContainerRef zarządza wstawianiem/usuwaniem szablonu."
      },
      "answers": [
        {
          "uk": "Через @Component з порожнім шаблоном",
          "en": "Via @Component with empty template",
          "pl": "Przez @Component z pustym szablonem",
          "correct": false
        },
        {
          "uk": "Через @Directive з TemplateRef та ViewContainerRef",
          "en": "Via @Directive with TemplateRef and ViewContainerRef",
          "pl": "Przez @Directive z TemplateRef i ViewContainerRef",
          "correct": true
        },
        {
          "uk": "Через спеціальний @StructuralDirective декоратор",
          "en": "Via special @StructuralDirective decorator",
          "pl": "Przez specjalny dekorator @StructuralDirective",
          "correct": false
        },
        {
          "uk": "Кастомні структурні директиви неможливі",
          "en": "Custom structural directives are not possible",
          "pl": "Niestandardowe dyrektywy strukturalne nie są możliwe",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q17",
      "order": 17,
      "difficulty": "medium",
      "uk": {
        "q": "Для чого використовується ViewContainerRef у структурних директивах?",
        "exp": "ViewContainerRef — це контейнер, який керує створенням та видаленням views. Методи createEmbeddedView() та clear() контролюють DOM."
      },
      "en": {
        "q": "What is ViewContainerRef used for in structural directives?",
        "exp": "ViewContainerRef is a container that manages view creation and removal. Methods createEmbeddedView() and clear() control the DOM."
      },
      "pl": {
        "q": "Do czego służy ViewContainerRef w dyrektywach strukturalnych?",
        "exp": "ViewContainerRef to kontener zarządzający tworzeniem i usuwaniem widoków. Metody createEmbeddedView() i clear() kontrolują DOM."
      },
      "answers": [
        {
          "uk": "Для стилізації елементів",
          "en": "For styling elements",
          "pl": "Do stylizacji elementów",
          "correct": false
        },
        {
          "uk": "Для керування створенням та видаленням views у DOM",
          "en": "For managing view creation and removal in DOM",
          "pl": "Do zarządzania tworzeniem i usuwaniem widoków w DOM",
          "correct": true
        },
        {
          "uk": "Для валідації форм",
          "en": "For form validation",
          "pl": "Do walidacji formularzy",
          "correct": false
        },
        {
          "uk": "Для HTTP-запитів",
          "en": "For HTTP requests",
          "pl": "Do żądań HTTP",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q18",
      "order": 18,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке Route Resolver і коли його використовувати?",
        "exp": "Route Resolver завантажує дані перед активацією маршруту. Angular чекає завершення resolve і передає дані в компонент через ActivatedRoute.data."
      },
      "en": {
        "q": "What is a Route Resolver and when should you use it?",
        "exp": "Route Resolver loads data before route activation. Angular waits for resolve completion and passes data to the component via ActivatedRoute.data."
      },
      "pl": {
        "q": "Czym jest Route Resolver i kiedy go używać?",
        "exp": "Route Resolver ładuje dane przed aktywacją trasy. Angular czeka na zakończenie resolve i przekazuje dane do komponentu przez ActivatedRoute.data."
      },
      "answers": [
        {
          "uk": "Для валідації URL",
          "en": "For URL validation",
          "pl": "Do walidacji URL",
          "correct": false
        },
        {
          "uk": "Для завантаження даних перед активацією маршруту",
          "en": "For loading data before route activation",
          "pl": "Do ładowania danych przed aktywacją trasy",
          "correct": true
        },
        {
          "uk": "Для кешування маршрутів",
          "en": "For caching routes",
          "pl": "Do cache'owania tras",
          "correct": false
        },
        {
          "uk": "Для анімації переходів",
          "en": "For transition animations",
          "pl": "Do animacji przejść",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q19",
      "order": 19,
      "difficulty": "medium",
      "uk": {
        "q": "Яка різниця між canActivate та canLoad guards?",
        "exp": "canActivate перевіряє доступ до маршруту (код вже завантажено). canLoad запобігає завантаженню lazy-loaded модуля взагалі."
      },
      "en": {
        "q": "What is the difference between canActivate and canLoad guards?",
        "exp": "canActivate checks route access (code already loaded). canLoad prevents lazy-loaded module from loading at all."
      },
      "pl": {
        "q": "Jaka jest różnica między canActivate a canLoad guards?",
        "exp": "canActivate sprawdza dostęp do trasy (kod już załadowany). canLoad zapobiega ładowaniu lazy-loaded modułu w ogóle."
      },
      "answers": [
        {
          "uk": "canActivate швидший",
          "en": "canActivate is faster",
          "pl": "canActivate jest szybszy",
          "correct": false
        },
        {
          "uk": "canActivate перевіряє доступ, canLoad запобігає завантаженню lazy-модуля",
          "en": "canActivate checks access, canLoad prevents lazy module loading",
          "pl": "canActivate sprawdza dostęp, canLoad zapobiega ładowaniu lazy modułu",
          "correct": true
        },
        {
          "uk": "canLoad працює тільки з SSR",
          "en": "canLoad only works with SSR",
          "pl": "canLoad działa tylko z SSR",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "No difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    },
    {
      "id": "angular-adv-q20",
      "order": 20,
      "difficulty": "medium",
      "uk": {
        "q": "Для чого використовується canDeactivate guard?",
        "exp": "canDeactivate перевіряє, чи можна покинути поточний маршрут. Типове використання — попередження про незбережені зміни у формі."
      },
      "en": {
        "q": "What is the canDeactivate guard used for?",
        "exp": "canDeactivate checks if the current route can be left. Typical use — warning about unsaved form changes."
      },
      "pl": {
        "q": "Do czego służy guard canDeactivate?",
        "exp": "canDeactivate sprawdza, czy można opuścić bieżącą trasę. Typowe użycie — ostrzeżenie o niezapisanych zmianach w formularzu."
      },
      "answers": [
        {
          "uk": "Для перевірки авторизації",
          "en": "For authorization check",
          "pl": "Do sprawdzenia autoryzacji",
          "correct": false
        },
        {
          "uk": "Для перевірки, чи можна покинути маршрут (незбережені зміни)",
          "en": "For checking if route can be left (unsaved changes)",
          "pl": "Do sprawdzenia czy można opuścić trasę (niezapisane zmiany)",
          "correct": true
        },
        {
          "uk": "Для lazy loading",
          "en": "For lazy loading",
          "pl": "Do lazy loading",
          "correct": false
        },
        {
          "uk": "Для кешування даних",
          "en": "For data caching",
          "pl": "Do cache'owania danych",
          "correct": false
        }
      ]
    }
  ]
}
