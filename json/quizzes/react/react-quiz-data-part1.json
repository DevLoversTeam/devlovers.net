{
  "quizId": "quiz-react-fundamentals",
  "topicId": "topic-react",
  "slug": "react-fundamentals",
  "questionsCount": 40,
  "timeLimitSeconds": 1800,
  "translations": {
    "uk": { "title": "Основи React", "description": "Перевірте свої знання базових концепцій React: компоненти, Virtual DOM, JSX, хуки, оптимізація та архітектурні патерни." },
    "en": { "title": "React Fundamentals", "description": "Test your knowledge of React basics: components, Virtual DOM, JSX, hooks, optimization and architectural patterns." },
    "pl": { "title": "Podstawy React", "description": "Sprawdź swoją wiedzę o podstawach React: komponenty, Virtual DOM, JSX, hooki, optymalizacja i wzorce architektoniczne." }
  },
  "questions": [
    {
      "id": "react-q01", "order": 1, "difficulty": "beginner",
      "uk": { "q": "Що найточніше описує React?", "exp": "React — це саме бібліотека, а не фреймворк. Він фокусується на одній задачі: побудова UI." },
      "en": { "q": "What best describes React?", "exp": "React is a library, not a framework. It focuses on one task: building UI." },
      "pl": { "q": "Co najlepiej opisuje React?", "exp": "React to biblioteka, a nie framework. Skupia się na jednym zadaniu: budowaniu UI." },
      "answers": [
        { "uk": "Повноцінний фреймворк для створення веб-додатків", "en": "A full-featured framework for building web applications", "pl": "Pełnoprawny framework do tworzenia aplikacji webowych", "correct": false },
        { "uk": "JavaScript-бібліотека для створення користувацьких інтерфейсів", "en": "A JavaScript library for building user interfaces", "pl": "Biblioteka JavaScript do tworzenia interfejsów użytkownika", "correct": true },
        { "uk": "Мова програмування для веб-розробки", "en": "A programming language for web development", "pl": "Język programowania do tworzenia stron internetowych", "correct": false },
        { "uk": "База даних для зберігання даних додатків", "en": "A database for storing application data", "pl": "Baza danych do przechowywania danych aplikacji", "correct": false }
      ]
    },
    {
      "id": "react-q02", "order": 2, "difficulty": "beginner",
      "uk": { "q": "Навіщо React використовує Virtual DOM?", "exp": "Virtual DOM — це легка копія реального DOM в пам'яті. React порівнює віртуальну версію з попередньою (diffing) і вносить лише мінімальні зміни." },
      "en": { "q": "Why does React use Virtual DOM?", "exp": "Virtual DOM is a lightweight copy of the real DOM in memory. React compares the virtual version with the previous one (diffing) and makes only minimal changes." },
      "pl": { "q": "Dlaczego React używa Virtual DOM?", "exp": "Virtual DOM to lekka kopia prawdziwego DOM w pamięci. React porównuje wersję wirtualną z poprzednią (diffing) i wprowadza tylko minimalne zmiany." },
      "answers": [
        { "uk": "Щоб зберігати дані користувача в браузері", "en": "To store user data in the browser", "pl": "Aby przechowywać dane użytkownika w przeglądarce", "correct": false },
        { "uk": "Для ефективного оновлення інтерфейсу без зайвих маніпуляцій з реальним DOM", "en": "For efficient UI updates without unnecessary real DOM manipulations", "pl": "Do wydajnych aktualizacji UI bez zbędnych manipulacji prawdziwym DOM", "correct": true },
        { "uk": "Для створення анімацій на сторінці", "en": "To create animations on the page", "pl": "Do tworzenia animacji na stronie", "correct": false },
        { "uk": "Щоб сторінка працювала без JavaScript", "en": "So the page works without JavaScript", "pl": "Aby strona działała bez JavaScript", "correct": false }
      ]
    },
    {
      "id": "react-q03", "order": 3, "difficulty": "beginner",
      "uk": { "q": "Як передаються дані між компонентами в React за замовчуванням?", "exp": "React використовує односпрямований (unidirectional) потік даних — дані передаються зверху вниз через props." },
      "en": { "q": "How is data passed between components in React by default?", "exp": "React uses unidirectional data flow — data is passed from top to bottom through props." },
      "pl": { "q": "Jak domyślnie przekazywane są dane między komponentami w React?", "exp": "React używa jednokierunkowego przepływu danych — dane są przekazywane z góry na dół przez props." },
      "answers": [
        { "uk": "Від дочірніх компонентів до батьківських", "en": "From child components to parent components", "pl": "Od komponentów potomnych do nadrzędnych", "correct": false },
        { "uk": "В обидва напрямки одночасно", "en": "In both directions simultaneously", "pl": "W obu kierunkach jednocześnie", "correct": false },
        { "uk": "Від батьківських компонентів до дочірніх (зверху вниз)", "en": "From parent components to child components (top to bottom)", "pl": "Od komponentów nadrzędnych do potomnych (z góry na dół)", "correct": true },
        { "uk": "Через глобальну змінну window", "en": "Through the global window variable", "pl": "Przez globalną zmienną window", "correct": false }
      ]
    },
    {
      "id": "react-q04", "order": 4, "difficulty": "beginner",
      "uk": { "q": "Що таке JSX?", "exp": "JSX виглядає як HTML всередині JavaScript, але насправді це синтаксичний цукор. Babel перетворює <h1>Hello</h1> на React.createElement()." },
      "en": { "q": "What is JSX?", "exp": "JSX looks like HTML inside JavaScript, but it's actually syntactic sugar. Babel transforms <h1>Hello</h1> into React.createElement()." },
      "pl": { "q": "Czym jest JSX?", "exp": "JSX wygląda jak HTML wewnątrz JavaScript, ale w rzeczywistości jest to cukier składniowy. Babel przekształca <h1>Hello</h1> w React.createElement()." },
      "answers": [
        { "uk": "Нова мова програмування від Facebook", "en": "A new programming language from Facebook", "pl": "Nowy język programowania od Facebooka", "correct": false },
        { "uk": "Розширення синтаксису JavaScript для опису UI у XML-подібному форматі", "en": "A JavaScript syntax extension for describing UI in an XML-like format", "pl": "Rozszerzenie składni JavaScript do opisywania UI w formacie podobnym do XML", "correct": true },
        { "uk": "Бібліотека для роботи з формами", "en": "A library for working with forms", "pl": "Biblioteka do pracy z formularzami", "correct": false },
        { "uk": "Інструмент для тестування React-компонентів", "en": "A tool for testing React components", "pl": "Narzędzie do testowania komponentów React", "correct": false }
      ]
    },
    {
      "id": "react-q05", "order": 5, "difficulty": "beginner",
      "uk": { "q": "Чому в JSX замість class пишуть className?", "exp": "В JavaScript class — ключове слово для створення класів. Оскільки JSX — це JavaScript, використання class як атрибута викликало б конфлікт." },
      "en": { "q": "Why do we use className instead of class in JSX?", "exp": "In JavaScript, class is a reserved keyword for creating classes. Since JSX is JavaScript, using class as an attribute would cause a conflict." },
      "pl": { "q": "Dlaczego w JSX zamiast class piszemy className?", "exp": "W JavaScript class to słowo kluczowe do tworzenia klas. Ponieważ JSX to JavaScript, użycie class jako atrybutu spowodowałoby konflikt." },
      "answers": [
        { "uk": "Це помилка в документації React", "en": "This is an error in React documentation", "pl": "To błąd w dokumentacji React", "correct": false },
        { "uk": "class — зарезервоване слово в JavaScript", "en": "class is a reserved word in JavaScript", "pl": "class to słowo zastrzeżone w JavaScript", "correct": true },
        { "uk": "className працює швидше", "en": "className works faster", "pl": "className działa szybciej", "correct": false },
        { "uk": "Це просто стиль коду Facebook", "en": "It's just Facebook's code style", "pl": "To po prostu styl kodu Facebooka", "correct": false }
      ]
    },
    {
      "id": "react-q06", "order": 6, "difficulty": "beginner",
      "uk": { "q": "Який тип компонентів рекомендується використовувати в сучасному React?", "exp": "Починаючи з React 16.8, функціональні компоненти отримали хуки. Вони простіші, коротші і легші для тестування." },
      "en": { "q": "Which type of components is recommended in modern React?", "exp": "Starting with React 16.8, functional components received hooks. They are simpler, shorter, and easier to test." },
      "pl": { "q": "Jaki typ komponentów jest zalecany we współczesnym React?", "exp": "Począwszy od React 16.8, komponenty funkcyjne otrzymały hooki. Są prostsze, krótsze i łatwiejsze do testowania." },
      "answers": [
        { "uk": "Тільки класові компоненти", "en": "Only class components", "pl": "Tylko komponenty klasowe", "correct": false },
        { "uk": "Функціональні компоненти з хуками", "en": "Functional components with hooks", "pl": "Komponenty funkcyjne z hookami", "correct": true },
        { "uk": "Тільки компоненти без стану", "en": "Only stateless components", "pl": "Tylko komponenty bez stanu", "correct": false },
        { "uk": "Компоненти на чистому JavaScript без React", "en": "Pure JavaScript components without React", "pl": "Komponenty w czystym JavaScript bez React", "correct": false }
      ]
    },
    {
      "id": "react-q07", "order": 7, "difficulty": "beginner",
      "uk": { "q": "Що таке props в React?", "exp": "Props (properties) — це вхідні дані компонента, як аргументи функції. Вони передаються зверху вниз і є незмінними (immutable)." },
      "en": { "q": "What are props in React?", "exp": "Props (properties) are input data for a component, like function arguments. They are passed from top to bottom and are immutable." },
      "pl": { "q": "Czym są props w React?", "exp": "Props (properties) to dane wejściowe komponentu, jak argumenty funkcji. Są przekazywane z góry na dół i są niezmienne (immutable)." },
      "answers": [
        { "uk": "Внутрішній стан компонента, який можна змінювати", "en": "Internal component state that can be modified", "pl": "Wewnętrzny stan komponentu, który można modyfikować", "correct": false },
        { "uk": "Дані, передані від батьківського компонента до дочірнього (read-only)", "en": "Data passed from parent to child component (read-only)", "pl": "Dane przekazane z komponentu nadrzędnego do potomnego (tylko do odczytu)", "correct": true },
        { "uk": "Методи життєвого циклу компонента", "en": "Component lifecycle methods", "pl": "Metody cyklu życia komponentu", "correct": false },
        { "uk": "CSS-стилі компонента", "en": "Component CSS styles", "pl": "Style CSS komponentu", "correct": false }
      ]
    },
    {
      "id": "react-q08", "order": 8, "difficulty": "beginner",
      "uk": { "q": "Чим state відрізняється від props?", "exp": "State — це 'пам'ять' компонента. Props передаються від батьківського компонента (read-only), state належить самому компоненту і може змінюватися." },
      "en": { "q": "How does state differ from props?", "exp": "State is the component's 'memory'. Props are passed from the parent component (read-only), state belongs to the component itself and can be changed." },
      "pl": { "q": "Czym różni się state od props?", "exp": "State to 'pamięć' komponentu. Props są przekazywane z komponentu nadrzędnego (tylko do odczytu), state należy do samego komponentu i może być zmieniany." },
      "answers": [
        { "uk": "State передається від батьківського компонента", "en": "State is passed from the parent component", "pl": "State jest przekazywany z komponentu nadrzędnego", "correct": false },
        { "uk": "State — це внутрішні дані компонента, які він може змінювати", "en": "State is the component's internal data that it can modify", "pl": "State to wewnętrzne dane komponentu, które może on modyfikować", "correct": true },
        { "uk": "State не впливає на рендеринг компонента", "en": "State does not affect component rendering", "pl": "State nie wpływa na renderowanie komponentu", "correct": false },
        { "uk": "State доступний тільки в класових компонентах", "en": "State is only available in class components", "pl": "State jest dostępny tylko w komponentach klasowych", "correct": false }
      ]
    },
    {
      "id": "react-q09", "order": 9, "difficulty": "beginner",
      "uk": { "q": "Що повертає хук useState?", "exp": "useState повертає масив з двох елементів: поточне значення і функцію-сетер. const [count, setCount] = useState(0) — це деструктуризація масиву." },
      "en": { "q": "What does the useState hook return?", "exp": "useState returns an array of two elements: current value and setter function. const [count, setCount] = useState(0) is array destructuring." },
      "pl": { "q": "Co zwraca hook useState?", "exp": "useState zwraca tablicę dwóch elementów: aktualną wartość i funkcję ustawiającą. const [count, setCount] = useState(0) to destrukturyzacja tablicy." },
      "answers": [
        { "uk": "Тільки поточне значення стану", "en": "Only the current state value", "pl": "Tylko aktualną wartość stanu", "correct": false },
        { "uk": "Масив з двох елементів: поточне значення і функцію для його зміни", "en": "An array of two elements: current value and a function to change it", "pl": "Tablicę dwóch elementów: aktualną wartość i funkcję do jej zmiany", "correct": true },
        { "uk": "Об'єкт з методами get і set", "en": "An object with get and set methods", "pl": "Obiekt z metodami get i set", "correct": false },
        { "uk": "Promise з новим значенням", "en": "A Promise with the new value", "pl": "Promise z nową wartością", "correct": false }
      ]
    },
    {
      "id": "react-q10", "order": 10, "difficulty": "medium",
      "uk": { "q": "Як правильно збільшити лічильник на 1, якщо нове значення залежить від попереднього?", "exp": "Використовуйте функціональну форму: setCount(prev => prev + 1). Це гарантує актуальність значення, бо React може 'батчити' оновлення." },
      "en": { "q": "How to correctly increment a counter by 1 when the new value depends on the previous one?", "exp": "Use the functional form: setCount(prev => prev + 1). This guarantees value accuracy because React may 'batch' state updates." },
      "pl": { "q": "Jak poprawnie zwiększyć licznik o 1, gdy nowa wartość zależy od poprzedniej?", "exp": "Użyj formy funkcyjnej: setCount(prev => prev + 1). To gwarantuje aktualność wartości, ponieważ React może 'batchować' aktualizacje." },
      "answers": [
        { "uk": "setCount(count + 1)", "en": "setCount(count + 1)", "pl": "setCount(count + 1)", "correct": false },
        { "uk": "setCount(prev => prev + 1)", "en": "setCount(prev => prev + 1)", "pl": "setCount(prev => prev + 1)", "correct": true },
        { "uk": "count = count + 1", "en": "count = count + 1", "pl": "count = count + 1", "correct": false },
        { "uk": "setCount(1)", "en": "setCount(1)", "pl": "setCount(1)", "correct": false }
      ]
    },
    {
      "id": "react-q11", "order": 11, "difficulty": "beginner",
      "uk": { "q": "Для чого використовується хук useEffect?", "exp": "useEffect — це місце для 'побічних ефектів': fetch-запити до API, підписки на події, зміна document.title, робота з таймерами." },
      "en": { "q": "What is the useEffect hook used for?", "exp": "useEffect is the place for 'side effects': fetch requests to APIs, event subscriptions, changing document.title, working with timers." },
      "pl": { "q": "Do czego służy hook useEffect?", "exp": "useEffect to miejsce na 'efekty uboczne': zapytania fetch do API, subskrypcje zdarzeń, zmiana document.title, praca z timerami." },
      "answers": [
        { "uk": "Для створення нових компонентів", "en": "For creating new components", "pl": "Do tworzenia nowych komponentów", "correct": false },
        { "uk": "Для виконання побічних ефектів: запити до API, підписки, таймери", "en": "For executing side effects: API requests, subscriptions, timers", "pl": "Do wykonywania efektów ubocznych: zapytania do API, subskrypcje, timery", "correct": true },
        { "uk": "Для стилізації компонентів", "en": "For styling components", "pl": "Do stylizacji komponentów", "correct": false },
        { "uk": "Для оптимізації рендерингу", "en": "For render optimization", "pl": "Do optymalizacji renderowania", "correct": false }
      ]
    },
    {
      "id": "react-q12", "order": 12, "difficulty": "medium",
      "uk": { "q": "Що означає порожній масив залежностей [] у useEffect?", "exp": "Це аналог componentDidMount з класів. Порожній масив каже React: 'цей ефект не залежить від жодних значень, виконай його лише раз'." },
      "en": { "q": "What does an empty dependency array [] in useEffect mean?", "exp": "This is equivalent to componentDidMount from classes. Empty array tells React: 'this effect doesn't depend on any values, run it only once'." },
      "pl": { "q": "Co oznacza pusta tablica zależności [] w useEffect?", "exp": "To odpowiednik componentDidMount z klas. Pusta tablica mówi React: 'ten efekt nie zależy od żadnych wartości, wykonaj go tylko raz'." },
      "answers": [
        { "uk": "Ефект ніколи не виконається", "en": "The effect will never run", "pl": "Efekt nigdy się nie wykona", "correct": false },
        { "uk": "Ефект виконається лише один раз після першого рендеру", "en": "The effect will run only once after the first render", "pl": "Efekt wykona się tylko raz po pierwszym renderze", "correct": true },
        { "uk": "Ефект виконуватиметься на кожному рендері", "en": "The effect will run on every render", "pl": "Efekt będzie się wykonywał przy każdym renderze", "correct": false },
        { "uk": "Це синтаксична помилка", "en": "This is a syntax error", "pl": "To jest błąd składni", "correct": false }
      ]
    },
    {
      "id": "react-q13", "order": 13, "difficulty": "medium",
      "uk": { "q": "Навіщо функція всередині useEffect може повертати іншу функцію?", "exp": "Return-функція в useEffect — це cleanup (очистка). Вона викликається перед наступним запуском ефекту або при розмонтуванні компонента." },
      "en": { "q": "Why might a function inside useEffect return another function?", "exp": "The return function in useEffect is the cleanup. It's called before the next effect run or when the component unmounts." },
      "pl": { "q": "Dlaczego funkcja wewnątrz useEffect może zwracać inną funkcję?", "exp": "Funkcja zwrotna w useEffect to cleanup (czyszczenie). Jest wywoływana przed następnym uruchomieniem efektu lub przy odmontowaniu komponentu." },
      "answers": [
        { "uk": "Щоб повернути нове значення стану", "en": "To return a new state value", "pl": "Aby zwrócić nową wartość stanu", "correct": false },
        { "uk": "Для очистки ресурсів (відписка, очищення таймерів) при розмонтуванні", "en": "For resource cleanup (unsubscribe, clear timers) on unmount", "pl": "Do czyszczenia zasobów (anulowanie subskrypcji, czyszczenie timerów) przy odmontowaniu", "correct": true },
        { "uk": "Для створення дочірнього компонента", "en": "To create a child component", "pl": "Do tworzenia komponentu potomnego", "correct": false },
        { "uk": "Це обов'язкова вимога React", "en": "This is a mandatory React requirement", "pl": "To obowiązkowy wymóg React", "correct": false }
      ]
    },
    {
      "id": "react-q14", "order": 14, "difficulty": "beginner",
      "uk": { "q": "Навіщо потрібен атрибут key при рендері списків у React?", "exp": "key допомагає React ідентифікувати елементи списку. Без унікальних ключів React не може ефективно оновлювати DOM." },
      "en": { "q": "Why is the key attribute needed when rendering lists in React?", "exp": "key helps React identify list elements. Without unique keys, React cannot efficiently update the DOM." },
      "pl": { "q": "Po co jest potrzebny atrybut key przy renderowaniu list w React?", "exp": "key pomaga React identyfikować elementy listy. Bez unikalnych kluczy React nie może efektywnie aktualizować DOM." },
      "answers": [
        { "uk": "Для стилізації елементів списку", "en": "For styling list elements", "pl": "Do stylizacji elementów listy", "correct": false },
        { "uk": "Щоб React міг ефективно визначати, які елементи змінились, додались чи видалились", "en": "So React can efficiently determine which elements changed, added, or removed", "pl": "Aby React mógł efektywnie określić, które elementy się zmieniły, zostały dodane lub usunięte", "correct": true },
        { "uk": "Для сортування елементів за алфавітом", "en": "For sorting elements alphabetically", "pl": "Do sortowania elementów alfabetycznie", "correct": false },
        { "uk": "key — необов'язковий атрибут", "en": "key is an optional attribute", "pl": "key to opcjonalny atrybut", "correct": false }
      ]
    },
    {
      "id": "react-q15", "order": 15, "difficulty": "medium",
      "uk": { "q": "Чому НЕ рекомендується використовувати індекс масиву як key?", "exp": "Якщо ви видалите перший елемент списку, всі індекси 'зсунуться'. React побачить той самий key=0, але інший контент — і може зберегти стан старого елемента для нового." },
      "en": { "q": "Why is it NOT recommended to use array index as key?", "exp": "If you delete the first list element, all indexes will 'shift'. React will see the same key=0 but different content — and may preserve the old element's state for the new one." },
      "pl": { "q": "Dlaczego NIE zaleca się używać indeksu tablicy jako key?", "exp": "Jeśli usuniesz pierwszy element listy, wszystkie indeksy się 'przesuną'. React zobaczy ten sam key=0, ale inną zawartość — i może zachować stan starego elementu dla nowego." },
      "answers": [
        { "uk": "Індекс завжди дорівнює нулю", "en": "Index is always zero", "pl": "Indeks zawsze wynosi zero", "correct": false },
        { "uk": "При зміні порядку елементів React може неправильно оновити компоненти", "en": "When element order changes, React may incorrectly update components", "pl": "Przy zmianie kolejności elementów React może nieprawidłowo zaktualizować komponenty", "correct": true },
        { "uk": "Індекс — це рядок, а не число", "en": "Index is a string, not a number", "pl": "Indeks to string, a nie liczba", "correct": false },
        { "uk": "React не приймає числа як key", "en": "React doesn't accept numbers as key", "pl": "React nie przyjmuje liczb jako key", "correct": false }
      ]
    },
    {
      "id": "react-q16", "order": 16, "difficulty": "beginner",
      "uk": { "q": "Який спосіб умовного рендерингу найчастіше використовують для вибору між двома варіантами?", "exp": "JSX не дозволяє if-else напряму. Тернарний оператор повертає значення, тому ідеально підходить: {isLoggedIn ? <Dashboard /> : <Login />}." },
      "en": { "q": "What conditional rendering method is most commonly used to choose between two options?", "exp": "JSX doesn't allow if-else directly. The ternary operator returns a value, so it's ideal: {isLoggedIn ? <Dashboard /> : <Login />}." },
      "pl": { "q": "Jaki sposób warunkowego renderowania jest najczęściej używany do wyboru między dwoma opcjami?", "exp": "JSX nie pozwala na if-else bezpośrednio. Operator trójargumentowy zwraca wartość, więc idealnie się nadaje: {isLoggedIn ? <Dashboard /> : <Login />}." },
      "answers": [
        { "uk": "if-else всередині JSX", "en": "if-else inside JSX", "pl": "if-else wewnątrz JSX", "correct": false },
        { "uk": "Тернарний оператор: condition ? <A /> : <B />", "en": "Ternary operator: condition ? <A /> : <B />", "pl": "Operator trójargumentowy: condition ? <A /> : <B />", "correct": true },
        { "uk": "switch-case", "en": "switch-case", "pl": "switch-case", "correct": false },
        { "uk": "try-catch", "en": "try-catch", "pl": "try-catch", "correct": false }
      ]
    },
    {
      "id": "react-q17", "order": 17, "difficulty": "beginner",
      "uk": { "q": "Що виведе {isAdmin && <AdminPanel />}, якщо isAdmin = false?", "exp": "Логічний AND (&&) повертає перший 'falsy' операнд. Якщо isAdmin = false, вираз повертає false, і React його ігнорує. Обережно з числом 0!" },
      "en": { "q": "What will {isAdmin && <AdminPanel />} render if isAdmin = false?", "exp": "Logical AND (&&) returns the first 'falsy' operand. If isAdmin = false, the expression returns false, and React ignores it. Be careful with number 0!" },
      "pl": { "q": "Co wyrenderuje {isAdmin && <AdminPanel />}, jeśli isAdmin = false?", "exp": "Logiczny AND (&&) zwraca pierwszy 'falsy' operand. Jeśli isAdmin = false, wyrażenie zwraca false, a React to ignoruje. Uwaga na liczbę 0!" },
      "answers": [
        { "uk": "Компонент <AdminPanel />", "en": "Component <AdminPanel />", "pl": "Komponent <AdminPanel />", "correct": false },
        { "uk": "Слово 'false'", "en": "The word 'false'", "pl": "Słowo 'false'", "correct": false },
        { "uk": "Нічого (пустий рендер)", "en": "Nothing (empty render)", "pl": "Nic (pusty render)", "correct": true },
        { "uk": "Помилку", "en": "An error", "pl": "Błąd", "correct": false }
      ]
    },
    {
      "id": "react-q18", "order": 18, "difficulty": "beginner",
      "uk": { "q": "Як правильно додати обробник кліку в React?", "exp": "React використовує camelCase для подій: onClick, onChange. Передається посилання на функцію (без дужок!). onClick={handleClick()} — викличеться одразу!" },
      "en": { "q": "How to correctly add a click handler in React?", "exp": "React uses camelCase for events: onClick, onChange. Pass a function reference (without parentheses!). onClick={handleClick()} — will execute immediately!" },
      "pl": { "q": "Jak poprawnie dodać obsługę kliknięcia w React?", "exp": "React używa camelCase dla zdarzeń: onClick, onChange. Przekazuje się referencję do funkcji (bez nawiasów!). onClick={handleClick()} — wykona się natychmiast!" },
      "answers": [
        { "uk": "<button onclick=\"handleClick()\">", "en": "<button onclick=\"handleClick()\">", "pl": "<button onclick=\"handleClick()\">", "correct": false },
        { "uk": "<button onClick={handleClick}>", "en": "<button onClick={handleClick}>", "pl": "<button onClick={handleClick}>", "correct": true },
        { "uk": "<button click={handleClick}>", "en": "<button click={handleClick}>", "pl": "<button click={handleClick}>", "correct": false },
        { "uk": "<button addEventListener=\"click\" handler={handleClick}>", "en": "<button addEventListener=\"click\" handler={handleClick}>", "pl": "<button addEventListener=\"click\" handler={handleClick}>", "correct": false }
      ]
    },
    {
      "id": "react-q19", "order": 19, "difficulty": "medium",
      "uk": { "q": "Що таке SyntheticEvent у React?", "exp": "SyntheticEvent — це React'івська абстракція над браузерними подіями. Має той самий інтерфейс (preventDefault, stopPropagation), але працює однаково у всіх браузерах." },
      "en": { "q": "What is SyntheticEvent in React?", "exp": "SyntheticEvent is React's abstraction over browser events. It has the same interface (preventDefault, stopPropagation), but works identically across all browsers." },
      "pl": { "q": "Czym jest SyntheticEvent w React?", "exp": "SyntheticEvent to abstrakcja React nad zdarzeniami przeglądarki. Ma ten sam interfejs (preventDefault, stopPropagation), ale działa identycznie we wszystkich przeglądarkach." },
      "answers": [
        { "uk": "Новий тип події, доступний тільки в React 18", "en": "A new event type available only in React 18", "pl": "Nowy typ zdarzenia dostępny tylko w React 18", "correct": false },
        { "uk": "Обгортка над нативними DOM-подіями для кросбраузерної сумісності", "en": "A wrapper over native DOM events for cross-browser compatibility", "pl": "Wrapper nad natywnymi zdarzeniami DOM dla kompatybilności międzyprzeglądarkowej", "correct": true },
        { "uk": "Подія, яка створюється штучно для тестування", "en": "An event created artificially for testing", "pl": "Zdarzenie tworzone sztucznie do testowania", "correct": false },
        { "uk": "Помилка в системі подій React", "en": "An error in React's event system", "pl": "Błąd w systemie zdarzeń React", "correct": false }
      ]
    },
    {
      "id": "react-q20", "order": 20, "difficulty": "medium",
      "uk": { "q": "Яку проблему вирішує Context API в React?", "exp": "Context дозволяє 'телепортувати' дані напряму, уникаючи prop drilling — передачу пропсів через багато рівнів компонентів." },
      "en": { "q": "What problem does Context API solve in React?", "exp": "Context allows you to 'teleport' data directly, avoiding prop drilling — passing props through many component levels." },
      "pl": { "q": "Jaki problem rozwiązuje Context API w React?", "exp": "Context pozwala 'teleportować' dane bezpośrednio, unikając prop drilling — przekazywania propsów przez wiele poziomów komponentów." },
      "answers": [
        { "uk": "Повільний рендеринг компонентів", "en": "Slow component rendering", "pl": "Wolne renderowanie komponentów", "correct": false },
        { "uk": "Prop drilling — передачу пропсів через багато рівнів компонентів", "en": "Prop drilling — passing props through many component levels", "pl": "Prop drilling — przekazywanie propsów przez wiele poziomów komponentów", "correct": true },
        { "uk": "Відсутність типізації в JavaScript", "en": "Lack of typing in JavaScript", "pl": "Brak typowania w JavaScript", "correct": false },
        { "uk": "Проблеми з CSS-стилями", "en": "CSS styling problems", "pl": "Problemy ze stylami CSS", "correct": false }
      ]
    }
  ]
}
