{
  "questions": [
    {
      "id": "vue-q11",
      "order": 11,
      "difficulty": "medium",
      "uk": {
        "q": "У чому різниця між v-bind і v-model у Vue.js?",
        "exp": "v-bind — одностороння прив'язка даних до атрибутів чи пропсів, v-model — двостороння прив'язка, яка синхронізує дані між станом і елементом форми."
      },
      "en": {
        "q": "What is the difference between v-bind and v-model in Vue.js?",
        "exp": "v-bind is one-way binding of data to attributes or props, v-model is two-way binding that synchronizes data between state and form elements."
      },
      "pl": {
        "q": "Jaka jest różnica między v-bind a v-model w Vue.js?",
        "exp": "v-bind to jednokierunkowe wiązanie danych z atrybutami lub propsami, v-model to dwukierunkowe wiązanie synchronizujące dane między stanem a elementami formularza."
      },
      "answers": [
        {
          "uk": "v-bind працює тільки з компонентами, v-model — тільки з HTML",
          "en": "v-bind only works with components, v-model only with HTML",
          "pl": "v-bind działa tylko z komponentami, v-model tylko z HTML",
          "correct": false
        },
        {
          "uk": "v-bind — одностороння прив'язка, v-model — двостороння прив'язка",
          "en": "v-bind is one-way binding, v-model is two-way binding",
          "pl": "v-bind to wiązanie jednokierunkowe, v-model to wiązanie dwukierunkowe",
          "correct": true
        },
        {
          "uk": "Це синоніми з однаковою функціональністю",
          "en": "They are synonyms with the same functionality",
          "pl": "To synonimy o tej samej funkcjonalności",
          "correct": false
        },
        {
          "uk": "v-model швидший за v-bind",
          "en": "v-model is faster than v-bind",
          "pl": "v-model jest szybszy niż v-bind",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q12",
      "order": 12,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке computed властивості у Vue.js?",
        "exp": "Computed — це властивості, які обчислюються на основі реактивних даних і кешуються, доки їхні залежності не зміняться."
      },
      "en": {
        "q": "What are computed properties in Vue.js?",
        "exp": "Computed properties are calculated based on reactive data and cached until their dependencies change."
      },
      "pl": {
        "q": "Czym są właściwości computed w Vue.js?",
        "exp": "Właściwości computed są obliczane na podstawie reaktywnych danych i cachowane, dopóki ich zależności się nie zmienią."
      },
      "answers": [
        {
          "uk": "Функції, які виконуються при кожному рендері",
          "en": "Functions that execute on every render",
          "pl": "Funkcje wykonywane przy każdym renderze",
          "correct": false
        },
        {
          "uk": "Властивості, що обчислюються на основі реактивних даних і кешуються",
          "en": "Properties calculated based on reactive data and cached",
          "pl": "Właściwości obliczane na podstawie reaktywnych danych i cachowane",
          "correct": true
        },
        {
          "uk": "Статичні константи компонента",
          "en": "Static component constants",
          "pl": "Statyczne stałe komponentu",
          "correct": false
        },
        {
          "uk": "Методи для асинхронних операцій",
          "en": "Methods for asynchronous operations",
          "pl": "Metody do operacji asynchronicznych",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q13",
      "order": 13,
      "difficulty": "medium",
      "uk": {
        "q": "Яка основна відмінність між computed і methods у Vue.js?",
        "exp": "Computed кешуються і перевираховуються тільки при зміні залежностей, methods виконуються щоразу при виклику."
      },
      "en": {
        "q": "What is the main difference between computed and methods in Vue.js?",
        "exp": "Computed properties are cached and recalculated only when dependencies change, methods execute every time they are called."
      },
      "pl": {
        "q": "Jaka jest główna różnica między computed a methods w Vue.js?",
        "exp": "Właściwości computed są cachowane i przeliczane tylko przy zmianie zależności, methods wykonują się za każdym wywołaniem."
      },
      "answers": [
        {
          "uk": "computed можуть приймати аргументи, methods — ні",
          "en": "computed can accept arguments, methods cannot",
          "pl": "computed mogą przyjmować argumenty, methods nie",
          "correct": false
        },
        {
          "uk": "computed кешуються і перевираховуються при зміні залежностей, methods виконуються щоразу",
          "en": "computed are cached and recalculate on dependency change, methods execute every time",
          "pl": "computed są cachowane i przeliczane przy zmianie zależności, methods wykonują się za każdym razem",
          "correct": true
        },
        {
          "uk": "methods швидші за computed",
          "en": "methods are faster than computed",
          "pl": "methods są szybsze niż computed",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "There is no difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q14",
      "order": 14,
      "difficulty": "medium",
      "uk": {
        "q": "Для чого використовуються watchers (спостерігачі) у Vue.js?",
        "exp": "Watch використовується для відстеження змін у реактивних даних і виконання побічних ефектів, як-от API-запити або збереження у localStorage."
      },
      "en": {
        "q": "What are watchers used for in Vue.js?",
        "exp": "Watch is used to track changes in reactive data and perform side effects like API requests or saving to localStorage."
      },
      "pl": {
        "q": "Do czego służą watchery (obserwatorzy) w Vue.js?",
        "exp": "Watch służy do śledzenia zmian w reaktywnych danych i wykonywania efektów ubocznych, jak żądania API czy zapis do localStorage."
      },
      "answers": [
        {
          "uk": "Для кешування обчислених значень",
          "en": "For caching computed values",
          "pl": "Do cachowania obliczonych wartości",
          "correct": false
        },
        {
          "uk": "Для відстеження змін у даних і виконання побічних ефектів",
          "en": "For tracking data changes and performing side effects",
          "pl": "Do śledzenia zmian w danych i wykonywania efektów ubocznych",
          "correct": true
        },
        {
          "uk": "Для реєстрації глобальних компонентів",
          "en": "For registering global components",
          "pl": "Do rejestracji globalnych komponentów",
          "correct": false
        },
        {
          "uk": "Для стилізації компонентів",
          "en": "For styling components",
          "pl": "Do stylizacji komponentów",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q15",
      "order": 15,
      "difficulty": "beginner",
      "uk": {
        "q": "Як передати дані від батьківського компонента до дочірнього у Vue.js?",
        "exp": "Дані передаються через props — властивості, які оголошуються у дочірньому компоненті і передаються як атрибути з батьківського."
      },
      "en": {
        "q": "How do you pass data from a parent component to a child in Vue.js?",
        "exp": "Data is passed through props — properties declared in the child component and passed as attributes from the parent."
      },
      "pl": {
        "q": "Jak przekazać dane z komponentu nadrzędnego do potomnego w Vue.js?",
        "exp": "Dane przekazuje się przez props — właściwości deklarowane w komponencie potomnym i przekazywane jako atrybuty z nadrzędnego."
      },
      "answers": [
        {
          "uk": "Через глобальні змінні",
          "en": "Through global variables",
          "pl": "Przez zmienne globalne",
          "correct": false
        },
        {
          "uk": "Через props",
          "en": "Through props",
          "pl": "Przez props",
          "correct": true
        },
        {
          "uk": "Через localStorage",
          "en": "Through localStorage",
          "pl": "Przez localStorage",
          "correct": false
        },
        {
          "uk": "Через URL-параметри",
          "en": "Through URL parameters",
          "pl": "Przez parametry URL",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q16",
      "order": 16,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке prop drilling і як його уникнути у Vue.js?",
        "exp": "Prop drilling — це передача даних через багато рівнів компонентів. Уникнути можна через provide/inject або Pinia для глобального стану."
      },
      "en": {
        "q": "What is prop drilling and how can you avoid it in Vue.js?",
        "exp": "Prop drilling is passing data through many component levels. It can be avoided using provide/inject or Pinia for global state."
      },
      "pl": {
        "q": "Czym jest prop drilling i jak go uniknąć w Vue.js?",
        "exp": "Prop drilling to przekazywanie danych przez wiele poziomów komponentów. Można go uniknąć używając provide/inject lub Pinia dla stanu globalnego."
      },
      "answers": [
        {
          "uk": "Оптимізація рендерингу, уникають через v-memo",
          "en": "Rendering optimization, avoided with v-memo",
          "pl": "Optymalizacja renderingu, unikana przez v-memo",
          "correct": false
        },
        {
          "uk": "Передача даних через багато рівнів компонентів, уникають через provide/inject або Pinia",
          "en": "Passing data through many component levels, avoided with provide/inject or Pinia",
          "pl": "Przekazywanie danych przez wiele poziomów komponentów, unikane przez provide/inject lub Pinia",
          "correct": true
        },
        {
          "uk": "Помилка компіляції шаблону",
          "en": "Template compilation error",
          "pl": "Błąd kompilacji szablonu",
          "correct": false
        },
        {
          "uk": "Витік пам'яті у компонентах",
          "en": "Memory leak in components",
          "pl": "Wyciek pamięci w komponentach",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q17",
      "order": 17,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке слоти (slots) у Vue.js?",
        "exp": "Слоти дозволяють передавати вміст від батьківського компонента в дочірній у визначене місце шаблону для гнучкої композиції."
      },
      "en": {
        "q": "What are slots in Vue.js?",
        "exp": "Slots allow passing content from a parent component to a child at a designated place in the template for flexible composition."
      },
      "pl": {
        "q": "Czym są sloty w Vue.js?",
        "exp": "Sloty pozwalają przekazywać treść z komponentu nadrzędnego do potomnego w wyznaczone miejsce szablonu dla elastycznej kompozycji."
      },
      "answers": [
        {
          "uk": "Методи для обробки подій",
          "en": "Methods for handling events",
          "pl": "Metody do obsługi zdarzeń",
          "correct": false
        },
        {
          "uk": "Місця у шаблоні для передачі вмісту від батьківського компонента",
          "en": "Places in the template for passing content from the parent component",
          "pl": "Miejsca w szablonie do przekazywania treści z komponentu nadrzędnego",
          "correct": true
        },
        {
          "uk": "Хуки життєвого циклу",
          "en": "Lifecycle hooks",
          "pl": "Hooki cyklu życia",
          "correct": false
        },
        {
          "uk": "Директиви для анімацій",
          "en": "Directives for animations",
          "pl": "Dyrektywy do animacji",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q18",
      "order": 18,
      "difficulty": "medium",
      "uk": {
        "q": "Як дочірній компонент може надіслати дані батьківському у Vue.js?",
        "exp": "Дочірній компонент використовує $emit для надсилання подій з даними, які батьківський компонент слухає через @eventName."
      },
      "en": {
        "q": "How can a child component send data to its parent in Vue.js?",
        "exp": "The child component uses $emit to send events with data that the parent listens to via @eventName."
      },
      "pl": {
        "q": "Jak komponent potomny może wysłać dane do nadrzędnego w Vue.js?",
        "exp": "Komponent potomny używa $emit do wysyłania zdarzeń z danymi, których komponent nadrzędny nasłuchuje przez @eventName."
      },
      "answers": [
        {
          "uk": "Через props",
          "en": "Through props",
          "pl": "Przez props",
          "correct": false
        },
        {
          "uk": "Через $emit і події",
          "en": "Through $emit and events",
          "pl": "Przez $emit i zdarzenia",
          "correct": true
        },
        {
          "uk": "Через глобальний store",
          "en": "Through global store",
          "pl": "Przez globalny store",
          "correct": false
        },
        {
          "uk": "Напряму змінюючи стан батька",
          "en": "By directly changing parent state",
          "pl": "Bezpośrednio zmieniając stan rodzica",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q19",
      "order": 19,
      "difficulty": "beginner",
      "uk": {
        "q": "Яка директива використовується для рендерингу списків у Vue.js?",
        "exp": "Директива v-for ітерує по масиву або об'єкту і рендерить елемент для кожного пункту. Обов'язково використовуйте :key для оптимізації."
      },
      "en": {
        "q": "Which directive is used for rendering lists in Vue.js?",
        "exp": "The v-for directive iterates over an array or object and renders an element for each item. Always use :key for optimization."
      },
      "pl": {
        "q": "Której dyrektywy używa się do renderowania list w Vue.js?",
        "exp": "Dyrektywa v-for iteruje po tablicy lub obiekcie i renderuje element dla każdego elementu. Zawsze używaj :key do optymalizacji."
      },
      "answers": [
        {
          "uk": "v-list",
          "en": "v-list",
          "pl": "v-list",
          "correct": false
        },
        {
          "uk": "v-for",
          "en": "v-for",
          "pl": "v-for",
          "correct": true
        },
        {
          "uk": "v-each",
          "en": "v-each",
          "pl": "v-each",
          "correct": false
        },
        {
          "uk": "v-repeat",
          "en": "v-repeat",
          "pl": "v-repeat",
          "correct": false
        }
      ]
    },
    {
      "id": "vue-q20",
      "order": 20,
      "difficulty": "medium",
      "uk": {
        "q": "У чому різниця між v-if і v-show у Vue.js?",
        "exp": "v-if додає/видаляє елемент з DOM, v-show лише змінює display: none. Використовуйте v-show для частого перемикання видимості."
      },
      "en": {
        "q": "What is the difference between v-if and v-show in Vue.js?",
        "exp": "v-if adds/removes the element from DOM, v-show only toggles display: none. Use v-show for frequent visibility toggling."
      },
      "pl": {
        "q": "Jaka jest różnica między v-if a v-show w Vue.js?",
        "exp": "v-if dodaje/usuwa element z DOM, v-show tylko zmienia display: none. Używaj v-show do częstego przełączania widoczności."
      },
      "answers": [
        {
          "uk": "v-if працює з компонентами, v-show — з HTML",
          "en": "v-if works with components, v-show with HTML",
          "pl": "v-if działa z komponentami, v-show z HTML",
          "correct": false
        },
        {
          "uk": "v-if додає/видаляє елемент з DOM, v-show змінює CSS display",
          "en": "v-if adds/removes element from DOM, v-show changes CSS display",
          "pl": "v-if dodaje/usuwa element z DOM, v-show zmienia CSS display",
          "correct": true
        },
        {
          "uk": "v-show швидший для першого рендерингу",
          "en": "v-show is faster for initial rendering",
          "pl": "v-show jest szybszy dla początkowego renderowania",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "There is no difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    }
  ]
}
