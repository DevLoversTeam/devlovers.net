{
  "questions": [
    {
      "id": "node-adv-q31",
      "order": 31,
      "difficulty": "medium",
      "uk": {
        "q": "Чому Node.js підходить для IoT (Internet of Things) застосунків?",
        "exp": "Легка вага, асинхронність та подієво-орієнтована модель дозволяють ефективно обробляти велику кількість підключень від сенсорів у реальному часі."
      },
      "en": {
        "q": "Why is Node.js suitable for IoT (Internet of Things) applications?",
        "exp": "Lightweight, async, and event-driven model allows efficient handling of many sensor connections in real-time."
      },
      "pl": {
        "q": "Dlaczego Node.js nadaje się do aplikacji IoT (Internet of Things)?",
        "exp": "Lekkość, asynchroniczność i model sterowany zdarzeniami pozwalają efektywnie obsługiwać wiele połączeń z sensorów w czasie rzeczywistym."
      },
      "answers": [
        {
          "uk": "Node.js споживає мало електрики",
          "en": "Node.js consumes little electricity",
          "pl": "Node.js zużywa mało elektryczności",
          "correct": false
        },
        {
          "uk": "Легкість, асинхронність та event-driven модель для обробки багатьох підключень",
          "en": "Lightweight, async, and event-driven model for handling many connections",
          "pl": "Lekkość, asynchroniczność i model event-driven do obsługi wielu połączeń",
          "correct": true
        },
        {
          "uk": "Node.js працює без інтернету",
          "en": "Node.js works without internet",
          "pl": "Node.js działa bez internetu",
          "correct": false
        },
        {
          "uk": "Node.js замінює прошивку пристроїв",
          "en": "Node.js replaces device firmware",
          "pl": "Node.js zastępuje firmware urządzeń",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q32",
      "order": 32,
      "difficulty": "medium",
      "uk": {
        "q": "Який протокол часто використовують для IoT комунікації з Node.js?",
        "exp": "MQTT — легкий протокол publish/subscribe для IoT з низьким споживанням ресурсів, підтримкою QoS та offline повідомлень."
      },
      "en": {
        "q": "Which protocol is often used for IoT communication with Node.js?",
        "exp": "MQTT is a lightweight publish/subscribe protocol for IoT with low resource consumption, QoS support, and offline messages."
      },
      "pl": {
        "q": "Który protokół jest często używany do komunikacji IoT z Node.js?",
        "exp": "MQTT to lekki protokół publish/subscribe dla IoT z niskim zużyciem zasobów, obsługą QoS i wiadomościami offline."
      },
      "answers": [
        {
          "uk": "FTP",
          "en": "FTP",
          "pl": "FTP",
          "correct": false
        },
        {
          "uk": "MQTT — легкий publish/subscribe протокол для IoT",
          "en": "MQTT — lightweight publish/subscribe protocol for IoT",
          "pl": "MQTT — lekki protokół publish/subscribe dla IoT",
          "correct": true
        },
        {
          "uk": "SMTP",
          "en": "SMTP",
          "pl": "SMTP",
          "correct": false
        },
        {
          "uk": "SSH",
          "en": "SSH",
          "pl": "SSH",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q33",
      "order": 33,
      "difficulty": "medium",
      "uk": {
        "q": "Яка бібліотека використовується для машинного навчання безпосередньо у Node.js?",
        "exp": "TensorFlow.js дозволяє тренувати та запускати ML-моделі прямо у Node.js. Також є Brain.js, ML.js для легких задач."
      },
      "en": {
        "q": "Which library is used for machine learning directly in Node.js?",
        "exp": "TensorFlow.js allows training and running ML models directly in Node.js. There's also Brain.js, ML.js for lighter tasks."
      },
      "pl": {
        "q": "Która biblioteka jest używana do uczenia maszynowego bezpośrednio w Node.js?",
        "exp": "TensorFlow.js pozwala trenować i uruchamiać modele ML bezpośrednio w Node.js. Jest też Brain.js, ML.js dla lżejszych zadań."
      },
      "answers": [
        {
          "uk": "Lodash",
          "en": "Lodash",
          "pl": "Lodash",
          "correct": false
        },
        {
          "uk": "TensorFlow.js, Brain.js, ML.js",
          "en": "TensorFlow.js, Brain.js, ML.js",
          "pl": "TensorFlow.js, Brain.js, ML.js",
          "correct": true
        },
        {
          "uk": "Express.js",
          "en": "Express.js",
          "pl": "Express.js",
          "correct": false
        },
        {
          "uk": "Moment.js",
          "en": "Moment.js",
          "pl": "Moment.js",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q34",
      "order": 34,
      "difficulty": "medium",
      "uk": {
        "q": "Яка перевага Socket.IO над чистим WebSocket?",
        "exp": "Socket.IO надає автоматичний fallback на long-polling, rooms/namespaces для групування, reconnection та broadcasting з коробки."
      },
      "en": {
        "q": "What is the advantage of Socket.IO over plain WebSocket?",
        "exp": "Socket.IO provides automatic fallback to long-polling, rooms/namespaces for grouping, reconnection, and broadcasting out of the box."
      },
      "pl": {
        "q": "Jaka jest zaleta Socket.IO nad czystym WebSocket?",
        "exp": "Socket.IO zapewnia automatyczny fallback na long-polling, rooms/namespaces do grupowania, reconnection i broadcasting z pudełka."
      },
      "answers": [
        {
          "uk": "Socket.IO швидший за WebSocket",
          "en": "Socket.IO is faster than WebSocket",
          "pl": "Socket.IO jest szybszy niż WebSocket",
          "correct": false
        },
        {
          "uk": "Fallback на long-polling, rooms/namespaces, reconnection, broadcasting",
          "en": "Fallback to long-polling, rooms/namespaces, reconnection, broadcasting",
          "pl": "Fallback na long-polling, rooms/namespaces, reconnection, broadcasting",
          "correct": true
        },
        {
          "uk": "Socket.IO не потребує сервера",
          "en": "Socket.IO doesn't need a server",
          "pl": "Socket.IO nie potrzebuje serwera",
          "correct": false
        },
        {
          "uk": "Socket.IO працює тільки з React",
          "en": "Socket.IO works only with React",
          "pl": "Socket.IO działa tylko z React",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q35",
      "order": 35,
      "difficulty": "medium",
      "uk": {
        "q": "Як інтегрувати Node.js з Python ML-сервісом для великих моделей?",
        "exp": "Запустити Python скрипт через child_process, або створити окремий Python REST API/gRPC сервіс, з яким Node.js взаємодіє через HTTP."
      },
      "en": {
        "q": "How to integrate Node.js with a Python ML service for large models?",
        "exp": "Run Python script via child_process, or create a separate Python REST API/gRPC service that Node.js interacts with via HTTP."
      },
      "pl": {
        "q": "Jak zintegrować Node.js z serwisem Python ML dla dużych modeli?",
        "exp": "Uruchomić skrypt Python przez child_process lub stworzyć osobny serwis Python REST API/gRPC, z którym Node.js komunikuje się przez HTTP."
      },
      "answers": [
        {
          "uk": "Переписати модель на JavaScript",
          "en": "Rewrite the model in JavaScript",
          "pl": "Przepisać model na JavaScript",
          "correct": false
        },
        {
          "uk": "child_process або окремий Python REST API/gRPC сервіс",
          "en": "child_process or separate Python REST API/gRPC service",
          "pl": "child_process lub osobny serwis Python REST API/gRPC",
          "correct": true
        },
        {
          "uk": "Імпортувати Python напряму в Node.js",
          "en": "Import Python directly into Node.js",
          "pl": "Importować Python bezpośrednio do Node.js",
          "correct": false
        },
        {
          "uk": "Python не можна інтегрувати з Node.js",
          "en": "Python cannot be integrated with Node.js",
          "pl": "Python nie może być zintegrowany z Node.js",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q36",
      "order": 36,
      "difficulty": "medium",
      "uk": {
        "q": "Який інструмент використовують для load testing Node.js API?",
        "exp": "Autocannon, Artillery, k6, Apache JMeter — для симуляції великого навантаження та вимірювання latency, throughput, error rate."
      },
      "en": {
        "q": "Which tool is used for load testing Node.js API?",
        "exp": "Autocannon, Artillery, k6, Apache JMeter — for simulating heavy load and measuring latency, throughput, error rate."
      },
      "pl": {
        "q": "Które narzędzie jest używane do load testingu API Node.js?",
        "exp": "Autocannon, Artillery, k6, Apache JMeter — do symulowania dużego obciążenia i mierzenia latency, throughput, error rate."
      },
      "answers": [
        {
          "uk": "ESLint",
          "en": "ESLint",
          "pl": "ESLint",
          "correct": false
        },
        {
          "uk": "Autocannon, Artillery, k6, Apache JMeter",
          "en": "Autocannon, Artillery, k6, Apache JMeter",
          "pl": "Autocannon, Artillery, k6, Apache JMeter",
          "correct": true
        },
        {
          "uk": "Prettier",
          "en": "Prettier",
          "pl": "Prettier",
          "correct": false
        },
        {
          "uk": "Webpack",
          "en": "Webpack",
          "pl": "Webpack",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q37",
      "order": 37,
      "difficulty": "medium",
      "uk": {
        "q": "Як безпечно зберігати секрети (API ключі, паролі) у Node.js продакшн?",
        "exp": "Використовувати Vault, AWS Secrets Manager, Azure Key Vault або Kubernetes Secrets замість .env файлів чи хардкоду в коді."
      },
      "en": {
        "q": "How to securely store secrets (API keys, passwords) in Node.js production?",
        "exp": "Use Vault, AWS Secrets Manager, Azure Key Vault, or Kubernetes Secrets instead of .env files or hardcoding in code."
      },
      "pl": {
        "q": "Jak bezpiecznie przechowywać sekrety (klucze API, hasła) w Node.js na produkcji?",
        "exp": "Używać Vault, AWS Secrets Manager, Azure Key Vault lub Kubernetes Secrets zamiast plików .env lub hardkodowania w kodzie."
      },
      "answers": [
        {
          "uk": "Зберігати у коді для зручності",
          "en": "Store in code for convenience",
          "pl": "Przechowywać w kodzie dla wygody",
          "correct": false
        },
        {
          "uk": "Vault, AWS Secrets Manager, Azure Key Vault, Kubernetes Secrets",
          "en": "Vault, AWS Secrets Manager, Azure Key Vault, Kubernetes Secrets",
          "pl": "Vault, AWS Secrets Manager, Azure Key Vault, Kubernetes Secrets",
          "correct": true
        },
        {
          "uk": "Публікувати в README",
          "en": "Publish in README",
          "pl": "Publikować w README",
          "correct": false
        },
        {
          "uk": "Комітити .env у Git",
          "en": "Commit .env to Git",
          "pl": "Commitować .env do Git",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q38",
      "order": 38,
      "difficulty": "medium",
      "uk": {
        "q": "Як Node.js застосунок масштабується у Kubernetes?",
        "exp": "Запускається як Pod/Deployment з кількома репліками, використовується Horizontal Pod Autoscaler (HPA) для автоматичного масштабування за CPU/пам'яттю."
      },
      "en": {
        "q": "How does a Node.js application scale in Kubernetes?",
        "exp": "Runs as Pod/Deployment with multiple replicas, uses Horizontal Pod Autoscaler (HPA) for automatic scaling by CPU/memory."
      },
      "pl": {
        "q": "Jak aplikacja Node.js skaluje się w Kubernetes?",
        "exp": "Działa jako Pod/Deployment z wieloma replikami, używa Horizontal Pod Autoscaler (HPA) do automatycznego skalowania po CPU/pamięci."
      },
      "answers": [
        {
          "uk": "Node.js не працює в Kubernetes",
          "en": "Node.js doesn't work in Kubernetes",
          "pl": "Node.js nie działa w Kubernetes",
          "correct": false
        },
        {
          "uk": "Pod/Deployment з репліками, Horizontal Pod Autoscaler для автоскейлінгу",
          "en": "Pod/Deployment with replicas, Horizontal Pod Autoscaler for autoscaling",
          "pl": "Pod/Deployment z replikami, Horizontal Pod Autoscaler do autoskalowania",
          "correct": true
        },
        {
          "uk": "Тільки один екземпляр на кластер",
          "en": "Only one instance per cluster",
          "pl": "Tylko jedna instancja na klaster",
          "correct": false
        },
        {
          "uk": "Kubernetes автоматично перетворює код",
          "en": "Kubernetes automatically transforms code",
          "pl": "Kubernetes automatycznie przekształca kod",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q39",
      "order": 39,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке supertest і як він використовується для тестування Node.js API?",
        "exp": "Supertest — бібліотека для integration testing HTTP-серверів у Node.js. Дозволяє робити HTTP-запити до Express/Koa app і перевіряти відповіді."
      },
      "en": {
        "q": "What is supertest and how is it used for testing Node.js API?",
        "exp": "Supertest is a library for integration testing HTTP servers in Node.js. Allows making HTTP requests to Express/Koa app and checking responses."
      },
      "pl": {
        "q": "Czym jest supertest i jak jest używany do testowania API Node.js?",
        "exp": "Supertest to biblioteka do integration testingu serwerów HTTP w Node.js. Pozwala wysyłać żądania HTTP do aplikacji Express/Koa i sprawdzać odpowiedzi."
      },
      "answers": [
        {
          "uk": "Бібліотека для UI-тестування",
          "en": "A library for UI testing",
          "pl": "Biblioteka do testowania UI",
          "correct": false
        },
        {
          "uk": "Бібліотека для integration testing HTTP-серверів Node.js",
          "en": "A library for integration testing Node.js HTTP servers",
          "pl": "Biblioteka do integration testingu serwerów HTTP Node.js",
          "correct": true
        },
        {
          "uk": "Інструмент для деплою",
          "en": "A deployment tool",
          "pl": "Narzędzie do deploymentu",
          "correct": false
        },
        {
          "uk": "Менеджер пакетів",
          "en": "A package manager",
          "pl": "Menedżer pakietów",
          "correct": false
        }
      ]
    },
    {
      "id": "node-adv-q40",
      "order": 40,
      "difficulty": "medium",
      "uk": {
        "q": "Що означає принцип Dev/prod parity у Twelve-Factor App?",
        "exp": "Dev/prod parity означає, що середовище розробки має бути максимально наближеним до продакшну для уникнення проблем при деплої."
      },
      "en": {
        "q": "What does the Dev/prod parity principle mean in Twelve-Factor App?",
        "exp": "Dev/prod parity means the development environment should closely match production to avoid deployment issues."
      },
      "pl": {
        "q": "Co oznacza zasada Dev/prod parity w Twelve-Factor App?",
        "exp": "Dev/prod parity oznacza, że środowisko deweloperskie powinno być maksymalnie zbliżone do produkcji, aby uniknąć problemów przy deploymencie."
      },
      "answers": [
        {
          "uk": "Dev і prod мають різні бази даних",
          "en": "Dev and prod have different databases",
          "pl": "Dev i prod mają różne bazy danych",
          "correct": false
        },
        {
          "uk": "Середовище розробки максимально наближене до продакшну",
          "en": "Development environment closely matches production",
          "pl": "Środowisko deweloperskie maksymalnie zbliżone do produkcji",
          "correct": true
        },
        {
          "uk": "Код пишеться тільки на продакшні",
          "en": "Code is written only in production",
          "pl": "Kod jest pisany tylko na produkcji",
          "correct": false
        },
        {
          "uk": "Dev не потрібен взагалі",
          "en": "Dev is not needed at all",
          "pl": "Dev nie jest w ogóle potrzebny",
          "correct": false
        }
      ]
    }
  ]
}
