{
  "questions": [
    {
      "id": "js-q11",
      "order": 11,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке замикання (closure) у JavaScript?",
        "exp": "Замикання — це функція, яка запам'ятовує оточення, в якому була створена, і має доступ до змінних зовнішньої області видимості."
      },
      "en": {
        "q": "What is a closure in JavaScript?",
        "exp": "A closure is a function that remembers the environment in which it was created and has access to variables from outer scope."
      },
      "pl": {
        "q": "Czym jest domknięcie (closure) w JavaScript?",
        "exp": "Domknięcie to funkcja, która pamięta środowisko, w którym została stworzona, i ma dostęp do zmiennych z zewnętrznego zakresu."
      },
      "answers": [
        {
          "uk": "Спосіб закрити браузерне вікно через JavaScript",
          "en": "A way to close a browser window through JavaScript",
          "pl": "Sposób na zamknięcie okna przeglądarki przez JavaScript",
          "correct": false
        },
        {
          "uk": "Функція, яка запам'ятовує оточення та має доступ до змінних зовнішньої області видимості",
          "en": "A function that remembers its environment and has access to outer scope variables",
          "pl": "Funkcja, która pamięta swoje otoczenie i ma dostęp do zmiennych z zewnętrznego zakresu",
          "correct": true
        },
        {
          "uk": "Метод для завершення виконання функції",
          "en": "A method for terminating function execution",
          "pl": "Metoda kończenia wykonywania funkcji",
          "correct": false
        },
        {
          "uk": "Приватна властивість класу",
          "en": "A private class property",
          "pl": "Prywatna właściwość klasy",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q12",
      "order": 12,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке hoisting у JavaScript?",
        "exp": "Hoisting — це механізм, при якому оголошення змінних та функцій переміщуються на початок області видимості перед виконанням коду."
      },
      "en": {
        "q": "What is hoisting in JavaScript?",
        "exp": "Hoisting is a mechanism where variable and function declarations are moved to the top of their scope before code execution."
      },
      "pl": {
        "q": "Czym jest hoisting w JavaScript?",
        "exp": "Hoisting to mechanizm, w którym deklaracje zmiennych i funkcji są przenoszone na początek ich zakresu przed wykonaniem kodu."
      },
      "answers": [
        {
          "uk": "Підняття DOM-елементів на верхній рівень сторінки",
          "en": "Lifting DOM elements to the top level of the page",
          "pl": "Podnoszenie elementów DOM na najwyższy poziom strony",
          "correct": false
        },
        {
          "uk": "Переміщення оголошень змінних та функцій на початок області видимості",
          "en": "Moving variable and function declarations to the top of their scope",
          "pl": "Przenoszenie deklaracji zmiennych i funkcji na początek ich zakresu",
          "correct": true
        },
        {
          "uk": "Оптимізація коду для швидшого виконання",
          "en": "Code optimization for faster execution",
          "pl": "Optymalizacja kodu dla szybszego wykonania",
          "correct": false
        },
        {
          "uk": "Видалення невикористаних змінних",
          "en": "Removal of unused variables",
          "pl": "Usuwanie nieużywanych zmiennych",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q13",
      "order": 13,
      "difficulty": "beginner",
      "uk": {
        "q": "Яка область видимості у змінної, оголошеної через let?",
        "exp": "Змінні, оголошені через let, мають блочну область видимості — існують лише в межах блоку {} де були оголошені."
      },
      "en": {
        "q": "What scope does a variable declared with let have?",
        "exp": "Variables declared with let have block scope — they exist only within the block {} where they were declared."
      },
      "pl": {
        "q": "Jaki zakres ma zmienna zadeklarowana przez let?",
        "exp": "Zmienne zadeklarowane przez let mają zakres blokowy — istnieją tylko w obrębie bloku {}, w którym zostały zadeklarowane."
      },
      "answers": [
        {
          "uk": "Глобальна область видимості",
          "en": "Global scope",
          "pl": "Zakres globalny",
          "correct": false
        },
        {
          "uk": "Функціональна область видимості",
          "en": "Function scope",
          "pl": "Zakres funkcyjny",
          "correct": false
        },
        {
          "uk": "Блочна область видимості",
          "en": "Block scope",
          "pl": "Zakres blokowy",
          "correct": true
        },
        {
          "uk": "Область видимості модуля",
          "en": "Module scope",
          "pl": "Zakres modułu",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q14",
      "order": 14,
      "difficulty": "medium",
      "uk": {
        "q": "Чим відрізняються стрілкові функції від звичайних функцій стосовно this?",
        "exp": "Стрілкові функції не мають власного this — вони успадковують this з оточуючого контексту, де були створені."
      },
      "en": {
        "q": "How do arrow functions differ from regular functions regarding this?",
        "exp": "Arrow functions don't have their own this — they inherit this from the surrounding context where they were created."
      },
      "pl": {
        "q": "Czym różnią się funkcje strzałkowe od zwykłych funkcji w kontekście this?",
        "exp": "Funkcje strzałkowe nie mają własnego this — dziedziczą this z otaczającego kontekstu, w którym zostały utworzone."
      },
      "answers": [
        {
          "uk": "Стрілкові функції не можуть використовувати this взагалі",
          "en": "Arrow functions cannot use this at all",
          "pl": "Funkcje strzałkowe nie mogą w ogóle używać this",
          "correct": false
        },
        {
          "uk": "Стрілкові функції не мають власного this, успадковують з оточуючого контексту",
          "en": "Arrow functions don't have their own this, inherit from surrounding context",
          "pl": "Funkcje strzałkowe nie mają własnego this, dziedziczą z otaczającego kontekstu",
          "correct": true
        },
        {
          "uk": "У стрілкових функціях this завжди вказує на window",
          "en": "In arrow functions this always points to window",
          "pl": "W funkcjach strzałkowych this zawsze wskazuje na window",
          "correct": false
        },
        {
          "uk": "Різниці немає",
          "en": "There is no difference",
          "pl": "Nie ma różnicy",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q15",
      "order": 15,
      "difficulty": "medium",
      "uk": {
        "q": "Що відбувається, коли ви намагаєтесь отримати доступ до змінної, оголошеної через let, до її ініціалізації?",
        "exp": "Виникає ReferenceError через temporal dead zone — період між початком блоку та ініціалізацією змінної."
      },
      "en": {
        "q": "What happens when you try to access a variable declared with let before its initialization?",
        "exp": "A ReferenceError occurs due to the temporal dead zone — the period between the start of the block and variable initialization."
      },
      "pl": {
        "q": "Co się dzieje, gdy próbujesz uzyskać dostęp do zmiennej zadeklarowanej przez let przed jej inicjalizacją?",
        "exp": "Wystąpi ReferenceError z powodu temporal dead zone — okresu między początkiem bloku a inicjalizacją zmiennej."
      },
      "answers": [
        {
          "uk": "Отримаєте значення undefined",
          "en": "You get the value undefined",
          "pl": "Otrzymasz wartość undefined",
          "correct": false
        },
        {
          "uk": "Виникне ReferenceError через temporal dead zone",
          "en": "A ReferenceError occurs due to temporal dead zone",
          "pl": "Wystąpi ReferenceError z powodu temporal dead zone",
          "correct": true
        },
        {
          "uk": "Отримаєте значення null",
          "en": "You get the value null",
          "pl": "Otrzymasz wartość null",
          "correct": false
        },
        {
          "uk": "Змінна автоматично ініціалізується нулем",
          "en": "Variable is automatically initialized with zero",
          "pl": "Zmienna jest automatycznie inicjalizowana zerem",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q16",
      "order": 16,
      "difficulty": "beginner",
      "uk": {
        "q": "Яку головну перевагу дає використання стрілкових функцій?",
        "exp": "Стрілкові функції мають коротший синтаксис та лексичне прив'язування this, що спрощує роботу з контекстом."
      },
      "en": {
        "q": "What is the main advantage of using arrow functions?",
        "exp": "Arrow functions have shorter syntax and lexical this binding, which simplifies working with context."
      },
      "pl": {
        "q": "Jaka jest główna zaleta używania funkcji strzałkowych?",
        "exp": "Funkcje strzałkowe mają krótszą składnię i leksykalne wiązanie this, co upraszcza pracę z kontekstem."
      },
      "answers": [
        {
          "uk": "Вони виконуються швидше",
          "en": "They execute faster",
          "pl": "Wykonują się szybciej",
          "correct": false
        },
        {
          "uk": "Коротший синтаксис та лексичне прив'язування this",
          "en": "Shorter syntax and lexical this binding",
          "pl": "Krótsza składnia i leksykalne wiązanie this",
          "correct": true
        },
        {
          "uk": "Вони можуть мати будь-яку кількість параметрів",
          "en": "They can have any number of parameters",
          "pl": "Mogą mieć dowolną liczbę parametrów",
          "correct": false
        },
        {
          "uk": "Вони автоматично обробляють помилки",
          "en": "They automatically handle errors",
          "pl": "Automatycznie obsługują błędy",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q17",
      "order": 17,
      "difficulty": "advanced",
      "uk": {
        "q": "Що станеться, якщо викликати стрілкову функцію через new?",
        "exp": "Виникне TypeError, оскільки стрілкові функції не можуть бути конструкторами — у них немає внутрішнього методу [[Construct]]."
      },
      "en": {
        "q": "What happens if you call an arrow function with new?",
        "exp": "A TypeError occurs because arrow functions cannot be constructors — they lack the internal [[Construct]] method."
      },
      "pl": {
        "q": "Co się stanie, jeśli wywołasz funkcję strzałkową przez new?",
        "exp": "Wystąpi TypeError, ponieważ funkcje strzałkowe nie mogą być konstruktorami — brakuje im wewnętrznej metody [[Construct]]."
      },
      "answers": [
        {
          "uk": "Створиться новий об'єкт як зі звичайною функцією",
          "en": "A new object will be created like with regular function",
          "pl": "Zostanie utworzony nowy obiekt jak w przypadku zwykłej funkcji",
          "correct": false
        },
        {
          "uk": "Виникне TypeError — стрілкові функції не можуть бути конструкторами",
          "en": "A TypeError occurs — arrow functions cannot be constructors",
          "pl": "Wystąpi TypeError — funkcje strzałkowe nie mogą być konstruktorami",
          "correct": true
        },
        {
          "uk": "Поверне undefined",
          "en": "Returns undefined",
          "pl": "Zwróci undefined",
          "correct": false
        },
        {
          "uk": "Створить порожній об'єкт",
          "en": "Creates an empty object",
          "pl": "Utworzy pusty obiekt",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q18",
      "order": 18,
      "difficulty": "medium",
      "uk": {
        "q": "В якому порядку виконуються phases при event propagation?",
        "exp": "Спочатку йде capturing phase (від document до цільового елемента), потім target phase, потім bubbling phase (від цільового до document)."
      },
      "en": {
        "q": "In what order do phases execute during event propagation?",
        "exp": "First comes capturing phase (from document to target), then target phase, then bubbling phase (from target to document)."
      },
      "pl": {
        "q": "W jakiej kolejności wykonują się fazy podczas propagacji zdarzeń?",
        "exp": "Najpierw jest faza capturing (od document do celu), potem faza target, potem faza bubbling (od celu do document)."
      },
      "answers": [
        {
          "uk": "Bubbling → Target → Capturing",
          "en": "Bubbling → Target → Capturing",
          "pl": "Bubbling → Target → Capturing",
          "correct": false
        },
        {
          "uk": "Capturing → Target → Bubbling",
          "en": "Capturing → Target → Bubbling",
          "pl": "Capturing → Target → Bubbling",
          "correct": true
        },
        {
          "uk": "Target → Bubbling → Capturing",
          "en": "Target → Bubbling → Capturing",
          "pl": "Target → Bubbling → Capturing",
          "correct": false
        },
        {
          "uk": "Всі фази виконуються одночасно",
          "en": "All phases execute simultaneously",
          "pl": "Wszystkie fazy wykonują się jednocześnie",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q19",
      "order": 19,
      "difficulty": "medium",
      "uk": {
        "q": "Яка різниця між stopPropagation() та stopImmediatePropagation()?",
        "exp": "stopPropagation() зупиняє поширення події далі, але не скасовує інші обробники на поточному елементі. stopImmediatePropagation() зупиняє поширення та скасовує всі інші обробники."
      },
      "en": {
        "q": "What's the difference between stopPropagation() and stopImmediatePropagation()?",
        "exp": "stopPropagation() stops event propagation further, but doesn't cancel other handlers on current element. stopImmediatePropagation() stops propagation and cancels all other handlers."
      },
      "pl": {
        "q": "Jaka jest różnica między stopPropagation() a stopImmediatePropagation()?",
        "exp": "stopPropagation() zatrzymuje dalszą propagację zdarzenia, ale nie anuluje innych handlerów na bieżącym elemencie. stopImmediatePropagation() zatrzymuje propagację i anuluje wszystkie inne handlery."
      },
      "answers": [
        {
          "uk": "Різниці немає, це синоніми",
          "en": "No difference, they are synonyms",
          "pl": "Nie ma różnicy, to synonimy",
          "correct": false
        },
        {
          "uk": "stopPropagation() зупиняє поширення, stopImmediatePropagation() також скасовує інші обробники на елементі",
          "en": "stopPropagation() stops propagation, stopImmediatePropagation() also cancels other handlers on element",
          "pl": "stopPropagation() zatrzymuje propagację, stopImmediatePropagation() także anuluje inne handlery na elemencie",
          "correct": true
        },
        {
          "uk": "stopImmediatePropagation() працює тільки для touch events",
          "en": "stopImmediatePropagation() works only for touch events",
          "pl": "stopImmediatePropagation() działa tylko dla zdarzeń dotykowych",
          "correct": false
        },
        {
          "uk": "stopPropagation() застаріла версія",
          "en": "stopPropagation() is the deprecated version",
          "pl": "stopPropagation() to przestarzała wersja",
          "correct": false
        }
      ]
    },
    {
      "id": "js-q20",
      "order": 20,
      "difficulty": "medium",
      "uk": {
        "q": "Що таке event delegation і навіщо воно потрібне?",
        "exp": "Event delegation — техніка додавання одного обробника на батьківський елемент замість багатьох на дочірні. Ефективніше для динамічних елементів."
      },
      "en": {
        "q": "What is event delegation and why is it needed?",
        "exp": "Event delegation is a technique of adding one handler to a parent element instead of many to children. More efficient for dynamic elements."
      },
      "pl": {
        "q": "Czym jest delegacja zdarzeń i po co jest potrzebna?",
        "exp": "Delegacja zdarzeń to technika dodawania jednego handlera do elementu nadrzędnego zamiast wielu do potomnych. Bardziej wydajna dla elementów dynamicznych."
      },
      "answers": [
        {
          "uk": "Спосіб передати обробник події іншому розробнику",
          "en": "A way to pass event handler to another developer",
          "pl": "Sposób na przekazanie handlera zdarzenia innemu programiście",
          "correct": false
        },
        {
          "uk": "Техніка додавання одного обробника на батьківський елемент для обробки подій дочірніх",
          "en": "Technique of adding one handler to parent element to handle child events",
          "pl": "Technika dodawania jednego handlera do elementu nadrzędnego do obsługi zdarzeń potomnych",
          "correct": true
        },
        {
          "uk": "Автоматичне створення обробників для нових елементів",
          "en": "Automatic creation of handlers for new elements",
          "pl": "Automatyczne tworzenie handlerów dla nowych elementów",
          "correct": false
        },
        {
          "uk": "Метод делегування обробки помилок",
          "en": "Method for delegating error handling",
          "pl": "Metoda delegowania obsługi błędów",
          "correct": false
        }
      ]
    }
  ]
}
