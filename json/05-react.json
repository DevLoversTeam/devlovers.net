[
  {
    "category": "react",
    "order": 1,
    "translations": {
      "uk": {
        "question": "1. Що таке React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React",
                "bold": true
              },
              {
                "text": " — це JavaScript-бібліотека для створення користувацьких інтерфейсів. Основні характеристики:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Компонентний підхід:",
                    "bold": true
                  },
                  {
                    "text": " UI розбивається на незалежні компоненти, які можна повторно використовувати."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Virtual DOM:",
                    "bold": true
                  },
                  {
                    "text": " Оптимізує оновлення інтерфейсу, зменшуючи кількість операцій з реальним DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Декларативність:",
                    "bold": true
                  },
                  {
                    "text": " Ви описуєте бажаний стан UI, а React самостійно приводить його у відповідність."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Однонаправлений потік даних:",
                    "bold": true
                  },
                  {
                    "text": " Дані передаються від батьківських компонентів до дочірніх через props."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React був створений Facebook і широко застосовується для розробки SPA."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "1. What is React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React",
                "bold": true
              },
              {
                "text": " is a JavaScript library for building user interfaces. Key characteristics:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Component-based approach:",
                    "bold": true
                  },
                  {
                    "text": " The UI is split into reusable, independent components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Virtual DOM:",
                    "bold": true
                  },
                  {
                    "text": " Improves performance by minimizing direct updates to the real DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Declarative nature:",
                    "bold": true
                  },
                  {
                    "text": " You describe how the UI should look for a given state, and React handles the updates."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "One-way data flow:",
                    "bold": true
                  },
                  {
                    "text": " Data flows from parent to child components via props."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React was created by Facebook and is widely used for building Single Page Applications."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "1. Czym jest React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React",
                "bold": true
              },
              {
                "text": " to biblioteka JavaScript służąca do tworzenia interfejsów użytkownika. Główne cechy:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Podejście komponentowe:",
                    "bold": true
                  },
                  {
                    "text": " Interfejs jest podzielony na niezależne, wielokrotnego użytku komponenty."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Virtual DOM:",
                    "bold": true
                  },
                  {
                    "text": " Zwiększa wydajność poprzez ograniczenie operacji na rzeczywistym DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Deklaratywność:",
                    "bold": true
                  },
                  {
                    "text": " Opisujesz docelowy wygląd UI, a React sam dba o aktualizacje."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jednokierunkowy przepływ danych:",
                    "bold": true
                  },
                  {
                    "text": " Dane są przekazywane z komponentów nadrzędnych do podrzędnych przez props."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React został stworzony przez Facebook i jest szeroko używany do tworzenia aplikacji SPA."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 2,
    "translations": {
      "uk": {
        "question": "2. Перерахуйте особливості React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Компонентний підхід:", "bold": true },
                  {
                    "text": " Код розділений на багаторазові, незалежні компоненти."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Віртуальний DOM:", "bold": true },
                  {
                    "text": " Швидке оновлення інтерфейсу без прямої роботи з реальним DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Односпрямований потік даних:", "bold": true },
                  { "text": " Дані передаються зверху вниз через props." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX:", "bold": true },
                  { "text": " Синтаксичне розширення JavaScript для опису UI." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Стан і життєвий цикл:", "bold": true },
                  {
                    "text": " Компоненти керують власним станом і фазами життя."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Hooks:", "bold": true },
                  {
                    "text": " Робота зі станом і side effects у функціональних компонентах."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Екосистема:", "bold": true },
                  {
                    "text": " Інтеграція з бібліотеками на кшталт React Router і Redux."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO-френдлі:", "bold": true },
                  { "text": " Підтримка SSR через Next.js." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Мобільна розробка:", "bold": true },
                  {
                    "text": " React Native для створення мобільних застосунків."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відкритий код:", "bold": true },
                  { "text": " Активна спільнота та публічна розробка." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "2. List the key features of React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Component-based approach:", "bold": true },
                  {
                    "text": " Code is split into reusable, independent components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Virtual DOM:", "bold": true },
                  {
                    "text": " Fast UI updates without direct manipulation of the real DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "One-way data flow:", "bold": true },
                  { "text": " Data flows top-down via props." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX:", "bold": true },
                  { "text": " JavaScript syntax extension for describing UI." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "State and lifecycle:", "bold": true },
                  {
                    "text": " Components manage their own state and lifecycle phases."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Hooks:", "bold": true },
                  {
                    "text": " Enable state and side effects in functional components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ecosystem:", "bold": true },
                  {
                    "text": " Integration with libraries like React Router and Redux."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO-friendly:", "bold": true },
                  { "text": " Server-side rendering via Next.js." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mobile development:", "bold": true },
                  { "text": " React Native for building mobile apps." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Open source:", "bold": true },
                  { "text": " Actively maintained by the community." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "2. Wymień główne cechy React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Podejście komponentowe:", "bold": true },
                  {
                    "text": " Kod podzielony na niezależne, wielokrotnego użytku komponenty."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Virtual DOM:", "bold": true },
                  {
                    "text": " Szybkie aktualizacje interfejsu bez bezpośredniej pracy z DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jednokierunkowy przepływ danych:", "bold": true },
                  { "text": " Dane przekazywane z góry na dół przez props." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX:", "bold": true },
                  { "text": " Rozszerzenie składni JavaScript do opisu UI." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Stan i cykl życia:", "bold": true },
                  {
                    "text": " Komponenty zarządzają własnym stanem i cyklem życia."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Hooks:", "bold": true },
                  {
                    "text": " Obsługa stanu i efektów ubocznych w komponentach funkcyjnych."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ekosystem:", "bold": true },
                  {
                    "text": " Wsparcie dla bibliotek takich jak React Router i Redux."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO-friendly:", "bold": true },
                  { "text": " Renderowanie po stronie serwera dzięki Next.js." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tworzenie aplikacji mobilnych:", "bold": true },
                  { "text": " React Native do budowy aplikacji mobilnych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Open source:", "bold": true },
                  { "text": " Aktywne wsparcie społeczności." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 3,
    "translations": {
      "uk": {
        "question": "3. Які основні функції React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні функції React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Декларативний підхід:", "bold": true },
                  {
                    "text": " Описує, як має виглядати UI, а React сам оптимізує оновлення DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Компонентна структура:", "bold": true },
                  {
                    "text": " Побудова додатка з незалежних, багаторазових компонентів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Віртуальний DOM:", "bold": true },
                  {
                    "text": " Ефективне оновлення реального DOM для підвищення продуктивності."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Односпрямований потік даних:", "bold": true },
                  {
                    "text": " Передача даних від батьківських компонентів до дочірніх через props."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Хуки (Hooks):", "bold": true },
                  {
                    "text": " Використання стану та життєвого циклу у функціональних компонентах."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX:", "bold": true },
                  {
                    "text": " Розширення JavaScript для опису UI у синтаксисі, схожому на HTML."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Native:", "bold": true },
                  {
                    "text": " Створення нативних мобільних додатків на базі React."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Екосистема:", "bold": true },
                  {
                    "text": " Набір бібліотек і інструментів, таких як React Router, Redux, Context API."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Підтримка SSR:", "bold": true },
                  {
                    "text": " Серверний рендеринг для покращення SEO та швидкого старту."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Управління станом:", "bold": true },
                  { "text": " useState, Context API, Redux та інші рішення." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ці можливості формують основу React як бібліотеки для сучасних інтерфейсів."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "3. What are the main functions of React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core functions of React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Declarative approach:", "bold": true },
                  {
                    "text": " Describes how the UI should look, while React handles DOM updates."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Component architecture:", "bold": true },
                  {
                    "text": " Applications are built from reusable, independent components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Virtual DOM:", "bold": true },
                  {
                    "text": " Efficient updates to the real DOM to improve performance."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "One-way data flow:", "bold": true },
                  {
                    "text": " Data flows from parent to child components via props."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hooks:", "bold": true },
                  {
                    "text": " Enable state and lifecycle logic in functional components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX:", "bold": true },
                  {
                    "text": " JavaScript extension for describing UI using HTML-like syntax."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Native:", "bold": true },
                  {
                    "text": " Building native mobile applications using React principles."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ecosystem:", "bold": true },
                  {
                    "text": " Libraries and tools such as React Router, Redux, and Context API."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SSR support:", "bold": true },
                  {
                    "text": " Server-side rendering for better SEO and faster initial load."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "State management:", "bold": true },
                  {
                    "text": " useState, Context API, Redux, and other solutions."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "These functions define React as a flexible UI library."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "3. Jakie są główne funkcje React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne funkcje React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Podejście deklaratywne:", "bold": true },
                  { "text": " Opisuje wygląd UI, a React sam aktualizuje DOM." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Struktura komponentowa:", "bold": true },
                  {
                    "text": " Aplikacje budowane są z niezależnych, wielokrotnego użytku komponentów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Virtual DOM:", "bold": true },
                  {
                    "text": " Wydajne aktualizacje rzeczywistego DOM poprawiające wydajność."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jednokierunkowy przepływ danych:", "bold": true },
                  {
                    "text": " Dane przekazywane z komponentów nadrzędnych do podrzędnych przez props."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hooki:", "bold": true },
                  {
                    "text": " Obsługa stanu i cyklu życia w komponentach funkcyjnych."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX:", "bold": true },
                  {
                    "text": " Rozszerzenie JavaScript do opisu UI w składni podobnej do HTML."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Native:", "bold": true },
                  { "text": " Tworzenie natywnych aplikacji mobilnych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ekosystem:", "bold": true },
                  {
                    "text": " Biblioteki i narzędzia takie jak React Router, Redux, Context API."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wsparcie SSR:", "bold": true },
                  {
                    "text": " Renderowanie po stronie serwera dla SEO i szybkiego startu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zarządzanie stanem:", "bold": true },
                  {
                    "text": " useState, Context API, Redux i inne rozwiązania."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Funkcje te definiują React jako nowoczesną bibliotekę UI."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 4,
    "translations": {
      "uk": {
        "question": "4. Які ключові переваги використання React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові переваги використання React" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Швидкість", "bold": true },
                  {
                    "text": ": Virtual DOM зменшує кількість операцій з реальним DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Компонентний підхід", "bold": true },
                  {
                    "text": ": Повторно використовувані компоненти спрощують підтримку коду."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Одностороння передача даних", "bold": true },
                  { "text": ": Прогнозований потік даних полегшує дебагінг." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Велика спільнота", "bold": true },
                  { "text": ": Широка екосистема бібліотек та інструментів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Мобільна розробка", "bold": true },
                  { "text": ": React Native для кросплатформених застосунків." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX", "bold": true },
                  {
                    "text": ": Поєднання JavaScript і HTML підвищує читабельність."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Хуки", "bold": true },
                  { "text": ": Просте управління станом і життєвим циклом." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO-дружність", "bold": true },
                  { "text": ": SSR через Next.js покращує індексацію." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Гнучкість", "bold": true },
                  { "text": ": Легка інтеграція в існуючі проєкти." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React DevTools", "bold": true },
                  { "text": ": Зручне налагодження компонентів і стану." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "4. What are the key advantages of using React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key advantages of using React" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Performance", "bold": true },
                  { "text": ": Virtual DOM reduces direct DOM operations." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Component-based", "bold": true },
                  { "text": ": Reusable components simplify maintenance." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "One-way data flow", "bold": true },
                  { "text": ": Predictable data flow eases debugging." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Large community", "bold": true },
                  { "text": ": Rich ecosystem of libraries and tools." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mobile compatibility", "bold": true },
                  { "text": ": React Native enables cross-platform apps." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX", "bold": true },
                  { "text": ": Combines JavaScript and HTML for clarity." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hooks support", "bold": true },
                  { "text": ": Simplified state and lifecycle handling." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO-friendly", "bold": true },
                  { "text": ": Server-side rendering with Next.js." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Flexibility", "bold": true },
                  { "text": ": Easy integration into existing projects." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React DevTools", "bold": true },
                  { "text": ": Efficient debugging of components and state." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "4. Jakie są kluczowe zalety korzystania z React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kluczowe zalety korzystania z React" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wydajność", "bold": true },
                  {
                    "text": ": Virtual DOM ogranicza operacje na prawdziwym DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podejście komponentowe", "bold": true },
                  {
                    "text": ": Komponenty wielokrotnego użytku ułatwiają utrzymanie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jednokierunkowy przepływ danych", "bold": true },
                  { "text": ": Przewidywalny model ułatwia debugowanie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Duża społeczność", "bold": true },
                  { "text": ": Bogaty ekosystem bibliotek i narzędzi." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aplikacje mobilne", "bold": true },
                  { "text": ": React Native dla aplikacji wieloplatformowych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX", "bold": true },
                  { "text": ": Czytelne łączenie JavaScript i HTML." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hooki", "bold": true },
                  { "text": ": Proste zarządzanie stanem i cyklem życia." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO-friendly", "bold": true },
                  { "text": ": Renderowanie po stronie serwera z Next.js." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Elastyczność", "bold": true },
                  { "text": ": Łatwa integracja z innymi projektami." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React DevTools", "bold": true },
                  { "text": ": Skuteczne narzędzie do debugowania." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 5,
    "translations": {
      "uk": {
        "question": "5. Що таке JSX?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "JSX (JavaScript XML)", "bold": true },
              {
                "text": " — це синтаксис, який дозволяє описувати UI у вигляді XML-подібного коду всередині JavaScript. Використовується в React для опису інтерфейсу."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні особливості JSX:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "XML-подібний синтаксис:", "bold": true },
                  { "text": " Схожий на HTML, але є частиною JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вбудований JavaScript:", "bold": true },
                  { "text": " Вирази JavaScript вставляються через {}." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Трансляція:", "bold": true },
                  {
                    "text": " JSX компілюється у звичайний JavaScript за допомогою Babel."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Атрибути:", "bold": true },
                  {
                    "text": " Використовуються camelCase-імена, наприклад className, htmlFor."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Один кореневий елемент:", "bold": true },
                  {
                    "text": " JSX-вираз повинен повертати один кореневий елемент або Fragment."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Читабельний синтаксис." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Тісна інтеграція з логікою JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Зручне створення UI-компонентів." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "JSX не є обовʼязковим, але практично стандартом у React-проєктах."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "5. What is JSX?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "JSX (JavaScript XML)", "bold": true },
              {
                "text": " is a syntax extension that allows writing UI structures using XML-like code inside JavaScript. It is used in React to describe the UI."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key features of JSX:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "XML-like syntax:", "bold": true },
                  { "text": " Similar to HTML but embedded in JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Embedded JavaScript:", "bold": true },
                  { "text": " JavaScript expressions are written inside {}." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Compilation:", "bold": true },
                  {
                    "text": " JSX is compiled into plain JavaScript using Babel."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Attributes:", "bold": true },
                  {
                    "text": " Uses camelCase names like className and htmlFor."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Single root element:", "bold": true },
                  {
                    "text": " JSX expressions must return one root element or a Fragment."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Readable syntax." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tight integration with JavaScript logic." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Convenient UI component creation." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "JSX is optional but widely adopted in React projects."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "5. Czym jest JSX?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "JSX (JavaScript XML)", "bold": true },
              {
                "text": " to rozszerzenie składni umożliwiające zapisywanie struktury UI w formie podobnej do XML wewnątrz JavaScript. Jest używane w React do opisu interfejsu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne cechy JSX:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Składnia podobna do XML:", "bold": true },
                  { "text": " Przypomina HTML, ale działa w JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wbudowany JavaScript:", "bold": true },
                  { "text": " Wyrażenia JavaScript umieszcza się w {}." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kompilacja:", "bold": true },
                  {
                    "text": " JSX jest transpilowany do czystego JavaScript przez Babel."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Atrybuty:", "bold": true },
                  {
                    "text": " Stosowane są nazwy camelCase, np. className, htmlFor."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jeden element nadrzędny:", "bold": true },
                  {
                    "text": " JSX musi zwracać jeden element główny lub Fragment."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Czytelna składnia." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ścisła integracja z logiką JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Wygodne tworzenie komponentów UI." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "JSX nie jest wymagany, ale powszechnie stosowany w projektach React."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 6,
    "translations": {
      "uk": {
        "question": "6. Різниця між станом (state) та пропсами (props)?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Різниця між станом (state) та пропсами (props)" }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Критерій" }],
              [{ "text": "State" }],
              [{ "text": "Props" }]
            ],
            "rows": [
              [
                [{ "text": "Призначення", "bold": true }],
                [{ "text": "Зберігає внутрішній стан компонента." }],
                [
                  {
                    "text": "Передає дані від батьківського компонента до дочірнього."
                  }
                ]
              ],
              [
                [{ "text": "Змінюваність", "bold": true }],
                [{ "text": "Може змінюватися всередині компонента." }],
                [{ "text": "Незмінні (read-only)." }]
              ],
              [
                [{ "text": "Доступність", "bold": true }],
                [{ "text": "Доступний лише в компоненті, де визначений." }],
                [{ "text": "Доступний у дочірньому компоненті." }]
              ],
              [
                [{ "text": "Ініціалізація", "bold": true }],
                [{ "text": "Встановлюється через useState або конструктор." }],
                [{ "text": "Передається з батьківського компонента." }]
              ],
              [
                [{ "text": "Область використання", "bold": true }],
                [{ "text": "Для динамічних даних, що змінюються." }],
                [{ "text": "Для передачі даних між компонентами." }]
              ],
              [
                [{ "text": "Хто керує?", "bold": true }],
                [{ "text": "Поточний компонент." }],
                [{ "text": "Батьківський компонент." }]
              ]
            ]
          }
        ]
      },
      "en": {
        "question": "6. What is the difference between state and props?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Difference between state and props" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Criteria" }],
              [{ "text": "State" }],
              [{ "text": "Props" }]
            ],
            "rows": [
              [
                [{ "text": "Purpose", "bold": true }],
                [{ "text": "Stores internal component data." }],
                [{ "text": "Passes data from parent to child component." }]
              ],
              [
                [{ "text": "Mutability", "bold": true }],
                [{ "text": "Can be changed within the component." }],
                [{ "text": "Immutable (read-only)." }]
              ],
              [
                [{ "text": "Accessibility", "bold": true }],
                [{ "text": "Available only inside the owning component." }],
                [{ "text": "Accessible in child components." }]
              ],
              [
                [{ "text": "Initialization", "bold": true }],
                [{ "text": "Initialized via useState or constructor." }],
                [{ "text": "Defined by the parent component." }]
              ],
              [
                [{ "text": "Usage scope", "bold": true }],
                [{ "text": "For dynamic, changeable data." }],
                [{ "text": "For passing static or dynamic data." }]
              ],
              [
                [{ "text": "Who controls it?", "bold": true }],
                [{ "text": "The component itself." }],
                [{ "text": "The parent component." }]
              ]
            ]
          }
        ]
      },
      "pl": {
        "question": "6. Jaka jest różnica między state a props?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Różnica między state a props" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Kryterium" }],
              [{ "text": "State" }],
              [{ "text": "Props" }]
            ],
            "rows": [
              [
                [{ "text": "Przeznaczenie", "bold": true }],
                [{ "text": "Przechowuje wewnętrzny stan komponentu." }],
                [{ "text": "Przekazuje dane z komponentu nadrzędnego." }]
              ],
              [
                [{ "text": "Zmienność", "bold": true }],
                [{ "text": "Może być zmieniany wewnątrz komponentu." }],
                [{ "text": "Niezmienne (read-only)." }]
              ],
              [
                [{ "text": "Dostępność", "bold": true }],
                [{ "text": "Dostępny tylko w komponencie właścicielu." }],
                [{ "text": "Dostępny w komponentach podrzędnych." }]
              ],
              [
                [{ "text": "Inicjalizacja", "bold": true }],
                [{ "text": "Ustawiany przez useState lub konstruktor." }],
                [{ "text": "Określany przez komponent nadrzędny." }]
              ],
              [
                [{ "text": "Zakres użycia", "bold": true }],
                [{ "text": "Dla danych dynamicznych." }],
                [{ "text": "Do przekazywania danych między komponentami." }]
              ],
              [
                [{ "text": "Kto kontroluje?", "bold": true }],
                [{ "text": "Sam komponent." }],
                [{ "text": "Komponent nadrzędny." }]
              ]
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 7,
    "translations": {
      "uk": {
        "question": "7. Яка різниця між елементом і компонентом?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Різниця між елементом і компонентом у React:" }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Критерій" }],
              [{ "text": "Елемент" }],
              [{ "text": "Компонент" }]
            ],
            "rows": [
              [
                [{ "text": "Визначення", "bold": true }],
                [{ "text": "Обʼєкт, що описує вигляд інтерфейсу." }],
                [{ "text": "Функція або клас, який повертає React-елементи." }]
              ],
              [
                [{ "text": "Тип", "bold": true }],
                [{ "text": "Нероздільний та незмінний (immutable)." }],
                [{ "text": "Багаторазовий, може мати стан." }]
              ],
              [
                [{ "text": "Синтаксис створення", "bold": true }],
                [{ "text": "JSX або React.createElement." }],
                [{ "text": "Функція або клас компонента." }]
              ],
              [
                [{ "text": "Призначення", "bold": true }],
                [{ "text": "Представляє окремий вузол UI." }],
                [{ "text": "Інкапсулює структуру та логіку UI." }]
              ],
              [
                [{ "text": "Використання", "bold": true }],
                [{ "text": "Базовий опис інтерфейсу." }],
                [{ "text": "Побудова складних частин додатка." }]
              ],
              [
                [{ "text": "Приклад", "bold": true }],
                [{ "text": "<h1>Hello</h1>", "code": true }],
                [
                  {
                    "text": "function Hello() { return <h1>Hello</h1>; }",
                    "code": true
                  }
                ]
              ]
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Елемент є результатом, компонент є фабрикою для їх створення."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "7. What is the difference between an element and a component?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Difference between an element and a component in React:"
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Criteria" }],
              [{ "text": "Element" }],
              [{ "text": "Component" }]
            ],
            "rows": [
              [
                [{ "text": "Definition", "bold": true }],
                [
                  {
                    "text": "An object describing what the UI should look like."
                  }
                ],
                [{ "text": "A function or class that returns React elements." }]
              ],
              [
                [{ "text": "Type", "bold": true }],
                [{ "text": "Immutable." }],
                [{ "text": "Reusable and may have state." }]
              ],
              [
                [{ "text": "Creation syntax", "bold": true }],
                [{ "text": "JSX or React.createElement." }],
                [{ "text": "Function or class component." }]
              ],
              [
                [{ "text": "Purpose", "bold": true }],
                [{ "text": "Represents a single UI node." }],
                [{ "text": "Encapsulates UI structure and logic." }]
              ],
              [
                [{ "text": "Usage", "bold": true }],
                [{ "text": "Low-level UI description." }],
                [{ "text": "Building complex UI with logic." }]
              ],
              [
                [{ "text": "Example", "bold": true }],
                [{ "text": "<h1>Hello</h1>", "code": true }],
                [
                  {
                    "text": "function Hello() { return <h1>Hello</h1>; }",
                    "code": true
                  }
                ]
              ]
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "An element is the result, a component is the blueprint."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "7. Jaka jest różnica między elementem a komponentem?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Różnica między elementem a komponentem w React:" }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Kryterium" }],
              [{ "text": "Element" }],
              [{ "text": "Komponent" }]
            ],
            "rows": [
              [
                [{ "text": "Definicja", "bold": true }],
                [{ "text": "Obiekt opisujący wygląd interfejsu." }],
                [{ "text": "Funkcja lub klasa zwracająca elementy React." }]
              ],
              [
                [{ "text": "Typ", "bold": true }],
                [{ "text": "Niezmienny (immutable)." }],
                [{ "text": "Wielokrotnego użytku, może posiadać stan." }]
              ],
              [
                [{ "text": "Sposób tworzenia", "bold": true }],
                [{ "text": "JSX lub React.createElement." }],
                [{ "text": "Komponent funkcyjny lub klasowy." }]
              ],
              [
                [{ "text": "Przeznaczenie", "bold": true }],
                [{ "text": "Pojedynczy element UI." }],
                [{ "text": "Logika i struktura interfejsu." }]
              ],
              [
                [{ "text": "Zastosowanie", "bold": true }],
                [{ "text": "Podstawowy opis UI." }],
                [{ "text": "Budowa złożonych części aplikacji." }]
              ],
              [
                [{ "text": "Przykład", "bold": true }],
                [{ "text": "<h1>Hello</h1>", "code": true }],
                [
                  {
                    "text": "function Hello() { return <h1>Hello</h1>; }",
                    "code": true
                  }
                ]
              ]
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Element to wynik, komponent to mechanizm jego tworzenia."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 8,
    "translations": {
      "uk": {
        "question": "8. Як створити компоненти в React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "У React компоненти можна створювати двома способами:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Функціональний компонент:", "bold": true },
                  { "text": " Функція, яка повертає React-елементи." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Greeting(props) {\n  return <>Hello, {props.name}!</>;\n}\n\n// Використання:\n<Greeting name=\"Alice\" />;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Класовий компонент:", "bold": true },
                  {
                    "text": " Клас, що успадковується від React.Component і має метод render."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class Greeting extends React.Component {\n  render() {\n    return <>Hello, {this.props.name}!</>;\n  }\n}\n\n// Використання:\n<Greeting name=\"Alice\" />;"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Відмінності:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Функціональні компоненти простіші та рекомендовані за замовчуванням."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Класові компоненти використовуються рідко та вважаються застарілими."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Примітка:", "bold": true },
              {
                "text": " Сучасний підхід використовує функціональні компоненти з хуками."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "8. How to create components in React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "In React, components can be created in two ways:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Functional component:", "bold": true },
                  { "text": " A function that returns React elements." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Greeting(props) {\n  return <>Hello, {props.name}!</>;\n}\n\n// Usage:\n<Greeting name=\"Alice\" />;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Class component:", "bold": true },
                  {
                    "text": " A class extending React.Component with a render method."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class Greeting extends React.Component {\n  render() {\n    return <>Hello, {this.props.name}!</>;\n  }\n}\n\n// Usage:\n<Greeting name=\"Alice\" />;"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Differences:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Functional components are simpler and preferred." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Class components are mostly legacy." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Note:", "bold": true },
              {
                "text": " Modern React favors functional components with hooks."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "8. Jak tworzyć komponenty w React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "W React komponenty można tworzyć na dwa sposoby:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponent funkcyjny:", "bold": true },
                  { "text": " Funkcja zwracająca elementy React." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Greeting(props) {\n  return <>Hello, {props.name}!</>;\n}\n\n// Użycie:\n<Greeting name=\"Alice\" />;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponent klasowy:", "bold": true },
                  {
                    "text": " Klasa dziedzicząca po React.Component z metodą render."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class Greeting extends React.Component {\n  render() {\n    return <>Hello, {this.props.name}!</>;\n  }\n}\n\n// Użycie:\n<Greeting name=\"Alice\" />;"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Różnice:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponenty funkcyjne są prostsze i zalecane." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponenty klasowe są obecnie rzadko używane." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Uwaga:", "bold": true },
              {
                "text": " Współczesny React opiera się na komponentach funkcyjnych i hookach."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 9,
    "translations": {
      "uk": {
        "question": "9. Що таке стан (state) у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Стан (state)", "bold": true },
              {
                "text": " у React — це обʼєкт для зберігання даних, що змінюються з часом і впливають на рендеринг компонента. Він робить компоненти динамічними та реактивними."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Особливості стану:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Локальний для компонента:", "bold": true },
                  { "text": " Доступний лише в компоненті, де визначений." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Асинхронні оновлення:", "bold": true },
                  {
                    "text": " Оновлення стану можуть бути згруповані React для оптимізації."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ініціалізація:", "bold": true },
                  {
                    "text": " Через useState у функціональних або в конструкторі класових компонентів."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "У класових компонентах:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </>\n    );\n  }\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "У функціональних компонентах (useState):" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </>\n  );\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коротко:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "State", "bold": true },
                  { "text": " — локальний і змінюваний." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Props", "bold": true },
                  { "text": " — передаються ззовні та незмінні." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "9. What is state in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "State", "bold": true },
              {
                "text": " in React is an object used to store data that changes over time and affects component rendering. It enables components to be dynamic and reactive."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "State characteristics:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Component-local:", "bold": true },
                  { "text": " Available only within the owning component." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Asynchronous updates:", "bold": true },
                  { "text": " State updates may be batched by React." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Initialization:", "bold": true },
                  { "text": " Via useState or a class constructor." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Class component example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </>\n    );\n  }\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Functional component (useState):" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </>\n  );\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In short:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "State", "bold": true },
                  { "text": " is local and mutable." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Props", "bold": true },
                  { "text": " are external and immutable." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "9. Czym jest state w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "State", "bold": true },
              {
                "text": " w React to obiekt służący do przechowywania danych, które zmieniają się w czasie i wpływają na renderowanie komponentu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Cechy state:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lokalny:", "bold": true },
                  { "text": " Dostępny tylko w danym komponencie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aktualizacje asynchroniczne:", "bold": true },
                  { "text": " React może grupować aktualizacje stanu." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Inicjalizacja:", "bold": true },
                  {
                    "text": " Przez useState lub konstruktor komponentu klasowego."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład komponentu klasowego:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </>\n    );\n  }\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Komponent funkcyjny (useState):" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </>\n  );\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W skrócie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "State", "bold": true },
                  { "text": " jest lokalny i zmienny." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Props", "bold": true },
                  { "text": " są przekazywane i niezmienne." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 10,
    "translations": {
      "uk": {
        "question": "10. Що таке пропси (props) в React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Пропси (props)", "bold": true },
              {
                "text": " в React — це обʼєкт із даними, які передаються від батьківського компонента до дочірнього. Вони використовуються для налаштування компонентів і є незмінними."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Особливості пропсів:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Передаються зверху вниз:", "bold": true },
                  {
                    "text": " Дані надходять від батьківського компонента до дочірнього."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Незмінні:", "bold": true },
                  { "text": " Компонент не може змінювати отримані props." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Динамічні:", "bold": true },
                  {
                    "text": " Оновлюються при зміні даних у батьківському компоненті."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використання пропсів:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Функціональний компонент:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Welcome(props) {\n  return <>Hello, {props.name}!</>;\n}\n\n<Welcome name=\"Alice\" />;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Класовий компонент:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class Welcome extends React.Component {\n  render() {\n    return <>Hello, {this.props.name}!</>;\n  }\n}\n\n<Welcome name=\"Bob\" />;"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Деструктуризація пропсів:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Welcome({ name }) {\n  return <>Hello, {name}!</>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Значення за замовчуванням:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Welcome({ name = 'Guest' }) {\n  return <>Hello, {name}!</>;\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Props забезпечують повторне використання та конфігурацію компонентів."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "10. What are props in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Props", "bold": true },
              {
                "text": " in React are an object containing data passed from a parent component to a child component. They are used to configure components and are immutable."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Props characteristics:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Top-down flow:", "bold": true },
                  { "text": " Data flows from parent to child components." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Immutable:", "bold": true },
                  { "text": " Child components cannot modify props." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dynamic:", "bold": true },
                  { "text": " Values change when parent data changes." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Using props:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Functional component:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Welcome(props) {\n  return <>Hello, {props.name}!</>;\n}\n\n<Welcome name=\"Alice\" />;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Class component:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class Welcome extends React.Component {\n  render() {\n    return <>Hello, {this.props.name}!</>;\n  }\n}\n\n<Welcome name=\"Bob\" />;"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Props destructuring:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Welcome({ name }) {\n  return <>Hello, {name}!</>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Default props values:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Welcome({ name = 'Guest' }) {\n  return <>Hello, {name}!</>;\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Props enable configuration and reuse of React components."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "10. Czym są props w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Props", "bold": true },
              {
                "text": " w React to obiekt z danymi przekazywanymi z komponentu nadrzędnego do podrzędnego. Służą do konfiguracji komponentów i są niezmienne."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Cechy props:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Przepływ z góry na dół:", "bold": true },
                  { "text": " Dane przekazywane są z rodzica do dziecka." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Niezmienność:", "bold": true },
                  { "text": " Komponent nie może modyfikować props." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dynamiczność:", "bold": true },
                  { "text": " Aktualizują się wraz ze zmianą danych rodzica." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Użycie props:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponent funkcyjny:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Welcome(props) {\n  return <>Hello, {props.name}!</>;\n}\n\n<Welcome name=\"Alice\" />;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponent klasowy:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class Welcome extends React.Component {\n  render() {\n    return <>Hello, {this.props.name}!</>;\n  }\n}\n\n<Welcome name=\"Bob\" />;"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Destrukturyzacja props:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Welcome({ name }) {\n  return <>Hello, {name}!</>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wartości domyślne:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Welcome({ name = 'Guest' }) {\n  return <>Hello, {name}!</>;\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Props zapewniają elastyczność i możliwość ponownego użycia komponentów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 11,
    "translations": {
      "uk": {
        "question": "11. Навіщо потрібен атрибут key при рендері списків?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Атрибут ", "bold": false },
              { "text": "key", "code": true },
              {
                "text": " використовується для ідентифікації елементів у списках під час рендерингу."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Призначення:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Оптимізація оновлень:", "boldItalic": true },
                  { "text": " React використовує " },
                  { "text": "key", "code": true },
                  {
                    "text": " для визначення, які елементи було змінено, додано або видалено."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Запобігання зайвим рендерам:",
                    "boldItalic": true
                  },
                  { "text": " " },
                  { "text": "key", "code": true },
                  {
                    "text": " дозволяє повторно використовувати незмінені елементи."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Збереження стану компонентів:",
                    "boldItalic": true
                  },
                  { "text": " Правильний " },
                  { "text": "key", "code": true },
                  {
                    "text": " допомагає зберігати внутрішній стан елементів списку."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Правильне використання:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Значення ", "bold": false },
                  { "text": "key", "code": true },
                  { "text": " має бути унікальним серед сусідніх елементів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Використовуйте стабільні ідентифікатори, наприклад ",
                    "bold": false
                  },
                  { "text": "id", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Не рекомендується використовувати індекс масиву як ",
                    "bold": false
                  },
                  { "text": "key", "code": true },
                  { "text": " при змінному порядку елементів." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "11. Why is the key attribute needed when rendering lists?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "The ", "bold": false },
              { "text": "key", "code": true },
              {
                "text": " attribute is used to uniquely identify elements in a list during rendering."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Purpose:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Update optimization:", "boldItalic": true },
                  { "text": " React uses " },
                  { "text": "key", "code": true },
                  {
                    "text": " to detect which elements were changed, added, or removed."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Avoiding unnecessary re-renders:",
                    "boldItalic": true
                  },
                  { "text": " " },
                  { "text": "key", "code": true },
                  { "text": " helps reuse unchanged elements." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Preserving component state:", "boldItalic": true },
                  { "text": " A correct " },
                  { "text": "key", "code": true },
                  {
                    "text": " allows React to preserve component state between renders."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Best practices:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "The ", "bold": false },
                  { "text": "key", "code": true },
                  { "text": " value must be unique among siblings." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Prefer stable identifiers such as ",
                    "bold": false
                  },
                  { "text": "id", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Avoid using array index as ", "bold": false },
                  { "text": "key", "code": true },
                  { "text": " when list order can change." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "11. Dlaczego atrybut key jest potrzebny przy renderowaniu list?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Atrybut ", "bold": false },
              { "text": "key", "code": true },
              {
                "text": " służy do jednoznacznej identyfikacji elementów listy podczas renderowania."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Cel:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Optymalizacja aktualizacji:", "boldItalic": true },
                  { "text": " React używa " },
                  { "text": "key", "code": true },
                  { "text": " do określenia zmian w liście." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Unikanie zbędnych renderów:", "boldItalic": true },
                  { "text": " " },
                  { "text": "key", "code": true },
                  { "text": " pozwala ponownie użyć niezmienionych elementów." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zachowanie stanu komponentów:",
                    "boldItalic": true
                  },
                  { "text": " Poprawny " },
                  { "text": "key", "code": true },
                  { "text": " umożliwia zachowanie stanu między renderami." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dobre praktyki:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wartość ", "bold": false },
                  { "text": "key", "code": true },
                  { "text": " musi być unikalna wśród elementów sąsiednich." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Najlepiej używać stabilnych identyfikatorów, np. ",
                    "bold": false
                  },
                  { "text": "id", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Nie zaleca się używania indeksu tablicy jako ",
                    "bold": false
                  },
                  { "text": "key", "code": true },
                  { "text": " przy zmiennej kolejności elementów." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 12,
    "translations": {
      "uk": {
        "question": "12. Як передаються дані між компонентами у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У React передача даних відбувається відповідно до ієрархії компонентів."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Передача даних вниз (parent → child)" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Для цього використовуються ", "bold": false },
              { "text": "props", "code": true },
              {
                "text": ". Батьківський компонент передає дані або функції дочірньому через атрибути."
              }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Parent() {\n  const data = 'Hello from Parent';\n  return <Child message={data} />;\n}\n\nfunction Child({ message }) {\n  return <p>{message}</p>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Передача даних вгору (child → parent)" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовуються callback-функції, які передаються через props."
              }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Parent() {\n  const handleData.ensure = data => console.log(data);\n  return <Child sendData={handleData} />;\n}\n\nfunction Child({ sendData }) {\n  return <button onClick={() => sendData('Hello from Child')}>Send</button>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Альтернативи для складних додатків:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Context API:", "bold": true },
                  {
                    "text": " для передачі глобальних даних без prop drilling."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Менеджери стану:", "bold": true },
                  { "text": " Redux, Zustand, MobX для великих застосунків." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Custom Hooks:", "bold": true },
                  { "text": " для повторного використання логіки." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "12. How is data passed between components in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "In React, data flow follows the component hierarchy." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Passing data down (parent → child)" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "This is done using ", "bold": false },
              { "text": "props", "code": true },
              {
                "text": ". Parents pass data or functions to children via attributes."
              }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Parent() {\n  const data = 'Hello from Parent';\n  return <Child message={data} />;\n}\n\nfunction Child({ message }) {\n  return <p>{message}</p>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Passing data up (child → parent)" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Achieved using callback functions passed via props." }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Parent() {\n  const handleData = data => console.log(data);\n  return <Child sendData={handleData} />;\n}\n\nfunction Child({ sendData }) {\n  return <button onClick={() => sendData('Hello from Child')}>Send</button>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Alternatives for complex apps:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Context API:", "bold": true },
                  { "text": " for sharing global data without prop drilling." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "State managers:", "bold": true },
                  { "text": " Redux, Zustand, MobX for large applications." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Custom Hooks:", "bold": true },
                  { "text": " for sharing logic between components." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "12. Jak przekazywane są dane między komponentami w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W React przepływ danych odbywa się zgodnie z hierarchią komponentów."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Przekazywanie danych w dół (parent → child)" }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Do tego używa się ", "bold": false },
              { "text": "props", "code": true },
              { "text": ", przekazywanych jako atrybuty." }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Parent() {\n  const data = 'Hello from Parent';\n  return <Child message={data} />;\n}\n\nfunction Child({ message }) {\n  return <p>{message}</p>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Przekazywanie danych w górę (child → parent)" }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Realizowane za pomocą funkcji callback przekazywanych przez props."
              }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function Parent() {\n  const handleData = data => console.log(data);\n  return <Child sendData={handleData} />;\n}\n\nfunction Child({ sendData }) {\n  return <button onClick={() => sendData('Hello from Child')}>Send</button>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Alternatywy dla większych aplikacji:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Context API:", "bold": true },
                  { "text": " do przekazywania danych globalnych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Menedżery stanu:", "bold": true },
                  { "text": " Redux, Zustand, MobX w dużych projektach." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Custom Hooks:", "bold": true },
                  { "text": " do współdzielenia logiki." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 13,
    "translations": {
      "uk": {
        "question": "13. Чому React використовує className замість атрибута class?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "У React використовується ", "bold": false },
              { "text": "className", "code": true },
              { "text": " замість ", "bold": false },
              { "text": "class", "code": true },
              { "text": ", оскільки ", "bold": false },
              { "text": "class", "code": true },
              { "text": " є зарезервованим ключовим словом у JavaScript." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Причини:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Уникнення конфліктів:", "bold": true },
                  {
                    "text": " class використовується для оголошення класів у JavaScript."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Сумісність з JSX:", "bold": true },
                  {
                    "text": " JSX є розширенням JavaScript і дотримується його правил."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відповідність DOM API:", "bold": true },
                  {
                    "text": " У JavaScript властивість елемента називається className."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "// Коректно\n<div className=\"container\">Hello</div>\n\n// Некоректно\n<div class=\"container\">Hello</div>"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Це обовʼязковий стандарт JSX, а не дизайнерське рішення."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "13. Why does React use className instead of class?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React uses ", "bold": false },
              { "text": "className", "code": true },
              { "text": " instead of ", "bold": false },
              { "text": "class", "code": true },
              { "text": " because ", "bold": false },
              { "text": "class", "code": true },
              { "text": " is a reserved keyword in JavaScript." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Reasons:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Avoiding conflicts:", "bold": true },
                  { "text": " class is used to define JavaScript classes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX compatibility:", "bold": true },
                  { "text": " JSX follows JavaScript syntax rules." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "DOM API alignment:", "bold": true },
                  {
                    "text": " In JavaScript, the DOM property is called className."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "// Correct\n<div className=\"container\">Hello</div>\n\n// Incorrect\n<div class=\"container\">Hello</div>"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "This is a JSX requirement, not a stylistic choice." }
            ]
          }
        ]
      },
      "pl": {
        "question": "13. Dlaczego React używa className zamiast class?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React używa ", "bold": false },
              { "text": "className", "code": true },
              { "text": " zamiast ", "bold": false },
              { "text": "class", "code": true },
              { "text": ", ponieważ ", "bold": false },
              { "text": "class", "code": true },
              { "text": " jest słowem kluczowym w JavaScript." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Powody:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Unikanie konfliktów:", "bold": true },
                  { "text": " class służy do definiowania klas w JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zgodność z JSX:", "bold": true },
                  { "text": " JSX podlega regułom składni JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zgodność z DOM API:", "bold": true },
                  { "text": " W DOM właściwość nosi nazwę className." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "// Poprawnie\n<div className=\"container\">Hello</div>\n\n// Niepoprawnie\n<div class=\"container\">Hello</div>"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "To techniczny wymóg JSX, a nie decyzja projektowa." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 14,
    "translations": {
      "uk": {
        "question": "14. Які є винятки щодо іменування компонентів React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У React існують суворі правила іменування компонентів, від яких не можна відступати."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Велика літера на початку:", "bold": true },
                  {
                    "text": " Компоненти повинні починатися з великої літери, інакше React сприйматиме їх як HTML-теги."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CamelCase:", "bold": true },
                  {
                    "text": " Імена компонентів пишуться у CamelCase без розділювачів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Не співпадати з HTML-тегами:", "bold": true },
                  {
                    "text": " Назви не повинні повторювати стандартні HTML-елементи."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Без спеціальних символів:", "bold": true },
                  { "text": " Заборонені дефіси, підкреслення та пробіли." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Класові компоненти:", "bold": true },
                  {
                    "text": " Класові компоненти також зобовʼязані починатися з великої літери."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Ці правила не рекомендації, а технічна вимога JSX." }
            ]
          }
        ]
      },
      "en": {
        "question": "14. What naming constraints exist for React components?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React enforces strict naming rules for components." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Capitalized names:", "bold": true },
                  {
                    "text": " Components must start with an uppercase letter or they are treated as HTML tags."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CamelCase:", "bold": true },
                  {
                    "text": " Component names use CamelCase without separators."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "No HTML tag names:", "bold": true },
                  {
                    "text": " Component names must not match built-in HTML elements."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "No special characters:", "bold": true },
                  { "text": " Hyphens, underscores, and spaces are invalid." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Class components:", "bold": true },
                  {
                    "text": " Class-based components follow the same capitalization rules."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "These are JSX requirements, not style preferences." }
            ]
          }
        ]
      },
      "pl": {
        "question": "14. Jakie ograniczenia dotyczą nazewnictwa komponentów React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React narzuca ścisłe zasady nazewnictwa komponentów." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wielka litera na początku:", "bold": true },
                  { "text": " Komponenty muszą zaczynać się wielką literą." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CamelCase:", "bold": true },
                  { "text": " Nazwy komponentów zapisuje się w CamelCase." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Brak nazw tagów HTML:", "bold": true },
                  { "text": " Nazwy nie mogą pokrywać się z elementami HTML." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Bez znaków specjalnych:", "bold": true },
                  {
                    "text": " Niedozwolone są myślniki, podkreślenia i spacje."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponenty klasowe:", "bold": true },
                  { "text": " Również muszą zaczynać się wielką literą." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Są to techniczne wymogi JSX." }]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 15,
    "translations": {
      "uk": {
        "question": "15. Як писати коментарі в React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У React коментарі пишуться як у JavaScript, але в JSX діє окремий синтаксис."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Коментарі в JavaScript (поза JSX):",
                    "bold": true
                  },
                  {
                    "type": "code",
                    "language": "javascript",
                    "content": "// Однорядковий коментар\n\n/*\nБагаторядковий коментар\n*/"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Коментарі всередині JSX:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent() {\n  return (\n    <>\n      {/* Коментар у JSX */}\n      <p>Hello, world!</p>\n    </>\n  );\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Коментарі в логіці компонента:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent() {\n  // Коментар у тілі функції\n  return <p>Hello</p>;\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коротко:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "У JSX використовується ", "bold": false },
                  { "text": "{/* ... */}", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "У JavaScript ", "bold": false },
                  { "text": "//", "code": true },
                  { "text": " та " },
                  { "text": "/* ... */", "code": true }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "15. How do you write comments in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React uses standard JavaScript comments, but JSX requires a special syntax."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "JavaScript comments (outside JSX):",
                    "bold": true
                  },
                  {
                    "type": "code",
                    "language": "javascript",
                    "content": "// Single-line comment\n\n/*\nMulti-line comment\n*/"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Comments inside JSX:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent() {\n  return (\n    <>\n      {/* JSX comment */}\n      <p>Hello, world!</p>\n    </>\n  );\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Comments in component logic:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent() {\n  // Logic comment\n  return <p>Hello</p>;\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Summary:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Use ", "bold": false },
                  { "text": "{/* ... */}", "code": true },
                  { "text": " inside JSX." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Use ", "bold": false },
                  { "text": "//", "code": true },
                  { "text": " or " },
                  { "text": "/* ... */", "code": true },
                  { "text": " in JavaScript." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "15. Jak pisać komentarze w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W React komentarze są takie jak w JavaScript, ale JSX wymaga specjalnej składni."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Komentarze JavaScript (poza JSX):", "bold": true },
                  {
                    "type": "code",
                    "language": "javascript",
                    "content": "// Komentarz jednoliniowy\n\n/*\nKomentarz wieloliniowy\n*/"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Komentarze w JSX:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent() {\n  return (\n    <>\n      {/* Komentarz JSX */}\n      <p>Hello, world!</p>\n    </>\n  );\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Komentarze w logice komponentu:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent() {\n  // Komentarz w funkcji\n  return <p>Hello</p>;\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Podsumowanie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "W JSX używaj ", "bold": false },
                  { "text": "{/* ... */}", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "W JavaScript ", "bold": false },
                  { "text": "//", "code": true },
                  { "text": " oraz " },
                  { "text": "/* ... */", "code": true }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 16,
    "translations": {
      "uk": {
        "question": "16. Що таке Virtual DOM в React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Virtual DOM", "bold": true },
              {
                "text": " - це віртуальне представлення реального DOM, яке React використовує для ефективного оновлення інтерфейсу."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює в React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Рендеринг у Virtual DOM:", "bold": true },
                  {
                    "text": " При зміні стану або пропсів компонентів React оновлює Virtual DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Diffing:", "bold": true },
                  {
                    "text": " React порівнює новий Virtual DOM зі старою версією, визначаючи мінімальний набір змін."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оновлення реального DOM:", "bold": true },
                  {
                    "text": " Виявлені зміни застосовуються до реального DOM, мінімізуючи кількість маніпуляцій."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основна перевага:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Оптимізація оновлень DOM, що суттєво покращує продуктивність React-додатків."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "16. What is the Virtual DOM in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Virtual DOM", "bold": true },
              {
                "text": " is a virtual representation of the real DOM that React uses to efficiently update the user interface."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works in React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Rendering to the Virtual DOM:", "bold": true },
                  {
                    "text": " When state or props change, React updates the Virtual DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Diffing:", "bold": true },
                  {
                    "text": " React compares the new Virtual DOM with the previous one to identify the minimal set of changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Updating the real DOM:", "bold": true },
                  {
                    "text": " The detected changes are applied to the real DOM, minimizing direct manipulations."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Main advantage:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Optimized DOM updates that significantly improve application performance."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "16. Czym jest Virtual DOM w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Virtual DOM", "bold": true },
              {
                "text": " to wirtualna reprezentacja rzeczywistego DOM, którą React wykorzystuje do wydajnego aktualizowania interfejsu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa w React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Renderowanie do Virtual DOM:", "bold": true },
                  {
                    "text": " Gdy zmienia się stan lub właściwości komponentów, React aktualizuje Virtual DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Diffing:", "bold": true },
                  {
                    "text": " React porównuje nowy Virtual DOM z poprzednim, określając minimalny zestaw zmian."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aktualizacja rzeczywistego DOM:", "bold": true },
                  {
                    "text": " Wykryte zmiany są stosowane do rzeczywistego DOM, ograniczając liczbę operacji."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główna zaleta:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Optymalizacja aktualizacji DOM, która znacząco poprawia wydajność aplikacji."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 17,
    "translations": {
      "uk": {
        "question": "17. Що таке (key) prop і яка перевага його використання в масивах елементів?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "У React prop " },
              { "text": "key", "code": true },
              {
                "text": " використовується для ідентифікації кожного елемента в списках або масивах, щоб React міг ефективно керувати оновленнями при зміні структури списку."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Основні моменти щодо " },
              { "text": "key", "code": true },
              { "text": ":" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Унікальність:", "bold": true },
                  { "text": " Кожен елемент повинен мати унікальний " },
                  { "text": "key", "code": true },
                  {
                    "text": ", щоб React міг коректно відстежувати зміни та зберігати стан компонентів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оптимізація рендерингу:", "bold": true },
                  { "text": " " },
                  { "text": "key", "code": true },
                  {
                    "text": " дозволяє React оновлювати лише змінені елементи DOM замість повторного рендерингу всього списку."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Природа key:", "bold": true },
                  { "text": " Prop " },
                  { "text": "key", "code": true },
                  {
                    "text": " не передається в компонент і використовується виключно React для внутрішньої ідентифікації елементів."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Переваги використання " },
              { "text": "key", "code": true },
              { "text": ":" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Підвищує продуктивність рендерингу." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Запобігає помилкам при зміні порядку, додаванні або видаленні елементів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Забезпечує коректне збереження стану компонентів."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "17. What is the (key) prop and what is the benefit of using it in element arrays?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "In React, the " },
              { "text": "key", "code": true },
              {
                "text": " prop is used to uniquely identify elements in lists or arrays so React can efficiently manage updates when the list changes."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Key points about " },
              { "text": "key", "code": true },
              { "text": ":" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Uniqueness:", "bold": true },
                  { "text": " Each element must have a unique " },
                  { "text": "key", "code": true },
                  {
                    "text": " so React can track changes and preserve component state."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Rendering optimization:", "bold": true },
                  { "text": " Using " },
                  { "text": "key", "code": true },
                  {
                    "text": " allows React to update only the changed DOM nodes instead of re-rendering the entire list."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Nature of key:", "bold": true },
                  { "text": " The " },
                  { "text": "key", "code": true },
                  {
                    "text": " prop is not passed to the component and is used internally by React only."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Benefits of using " },
              { "text": "key", "code": true },
              { "text": ":" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Improves rendering performance." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Prevents bugs when items are reordered, added, or removed."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Ensures correct state handling for list elements."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "17. Czym jest prop (key) i jaka jest zaleta jego użycia w tablicach elementów?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "W React prop " },
              { "text": "key", "code": true },
              {
                "text": " służy do jednoznacznej identyfikacji elementów w listach lub tablicach, aby React mógł wydajnie zarządzać aktualizacjami."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Najważniejsze informacje o " },
              { "text": "key", "code": true },
              { "text": ":" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Unikalność:", "bold": true },
                  { "text": " Każdy element musi mieć unikalny " },
                  { "text": "key", "code": true },
                  {
                    "text": ", aby React mógł poprawnie śledzić zmiany i zachować stan komponentów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optymalizacja renderowania:", "bold": true },
                  { "text": " Użycie " },
                  { "text": "key", "code": true },
                  {
                    "text": " pozwala Reactowi aktualizować tylko zmienione elementy DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Charakter key:", "bold": true },
                  { "text": " Prop " },
                  { "text": "key", "code": true },
                  {
                    "text": " nie jest przekazywany do komponentu i służy wyłącznie do wewnętrznych mechanizmów Reacta."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Zalety użycia " },
              { "text": "key", "code": true },
              { "text": ":" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Zwiększa wydajność renderowania." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zapobiega błędom przy zmianie kolejności, dodawaniu lub usuwaniu elementów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zapewnia poprawne zarządzanie stanem elementów listy."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 18,
    "translations": {
      "uk": {
        "question": "18. Що таке умовний рендеринг у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Умовний рендеринг у React — це підхід, за якого компонент відображає різний UI залежно від умов, таких як стан, пропси або інші значення."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні підходи до умовного рендерингу:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Оператор if:", "bold": true },
                  {
                    "text": " Дозволяє явно визначити, який JSX повертати залежно від умови."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Тернарний оператор:", "bold": true },
                  {
                    "text": " Використовується для компактного умовного рендерингу безпосередньо в JSX."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Логічний оператор &&:", "bold": true },
                  {
                    "text": " Рендерить елемент лише тоді, коли умова є істинною."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги умовного рендерингу:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Динамічна зміна інтерфейсу без перезавантаження сторінки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Чітке керування логікою відображення компонентів."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "18. What is conditional rendering in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Conditional rendering in React is a technique where a component renders different UI output depending on conditions such as state or props."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Main approaches to conditional rendering:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "if statement:", "bold": true },
                  {
                    "text": " Allows explicit control over what JSX is returned based on a condition."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ternary operator:", "bold": true },
                  {
                    "text": " Commonly used for concise conditional expressions inside JSX."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Logical && operator:", "bold": true },
                  {
                    "text": " Renders an element only when the condition evaluates to true."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Benefits of conditional rendering:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Enables dynamic UI updates without page reloads." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Provides clear control over component display logic."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "18. Czym jest renderowanie warunkowe w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Renderowanie warunkowe w React to mechanizm, w którym komponent wyświetla różny interfejs w zależności od spełnienia określonych warunków, takich jak stan lub właściwości."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Główne podejścia do renderowania warunkowego:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Instrukcja if:", "bold": true },
                  {
                    "text": " Umożliwia jawne określenie, co ma zostać wyrenderowane."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Operator trójargumentowy:", "bold": true },
                  {
                    "text": " Stosowany do krótkich warunków bezpośrednio w JSX."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Operator logiczny &&:", "bold": true },
                  {
                    "text": " Renderuje element tylko wtedy, gdy warunek jest spełniony."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety renderowania warunkowego:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Dynamiczne zmiany interfejsu użytkownika." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Lepsza kontrola nad logiką wyświetlania komponentów."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 19,
    "translations": {
      "uk": {
        "question": "19. Що таке фрагменти (Fragments) у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Фрагменти в React",
                "bold": true
              },
              {
                "text": " — це спосіб групувати кілька елементів без додавання зайвих елементів в DOM. Вони дозволяють повернути декілька елементів з компонента без обгортки, такої як "
              },
              {
                "text": "div",
                "code": true
              },
              {
                "text": ", що допомагає уникнути зайвих елементів, які можуть порушити стилі або структуру документа."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Використання:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Повернення кількох елементів з компонента без додаткової обгортки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Рендеринг списків з кількома елементами на кожен запис (з "
                  },
                  {
                    "text": "key",
                    "code": true
                  },
                  {
                    "text": ")."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Збереження коректної структури таблиць або списків без зайвих обгорток."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Скорочення кількості елементів в DOM для покращення продуктивності."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Уникнення конфліктів CSS-стилів, які виникають від непотрібних обгорток."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Фрагменти дозволяють безпечно керувати компонентами, відстежувати структуру та ефективно розвивати UI без засмічування DOM."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "19. What are Fragments in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Fragments in React",
                "bold": true
              },
              {
                "text": " are a way to group multiple elements without adding extra elements to the DOM. They allow returning multiple elements from a component without a wrapper such as "
              },
              {
                "text": "div",
                "code": true
              },
              {
                "text": ", which helps avoid unnecessary elements that could break styles or document structure."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Usage:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Returning multiple elements from a component without additional wrappers."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Rendering lists with multiple elements per item (with "
                  },
                  {
                    "text": "key",
                    "code": true
                  },
                  {
                    "text": ")."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Maintaining correct structure in tables or lists without unnecessary wrappers."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Reducing the number of elements in the DOM for improved performance."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Avoiding CSS style conflicts that arise from unnecessary wrappers."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Fragments allow safe component management, structure tracking, and efficient UI development without cluttering the DOM."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "19. Czym są fragmenty (Fragments) w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Fragmenty w React",
                "bold": true
              },
              {
                "text": " to sposób grupowania wielu elementów bez dodawania dodatkowych elementów do DOM. Pozwalają zwrócić wiele elementów z komponentu bez opakowania, takiego jak "
              },
              {
                "text": "div",
                "code": true
              },
              {
                "text": ", co pomaga uniknąć niepotrzebnych elementów, które mogą naruszić style lub strukturę dokumentu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Zastosowanie:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zwracanie wielu elementów z komponentu bez dodatkowych opakowań."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Renderowanie list z wieloma elementami na pozycję (z "
                  },
                  {
                    "text": "key",
                    "code": true
                  },
                  {
                    "text": ")."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zachowanie prawidłowej struktury tabel lub list bez zbędnych opakowań."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zmniejszenie liczby elementów w DOM w celu poprawy wydajności."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Unikanie konfliktów stylów CSS wynikających z niepotrzebnych opakowań."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Fragmenty umożliwiają bezpieczne zarządzanie komponentami, śledzenie struktury i efektywny rozwój interfejsu użytkownika bez zaśmiecania DOM."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 20,
    "translations": {
      "uk": {
        "question": "20. Що таке узгодження (Reconciliation)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Reconciliation", "bold": true },
              {
                "text": " — це внутрішній процес у React, за допомогою якого він визначає мінімальний набір змін для оновлення реального DOM відповідно до нового стану віртуального DOM."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює reconciliation:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Порівняння віртуальних DOM:", "bold": true },
                  {
                    "text": " React порівнює попереднє дерево Virtual DOM з новим після змін стану або пропсів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Diffing:", "bold": true },
                  {
                    "text": " Визначаються лише ті вузли, які були змінені, додані або видалені."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оновлення реального DOM:", "bold": true },
                  {
                    "text": " React застосовує лише необхідні зміни, уникаючи повного перерендеру."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові принципи:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Порівняння за типами елементів:", "bold": true },
                  {
                    "text": " вузли одного типу оновлюються, а не замінюються."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Використання key:", "bold": true },
                  {
                    "text": " ключі допомагають коректно зіставляти елементи списків між рендерами."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "20. What is Reconciliation?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Reconciliation", "bold": true },
              {
                "text": " is the internal React process used to determine the minimal set of changes needed to update the real DOM based on the new Virtual DOM."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How reconciliation works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Virtual DOM comparison:", "bold": true },
                  {
                    "text": " React compares the previous Virtual DOM tree with the new one after state or props changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Diffing:", "bold": true },
                  {
                    "text": " Only the changed, added, or removed nodes are identified."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Real DOM update:", "bold": true },
                  {
                    "text": " React applies only the necessary updates, avoiding full re-renders."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key principles:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Element type comparison:", "bold": true },
                  {
                    "text": " nodes of the same type are updated rather than replaced."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Use of keys:", "bold": true },
                  {
                    "text": " keys help correctly match list elements between renders."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "20. Czym jest uzgadnianie (Reconciliation)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Reconciliation", "bold": true },
              {
                "text": " to wewnętrzny proces w React, który służy do określenia minimalnych zmian potrzebnych do zsynchronizowania rzeczywistego DOM z Virtual DOM."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa reconciliation:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Porównanie Virtual DOM:", "bold": true },
                  {
                    "text": " React porównuje poprzednie i nowe drzewo Virtual DOM po zmianach stanu lub właściwości."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Diffing:", "bold": true },
                  {
                    "text": " Identyfikowane są tylko zmienione, dodane lub usunięte elementy."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aktualizacja DOM:", "bold": true },
                  {
                    "text": " React wprowadza jedynie niezbędne zmiany, unikając pełnego renderowania."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kluczowe zasady:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Porównanie typów elementów:", "bold": true },
                  {
                    "text": " elementy tego samego typu są aktualizowane, a nie zastępowane."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Użycie kluczy:", "bold": true },
                  {
                    "text": " klucze umożliwiają poprawne dopasowanie elementów list."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 21,
    "translations": {
      "uk": {
        "question": "21. Як оновити стан компонента?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "У React стан компонента оновлюється за допомогою " },
              { "text": "setState", "code": true },
              { "text": " у класових компонентах або " },
              { "text": "useState", "code": true },
              { "text": " у функціональних компонентах." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Класові компоненти:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Стан оновлюється через " },
              { "text": "this.setState()", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Функціональні компоненти:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Стан оновлюється через функцію, отриману з " },
              { "text": "useState", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Важливі зауваження:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Асинхронність:", "bold": true },
                  {
                    "text": " оновлення стану відбувається асинхронно, тому для залежності від попереднього значення слід використовувати функціональний підхід."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Заборона прямої мутації:", "bold": true },
                  {
                    "text": " пряме змінення стану не викликає повторного рендерингу."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "21. How do you update component state?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "In React, component state is updated using " },
              { "text": "setState", "code": true },
              { "text": " in class components or " },
              { "text": "useState", "code": true },
              { "text": " in functional components." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Class components:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "State is updated via " },
              { "text": "this.setState()", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Functional components:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "State is updated using the setter function returned by "
              },
              { "text": "useState", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Important notes:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Asynchronous updates:", "bold": true },
                  {
                    "text": " state updates are asynchronous, so functional updates should be used when relying on previous state."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "No direct mutation:", "bold": true },
                  {
                    "text": " directly modifying state does not trigger re-rendering."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "21. Jak aktualizować stan komponentu?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "W React stan komponentu aktualizuje się za pomocą " },
              { "text": "setState", "code": true },
              { "text": " w komponentach klasowych lub " },
              { "text": "useState", "code": true },
              { "text": " w komponentach funkcyjnych." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Komponenty klasowe:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Stan jest aktualizowany przez " },
              { "text": "this.setState()", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Komponenty funkcyjne:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Stan jest aktualizowany za pomocą funkcji zwróconej przez "
              },
              { "text": "useState", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ważne uwagi:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Asynchroniczność:", "bold": true },
                  {
                    "text": " aktualizacje stanu są asynchroniczne, dlatego należy stosować aktualizacje funkcyjne."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Brak bezpośredniej mutacji:", "bold": true },
                  {
                    "text": " bezpośrednia zmiana stanu nie powoduje ponownego renderowania."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 22,
    "translations": {
      "uk": {
        "question": "22. Що таке вбудовані умовні вирази?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Вбудовані умовні вирази",
                "bold": true
              },
              {
                "text": " в React — це механізми, що дозволяють вбудовувати умови безпосередньо в JSX для умовного рендерингу елементів або компонентів. Це робить код компактнішим, читабельнішим і зручнішим для розуміння."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Основні методи:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Тернарний оператор",
                    "bold": true
                  },
                  {
                    "text": " — найпоширеніший спосіб умовного рендерингу. Синтаксис: "
                  },
                  {
                    "text": "condition ? expressionTrue : expressionFalse",
                    "code": true
                  },
                  {
                    "text": ". Відображає один елемент, якщо умова істинна, інший — якщо хибна."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Логічний оператор AND (&&)",
                    "bold": true
                  },
                  {
                    "text": " — дозволяє рендерити елемент лише якщо умова "
                  },
                  {
                    "text": "true",
                    "code": true
                  },
                  {
                    "text": ". Якщо умова "
                  },
                  {
                    "text": "false",
                    "code": true
                  },
                  {
                    "text": ", нічого не буде відображено."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Оператор IF перед поверненням JSX",
                    "bold": true
                  },
                  {
                    "text": " — для складних умов використовуються звичайні "
                  },
                  {
                    "text": "if/else",
                    "code": true
                  },
                  {
                    "text": " конструкції перед поверненням JSX. Дозволяє виконати декілька умовних дій перед рендерингом."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Логічний оператор OR (||)",
                    "bold": true
                  },
                  {
                    "text": " — рендерит альтернативний елемент, якщо перша умова не виконується. Корисна для значень за замовчуванням."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Inline функції",
                    "bold": true
                  },
                  {
                    "text": " — складна логіка умов можна винести в окремі функції для кращої читаємості коду."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Переваги вбудованих умовних виразів:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Компактний і читабельний код — умови вбудовані безпосередньо в JSX без зайвих рівнів вкладеності."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Зменшується кількість допоміжних змінних — не потрібно створювати додаткові "
                  },
                  {
                    "text": "let",
                    "code": true
                  },
                  {
                    "text": " або "
                  },
                  {
                    "text": "const",
                    "code": true
                  },
                  {
                    "text": " для зберігання умовного вмісту."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Динамічний рендеринг — легко переключатися між різними компонентами на основі стану."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Важливі обмеження:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "В React не можна використовувати інструкції "
                  },
                  {
                    "text": "if",
                    "code": true
                  },
                  {
                    "text": " безпосередньо всередину JSX. Вони повинні перебувати поза JSX-блоком або скоротаним до тернарного оператора."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Не використовуйте циклові конструкції "
                  },
                  {
                    "text": "for",
                    "code": true
                  },
                  {
                    "text": " у JSX — натомість використовуйте "
                  },
                  {
                    "text": "map()",
                    "code": true
                  },
                  {
                    "text": "."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Уникайте складних умовних виразів у JSX — розділяйте складну логіку на окремі функції для читаємості."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "22. What are inline conditional expressions?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Inline conditional expressions",
                "bold": true
              },
              {
                "text": " in React are mechanisms that allow embedding conditions directly in JSX for conditional rendering of elements or components. This makes code more compact, readable, and easier to understand."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Main methods:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Ternary operator",
                    "bold": true
                  },
                  {
                    "text": " — the most common way for conditional rendering. Syntax: "
                  },
                  {
                    "text": "condition ? expressionTrue : expressionFalse",
                    "code": true
                  },
                  {
                    "text": ". Displays one element if condition is true, another if false."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Logical AND operator (&&)",
                    "bold": true
                  },
                  {
                    "text": " — allows rendering an element only if the condition is "
                  },
                  {
                    "text": "true",
                    "code": true
                  },
                  {
                    "text": ". If condition is "
                  },
                  {
                    "text": "false",
                    "code": true
                  },
                  {
                    "text": ", nothing is displayed."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "IF statement before returning JSX",
                    "bold": true
                  },
                  {
                    "text": " — for complex conditions, regular "
                  },
                  {
                    "text": "if/else",
                    "code": true
                  },
                  {
                    "text": " constructs are used before returning JSX. Allows multiple conditional actions before rendering."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Logical OR operator (||)",
                    "bold": true
                  },
                  {
                    "text": " — renders alternative element if first condition fails. Useful for default values."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Inline functions",
                    "bold": true
                  },
                  {
                    "text": " — complex condition logic can be extracted to separate functions for better code readability."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Benefits of inline conditional expressions:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Compact and readable code — conditions are embedded directly in JSX without excessive nesting."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Reduced auxiliary variables — no need to create additional "
                  },
                  {
                    "text": "let",
                    "code": true
                  },
                  {
                    "text": " or "
                  },
                  {
                    "text": "const",
                    "code": true
                  },
                  {
                    "text": " for storing conditional content."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Dynamic rendering — easily switch between different components based on state."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Important limitations:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "In React, you cannot use "
                  },
                  {
                    "text": "if",
                    "code": true
                  },
                  {
                    "text": " statements directly inside JSX. They must be outside JSX blocks or reduced to ternary operator."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Do not use loop constructs like "
                  },
                  {
                    "text": "for",
                    "code": true
                  },
                  {
                    "text": " in JSX — use "
                  },
                  {
                    "text": "map()",
                    "code": true
                  },
                  {
                    "text": " instead."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Avoid complex conditional expressions in JSX — extract complex logic into separate functions for readability."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "22. Czym są wbudowane wyrażenia warunkowe?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wbudowane wyrażenia warunkowe",
                "bold": true
              },
              {
                "text": " w React to mechanizmy, które pozwalają osadzać warunki bezpośrednio w JSX do warunkowego renderowania elementów lub komponentów. Czyni to kod bardziej zwartym, czytelnym i łatwym do zrozumienia."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Główne metody:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Operator warunkowy (ternarny)",
                    "bold": true
                  },
                  {
                    "text": " — najczęstszy sposób warunkowego renderowania. Składnia: "
                  },
                  {
                    "text": "condition ? expressionTrue : expressionFalse",
                    "code": true
                  },
                  {
                    "text": ". Wyświetla jeden element, jeśli warunek jest prawdziwy, drugi, jeśli fałszywy."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Operator logiczny AND (&&)",
                    "bold": true
                  },
                  {
                    "text": " — pozwala renderować element tylko wtedy, gdy warunek to "
                  },
                  {
                    "text": "true",
                    "code": true
                  },
                  {
                    "text": ". Jeśli warunek to "
                  },
                  {
                    "text": "false",
                    "code": true
                  },
                  {
                    "text": ", nic nie jest wyświetlane."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Instrukcja IF przed zwróceniem JSX",
                    "bold": true
                  },
                  {
                    "text": " — dla złożonych warunków używane są regularne konstrukcje "
                  },
                  {
                    "text": "if/else",
                    "code": true
                  },
                  {
                    "text": " przed zwróceniem JSX. Umożliwia wielokrotne działania warunkowe przed renderowaniem."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Operator logiczny OR (||)",
                    "bold": true
                  },
                  {
                    "text": " — renderuje alternatywny element, jeśli pierwszy warunek nie zostanie spełniony. Przydatny do wartości domyślnych."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Funkcje wbudowane",
                    "bold": true
                  },
                  {
                    "text": " — złożoną logikę warunków można wyodrębnić do oddzielnych funkcji dla lepszej czytelności kodu."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Zalety wbudowanych wyrażeń warunkowych:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zwarty i czytelny kod — warunki osadzone bezpośrednio w JSX bez nadmiernego zagnieżdżenia."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zmniejszona liczba zmiennych pomocniczych — nie ma potrzeby tworzenia dodatkowych "
                  },
                  {
                    "text": "let",
                    "code": true
                  },
                  {
                    "text": " lub "
                  },
                  {
                    "text": "const",
                    "code": true
                  },
                  {
                    "text": " do przechowywania warunkowej zawartości."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Dynamiczne renderowanie — łatwe przełączanie między różnymi komponentami na podstawie stanu."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Ważne ograniczenia:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "W React nie można używać instrukcji "
                  },
                  {
                    "text": "if",
                    "code": true
                  },
                  {
                    "text": " bezpośrednio wewnątrz JSX. Muszą się znajdować poza blokami JSX lub być zredukowane do operatora ternarnego."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Nie używaj konstrukcji pętli takich jak "
                  },
                  {
                    "text": "for",
                    "code": true
                  },
                  {
                    "text": " w JSX — użyj zamiast tego "
                  },
                  {
                    "text": "map()",
                    "code": true
                  },
                  {
                    "text": "."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Unikaj złożonych wyrażeń warunkowych w JSX — wyodrębnij złożoną logikę do oddzielnych funkcji w celu poprawy czytelności."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 23,
    "translations": {
      "uk": {
        "question": "23. Яка різниця між обробкою подій HTML і React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Різниця між обробкою подій у HTML та React:" }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Критерій" }],
              [{ "text": "HTML" }],
              [{ "text": "React" }]
            ],
            "rows": [
              [
                [{ "text": "Синтаксис подій", "bold": true }],
                [
                  { "text": "Атрибут у нижньому регістрі: " },
                  { "text": "onclick", "code": true }
                ],
                [{ "text": "camelCase: " }, { "text": "onClick", "code": true }]
              ],
              [
                [{ "text": "Передача обробника", "bold": true }],
                [{ "text": "Рядок або глобальна функція" }],
                [{ "text": "Посилання на функцію компонента" }]
              ],
              [
                [{ "text": "Керування слухачами", "bold": true }],
                [
                  { "text": "Через " },
                  { "text": "addEventListener", "code": true }
                ],
                [{ "text": "Автоматично через Virtual DOM" }]
              ],
              [
                [{ "text": "Контекст this", "bold": true }],
                [{ "text": "Потрібен ручний контроль" }],
                [{ "text": "У функціональних компонентах проблем немає" }]
              ],
              [
                [{ "text": "Стандартна поведінка", "bold": true }],
                [
                  { "text": "Через " },
                  { "text": "return false", "code": true }
                ],
                [
                  { "text": "Через " },
                  { "text": "event.preventDefault()", "code": true }
                ]
              ],
              [
                [{ "text": "Події", "bold": true }],
                [{ "text": "Нативні DOM-події" }],
                [{ "text": "SyntheticEvent (нормалізація)" }]
              ]
            ]
          }
        ]
      },
      "en": {
        "question": "23. What is the difference between HTML and React event handling?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Differences between event handling in HTML and React:"
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Criterion" }],
              [{ "text": "HTML" }],
              [{ "text": "React" }]
            ],
            "rows": [
              [
                [{ "text": "Event syntax", "bold": true }],
                [
                  { "text": "Lowercase attribute: " },
                  { "text": "onclick", "code": true }
                ],
                [{ "text": "camelCase: " }, { "text": "onClick", "code": true }]
              ],
              [
                [{ "text": "Handler passing", "bold": true }],
                [{ "text": "String or global function" }],
                [{ "text": "Function reference" }]
              ],
              [
                [{ "text": "Listener management", "bold": true }],
                [
                  { "text": "Via " },
                  { "text": "addEventListener", "code": true }
                ],
                [{ "text": "Managed by Virtual DOM" }]
              ],
              [
                [{ "text": "this context", "bold": true }],
                [{ "text": "Manual binding required" }],
                [{ "text": "No issue in functional components" }]
              ],
              [
                [{ "text": "Default behavior", "bold": true }],
                [
                  { "text": "Using " },
                  { "text": "return false", "code": true }
                ],
                [
                  { "text": "Using " },
                  { "text": "event.preventDefault()", "code": true }
                ]
              ],
              [
                [{ "text": "Events", "bold": true }],
                [{ "text": "Native DOM events" }],
                [{ "text": "SyntheticEvent wrapper" }]
              ]
            ]
          }
        ]
      },
      "pl": {
        "question": "23. Jaka jest różnica między obsługą zdarzeń w HTML i React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Różnice między obsługą zdarzeń w HTML i React:" }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Kryterium" }],
              [{ "text": "HTML" }],
              [{ "text": "React" }]
            ],
            "rows": [
              [
                [{ "text": "Składnia zdarzeń", "bold": true }],
                [
                  { "text": "Atrybut małymi literami: " },
                  { "text": "onclick", "code": true }
                ],
                [{ "text": "camelCase: " }, { "text": "onClick", "code": true }]
              ],
              [
                [{ "text": "Przekazywanie handlera", "bold": true }],
                [{ "text": "Łańcuch znaków lub funkcja globalna" }],
                [{ "text": "Referencja do funkcji komponentu" }]
              ],
              [
                [{ "text": "Zarządzanie listenerami", "bold": true }],
                [
                  { "text": "Przez " },
                  { "text": "addEventListener", "code": true }
                ],
                [{ "text": "Automatycznie przez Virtual DOM" }]
              ],
              [
                [{ "text": "Kontekst this", "bold": true }],
                [{ "text": "Wymaga ręcznego bindowania" }],
                [{ "text": "Brak problemu w komponentach funkcyjnych" }]
              ],
              [
                [{ "text": "Domyślne zachowanie", "bold": true }],
                [
                  { "text": "Za pomocą " },
                  { "text": "return false", "code": true }
                ],
                [
                  { "text": "Za pomocą " },
                  { "text": "event.preventDefault()", "code": true }
                ]
              ],
              [
                [{ "text": "Zdarzenia", "bold": true }],
                [{ "text": "Natywne zdarzenia DOM" }],
                [{ "text": "SyntheticEvent (normalizacja)" }]
              ]
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 24,
    "translations": {
      "uk": {
        "question": "24. Що таке синтетичні події в React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Синтетичні події (Synthetic Events)", "bold": true },
              {
                "text": " — це обгортки над нативними DOM-подіями в React, які забезпечують єдиний інтерфейс роботи з подіями у всіх браузерах."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні характеристики:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Кросбраузерність:", "bold": true },
                  { "text": " однакова поведінка подій у різних браузерах." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оптимізація:", "bold": true },
                  {
                    "text": " використання пулу обʼєктів для зменшення витрат памʼяті."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Стандартний інтерфейс:", "bold": true },
                  { "text": " підтримує методи " },
                  { "text": "preventDefault()", "code": true },
                  { "text": " та " },
                  { "text": "stopPropagation()", "code": true },
                  { "text": "." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "24. What are synthetic events in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Synthetic Events", "bold": true },
              {
                "text": " are wrappers around native DOM events in React that provide a consistent event interface across all browsers."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key characteristics:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Cross-browser consistency:", "bold": true },
                  { "text": " uniform behavior across different browsers." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optimization:", "bold": true },
                  { "text": " object pooling to reduce memory allocations." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Standard interface:", "bold": true },
                  { "text": " supports methods like " },
                  { "text": "preventDefault()", "code": true },
                  { "text": " and " },
                  { "text": "stopPropagation()", "code": true },
                  { "text": "." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "24. Czym są zdarzenia syntetyczne w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zdarzenia syntetyczne (Synthetic Events)",
                "bold": true
              },
              {
                "text": " to obiekty opakowujące natywne zdarzenia DOM w React, zapewniające jednolity interfejs obsługi zdarzeń we wszystkich przeglądarkach."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne cechy:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Zgodność międzyprzeglądarkowa:", "bold": true },
                  { "text": " jednolite zachowanie zdarzeń." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optymalizacja:", "bold": true },
                  {
                    "text": " wykorzystanie puli obiektów w celu oszczędzania pamięci."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Standardowy interfejs:", "bold": true },
                  { "text": " obsługa metod " },
                  { "text": "preventDefault()", "code": true },
                  { "text": " oraz " },
                  { "text": "stopPropagation()", "code": true },
                  { "text": "." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 25,
    "translations": {
      "uk": {
        "question": "25. Як обробляти події в React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "В React обробка подій схожа на звичайний JavaScript, але використовує синтетичні події та декларативний підхід через JSX."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні принципи:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Синтетичні події:", "bold": true },
                  { "text": " всі події обгорнуті в " },
                  { "text": "SyntheticEvent", "bold": true },
                  { "text": " для кросбраузерної сумісності." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "camelCase:", "bold": true },
                  { "text": " події оголошуються як " },
                  { "text": "onClick", "code": true },
                  { "text": ", а не " },
                  { "text": "onclick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Передача функцій:", "bold": true },
                  { "text": " обробник передається як посилання на функцію." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Особливості:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Не використовується " },
                  { "text": "addEventListener", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Контекст " },
                  { "text": "this", "code": true },
                  { "text": " у класових компонентах потребує привʼязки." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "25. How are events handled in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In React, event handling is similar to standard JavaScript but uses synthetic events and a declarative JSX-based approach."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core principles:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Synthetic events:", "bold": true },
                  { "text": " all events are wrapped in " },
                  { "text": "SyntheticEvent", "bold": true },
                  { "text": " for cross-browser consistency." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "camelCase:", "bold": true },
                  { "text": " events use " },
                  { "text": "onClick", "code": true },
                  { "text": " instead of " },
                  { "text": "onclick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Function handlers:", "bold": true },
                  { "text": " handlers are passed as function references." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Notes:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "No need for " },
                  { "text": "addEventListener", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "The " },
                  { "text": "this", "code": true },
                  { "text": " context must be bound in class components." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "25. Jak obsługiwać zdarzenia w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W React obsługa zdarzeń jest podobna do JavaScript, ale opiera się na zdarzeniach syntetycznych i deklaratywnym JSX."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne zasady:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Zdarzenia syntetyczne:", "bold": true },
                  { "text": " wszystkie zdarzenia są opakowane w " },
                  { "text": "SyntheticEvent", "bold": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "camelCase:", "bold": true },
                  { "text": " używa się " },
                  { "text": "onClick", "code": true },
                  { "text": " zamiast " },
                  { "text": "onclick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Funkcje obsługi:", "bold": true },
                  { "text": " przekazywane jako referencje." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Uwagi:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Nie używa się " },
                  { "text": "addEventListener", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontekst " },
                  { "text": "this", "code": true },
                  { "text": " w komponentach klasowych wymaga bindowania." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 26,
    "translations": {
      "uk": {
        "question": "26. Що таке події вказівника (Pointer Events)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Pointer Events", "bold": true },
              {
                "text": " — це уніфікований API для обробки подій миші, сенсорного екрана та стилуса в React."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні події:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Подія", "bold": true }],
              [{ "text": "Опис", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "onPointerDown", "bold": true }],
                [{ "text": "Спрацьовує при натисканні вказівника." }]
              ],
              [
                [{ "text": "onPointerUp", "bold": true }],
                [{ "text": "Спрацьовує при відпусканні вказівника." }]
              ],
              [
                [{ "text": "onPointerMove", "bold": true }],
                [{ "text": "Викликається при русі вказівника." }]
              ],
              [
                [{ "text": "onPointerEnter", "bold": true }],
                [{ "text": "Коли вказівник входить у межі елемента." }]
              ],
              [
                [{ "text": "onPointerLeave", "bold": true }],
                [{ "text": "Коли вказівник залишає елемент." }]
              ],
              [
                [{ "text": "onPointerCancel", "bold": true }],
                [{ "text": "Коли подію скасовано браузером." }]
              ]
            ]
          }
        ]
      },
      "en": {
        "question": "26. What are Pointer Events?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Pointer Events", "bold": true },
              {
                "text": " are a unified API for handling mouse, touch, and pen input events in React."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Main events:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Event", "bold": true }],
              [{ "text": "Description", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "onPointerDown", "bold": true }],
                [{ "text": "Fires when a pointer is pressed." }]
              ],
              [
                [{ "text": "onPointerUp", "bold": true }],
                [{ "text": "Fires when a pointer is released." }]
              ],
              [
                [{ "text": "onPointerMove", "bold": true }],
                [{ "text": "Triggered when the pointer moves." }]
              ],
              [
                [{ "text": "onPointerEnter", "bold": true }],
                [{ "text": "When the pointer enters an element." }]
              ],
              [
                [{ "text": "onPointerLeave", "bold": true }],
                [{ "text": "When the pointer leaves an element." }]
              ],
              [
                [{ "text": "onPointerCancel", "bold": true }],
                [{ "text": "When the browser cancels the event." }]
              ]
            ]
          }
        ]
      },
      "pl": {
        "question": "26. Czym są zdarzenia wskaźnika (Pointer Events)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Pointer Events", "bold": true },
              {
                "text": " to zunifikowane API do obsługi zdarzeń myszy, dotyku i rysika w React."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne zdarzenia:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Zdarzenie", "bold": true }],
              [{ "text": "Opis", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "onPointerDown", "bold": true }],
                [{ "text": "Wywoływane przy naciśnięciu wskaźnika." }]
              ],
              [
                [{ "text": "onPointerUp", "bold": true }],
                [{ "text": "Wywoływane przy zwolnieniu wskaźnika." }]
              ],
              [
                [{ "text": "onPointerMove", "bold": true }],
                [{ "text": "Wywoływane podczas ruchu wskaźnika." }]
              ],
              [
                [{ "text": "onPointerEnter", "bold": true }],
                [{ "text": "Gdy wskaźnik wchodzi w element." }]
              ],
              [
                [{ "text": "onPointerLeave", "bold": true }],
                [{ "text": "Gdy wskaźnik opuszcza element." }]
              ],
              [
                [{ "text": "onPointerCancel", "bold": true }],
                [{ "text": "Gdy zdarzenie zostaje anulowane." }]
              ]
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 27,
    "translations": {
      "uk": {
        "question": "27. Коли використовувати компонент класу замість функціонального компонента?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Класові компоненти історично використовувалися у випадках, коли функціональні компоненти не мали необхідних можливостей."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Стан компонента:", "bold": true },
                  {
                    "text": " раніше лише класи підтримували локальний стан. Сьогодні це вирішується хуками."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Методи життєвого циклу:", "bold": true },
                  {
                    "text": " класи надавали доступ до lifecycle-методів, які зараз замінені хуком "
                  },
                  { "text": "useEffect", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Застарілий код:", "bold": true },
                  {
                    "text": " підтримка існуючих проєктів, написаних на класах."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У нових проєктах класові компоненти не рекомендуються. Функціональні компоненти з хуками є стандартом."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "27. When should you use a class component instead of a functional component?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Class components were historically used when functional components lacked certain capabilities."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Component state:", "bold": true },
                  {
                    "text": " only class components supported state before hooks."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Lifecycle methods:", "bold": true },
                  {
                    "text": " classes exposed lifecycle APIs now replaced by "
                  },
                  { "text": "useEffect", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Legacy code:", "bold": true },
                  {
                    "text": " maintaining older React codebases."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "For new development, functional components with hooks are the recommended approach."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "27. Kiedy używać komponentu klasowego zamiast funkcyjnego?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Komponenty klasowe były używane, gdy komponenty funkcyjne nie oferowały wymaganej funkcjonalności."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Stan komponentu:", "bold": true },
                  {
                    "text": " wcześniej dostępny tylko w komponentach klasowych."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Metody cyklu życia:", "bold": true },
                  {
                    "text": " obecnie zastąpione przez hook "
                  },
                  { "text": "useEffect", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Starszy kod:", "bold": true },
                  {
                    "text": " utrzymanie istniejących aplikacji."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W nowych projektach zaleca się używanie komponentów funkcyjnych z hookami."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 28,
    "translations": {
      "uk": {
        "question": "28. Що таке компоненти без стану (stateless components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Компоненти без стану (stateless components) — це компоненти, які не зберігають власний стан і працюють виключно з даними, отриманими через props."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Особливості:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Відсутність стану:", "bold": true },
                  { "text": " не використовують внутрішній state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Орієнтація на props:", "bold": true },
                  { "text": " рендерять UI виключно на основі вхідних даних." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Передбачуваність:", "bold": true },
                  {
                    "text": " однакові props завжди дають однаковий результат."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "28. What are stateless components?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Stateless components are components that do not manage their own state and rely entirely on props to render UI."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key characteristics:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "No internal state:", "bold": true },
                  { "text": " they do not use component state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Props-driven:", "bold": true },
                  { "text": " UI output depends solely on input props." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Predictability:", "bold": true },
                  { "text": " same props always produce the same output." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "28. Czym są komponenty bezstanowe (stateless components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Komponenty bezstanowe to komponenty, które nie przechowują własnego stanu i renderują interfejs wyłącznie na podstawie propsów."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Cechy charakterystyczne:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Brak stanu:", "bold": true },
                  { "text": " nie korzystają z wewnętrznego state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oparte na propsach:", "bold": true },
                  { "text": " renderują UI na podstawie danych wejściowych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przewidywalność:", "bold": true },
                  { "text": " te same propsy dają ten sam wynik." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 29,
    "translations": {
      "uk": {
        "question": "29. Що таке компоненти стану (stateful components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Компоненти стану (stateful components)",
                "bold": true
              },
              {
                "text": " — це компоненти, які зберігають і керують власним внутрішнім станом, що може змінюватися з часом і впливати на рендеринг."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Особливості:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Власний стан:", "bold": true },
                  { "text": " зберігають дані у state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оновлення стану:", "bold": true },
                  {
                    "text": " зміни стану викликають повторний рендеринг компонента."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Динамічність:", "bold": true },
                  { "text": " UI змінюється залежно від поточного стану." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "29. What are stateful components?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Stateful components", "bold": true },
              {
                "text": " are components that manage their own internal state, which can change over time and affect rendering."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key characteristics:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Internal state:", "bold": true },
                  { "text": " they store data inside component state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "State updates:", "bold": true },
                  { "text": " state changes trigger re-rendering." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dynamic behavior:", "bold": true },
                  { "text": " UI output depends on current state." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "29. Czym są komponenty stanowe (stateful components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Komponenty stanowe (stateful components)",
                "bold": true
              },
              {
                "text": " to komponenty, które przechowują i zarządzają własnym stanem, wpływającym na renderowanie."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Cechy:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Własny stan:", "bold": true },
                  { "text": " dane są przechowywane w state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aktualizacja stanu:", "bold": true },
                  { "text": " zmiany stanu powodują ponowne renderowanie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dynamiczność:", "bold": true },
                  { "text": " interfejs reaguje na zmiany stanu." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 30,
    "translations": {
      "uk": {
        "question": "30. Що таке чисті компоненти (Pure Components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Чисті компоненти (Pure Components)", "bold": true },
              {
                "text": " — це класові компоненти React, які оптимізують рендеринг за допомогою поверхневого порівняння пропсів і стану."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключова ідея:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Компонент перерендерюється лише тоді, коли змінюються пропси або стан за результатом shallow comparison."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Особливості:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Авто-оптимізація:", "bold": true },
                  {
                    "text": " реалізує shouldComponentUpdate з поверхневим порівнянням."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Обмеження:", "bold": true },
                  {
                    "text": " не відстежує глибокі зміни у вкладених обʼєктах."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "30. What are Pure Components?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Pure Components", "bold": true },
              {
                "text": " are React class components that optimize rendering by performing a shallow comparison of props and state."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core idea:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The component re-renders only when props or state change based on shallow comparison."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key points:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatic optimization:", "bold": true },
                  { "text": " includes a built-in shouldComponentUpdate." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Limitation:", "bold": true },
                  {
                    "text": " does not detect deep mutations in objects or arrays."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "30. Czym są czyste komponenty (Pure Components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Czyste komponenty (Pure Components)", "bold": true },
              {
                "text": " to komponenty klasowe React, które optymalizują renderowanie poprzez płytkie porównanie propsów i stanu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główna idea:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Komponent renderuje się ponownie tylko wtedy, gdy zmienią się propsy lub stan."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Cechy:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatyczna optymalizacja:", "bold": true },
                  { "text": " wbudowane shouldComponentUpdate." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ograniczenia:", "bold": true },
                  {
                    "text": " brak wykrywania głębokich zmian w strukturach danych."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 31,
    "translations": {
      "uk": {
        "question": "31. Що таке компоненти вищого порядку (Higher-Order Components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Компоненти вищого порядку (Higher-Order Components)",
                "bold": true
              },
              {
                "text": " — це функції, які приймають компонент і повертають новий компонент, розширюючи або модифікуючи його поведінку."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні характеристики:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Функція над компонентом:", "bold": true },
                  { "text": " приймає компонент як аргумент." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Повертає новий компонент:", "bold": true },
                  { "text": " додає логіку або пропси." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Повторне використання логіки:", "bold": true },
                  { "text": " дозволяє уникати дублювання коду." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У сучасному React HOC застосовуються рідше, оскільки більшість сценаріїв ефективніше вирішуються хуками."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "31. What are Higher-Order Components?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Higher-Order Components", "bold": true },
              {
                "text": " are functions that take a component as input and return a new component with enhanced behavior."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key characteristics:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Component wrapper:", "bold": true },
                  { "text": " accepts a component as an argument." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Returns a new component:", "bold": true },
                  { "text": " injects additional logic or props." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Logic reuse:", "bold": true },
                  { "text": " enables sharing behavior across components." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In modern React applications, HOCs are often replaced by hooks."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "31. Czym są komponenty wyższego rzędu (Higher-Order Components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Komponenty wyższego rzędu (Higher-Order Components)",
                "bold": true
              },
              {
                "text": " to funkcje, które przyjmują komponent i zwracają nowy komponent z rozszerzoną funkcjonalnością."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Cechy charakterystyczne:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Funkcja nad komponentem:", "bold": true },
                  { "text": " przyjmuje komponent jako argument." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Nowy komponent:", "bold": true },
                  { "text": " dodaje logikę lub propsy." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wielokrotne użycie logiki:", "bold": true },
                  { "text": " umożliwia współdzielenie zachowania." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W nowoczesnym React HOC są często zastępowane przez hooki."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 32,
    "translations": {
      "uk": {
        "question": "32. Що таке children prop?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "children",
                "code": true
              },
              {
                "text": " — це спеціальний пропс у React, який містить вкладений вміст, переданий між відкриваючим і закриваючим тегами компонента."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові властивості:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Гнучкість:", "bold": true },
                  {
                    "text": " може містити текст, JSX, компоненти або функції."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Композиція:", "bold": true },
                  { "text": " дозволяє створювати компоненти-обгортки." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Повторне використання:", "bold": true },
                  { "text": " один компонент може відображати різний вміст." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "32. What is the children prop?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "children",
                "code": true
              },
              {
                "text": " is a special React prop that contains the nested content passed between a component’s opening and closing tags."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key properties:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Flexibility:", "bold": true },
                  {
                    "text": " can contain text, JSX, components, or functions."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Composition:", "bold": true },
                  { "text": " enables wrapper and layout components." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Reusability:", "bold": true },
                  {
                    "text": " the same component can render different content."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "32. Czym jest prop children?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "children",
                "code": true
              },
              {
                "text": " to specjalny props w React, który zawiera zagnieżdżoną treść przekazaną między znacznikami komponentu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kluczowe cechy:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Elastyczność:", "bold": true },
                  {
                    "text": " może zawierać tekst, JSX, komponenty lub funkcje."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kompozycja:", "bold": true },
                  { "text": " umożliwia tworzenie komponentów opakowujących." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wielokrotne użycie:", "bold": true },
                  { "text": " jeden komponent może renderować różną treść." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 33,
    "translations": {
      "uk": {
        "question": "33. Що таке портал (Portal)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Портал (Portal)", "bold": true },
              {
                "text": " — це механізм у React, який дозволяє рендерити елементи в DOM-вузол поза ієрархією батьківського компонента."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові моменти:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Рендеринг поза деревом DOM:", "bold": true },
                  { "text": " елемент фізично знаходиться в іншому DOM-вузлі." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Збереження React-ієрархії:", "bold": true },
                  {
                    "text": " події поширюються відповідно до дерева компонентів React."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "33. What is a Portal?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A Portal", "bold": true },
              {
                "text": " is a React feature that allows rendering children into a DOM node outside the parent component’s DOM hierarchy."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key points:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Out-of-tree rendering:", "bold": true },
                  { "text": " the element is mounted elsewhere in the DOM." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Preserved React hierarchy:", "bold": true },
                  {
                    "text": " event bubbling follows the React component tree."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "33. Czym jest portal (Portal)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Portal", "bold": true },
              {
                "text": " to mechanizm w React umożliwiający renderowanie elementów w węźle DOM poza hierarchią komponentu nadrzędnego."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Najważniejsze cechy:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Renderowanie poza drzewem DOM:", "bold": true },
                  { "text": " element znajduje się w innym miejscu w DOM." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zachowana hierarchia React:", "bold": true },
                  { "text": " obsługa zdarzeń zgodna z drzewem komponentów." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 34,
    "translations": {
      "uk": {
        "question": "34. Як працюють портали (Portals) в React, і які їх переваги та основні застосування в UI-розробці?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Портали (Portals)", "bold": true },
              {
                "text": " дозволяють рендерити елементи в інший DOM-вузол поза стандартною ієрархією батьківського компонента."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працюють:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React використовує метод "
              },
              { "text": "ReactDOM.createPortal", "code": true },
              {
                "text": ", який рендерить JSX у вказаний DOM-контейнер, зберігаючи при цьому React-ієрархію та обробку подій."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Коректне накладання елементів поверх UI." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відсутність проблем із overflow та z-index." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Збереження контексту та подій React." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні застосування:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Модальні вікна." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Tooltips і popovers." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Контекстні меню." }]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "34. How do Portals work in React, and what are their benefits and main UI use cases?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Portals", "bold": true },
              {
                "text": " allow rendering elements into a DOM node outside the parent component’s DOM hierarchy."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How they work:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React uses "
              },
              { "text": "ReactDOM.createPortal", "code": true },
              {
                "text": " to mount JSX into a target DOM node while preserving React context and event bubbling."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Benefits:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Proper layering of UI elements." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Avoids overflow and z-index issues." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Preserves React state and events." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Common use cases:" }]
          },
          {
            "type": "bulletList",
            "children": [
              { "type": "listItem", "children": [{ "text": "Modals." }] },
              {
                "type": "listItem",
                "children": [{ "text": "Tooltips and popovers." }]
              },
              { "type": "listItem", "children": [{ "text": "Context menus." }] }
            ]
          }
        ]
      },
      "pl": {
        "question": "34. Jak działają portale (Portals) w React i jakie są ich zalety oraz główne zastosowania w UI?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Portale (Portals)", "bold": true },
              {
                "text": " umożliwiają renderowanie elementów w węźle DOM poza hierarchią komponentu nadrzędnego."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działają:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React używa metody "
              },
              { "text": "ReactDOM.createPortal", "code": true },
              {
                "text": ", aby renderować JSX w docelowym węźle DOM z zachowaniem kontekstu i zdarzeń React."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Poprawne nakładanie elementów UI." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Brak problemów z overflow i z-index." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Zachowanie stanu i zdarzeń React." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne zastosowania:" }]
          },
          {
            "type": "bulletList",
            "children": [
              { "type": "listItem", "children": [{ "text": "Okna modalne." }] },
              {
                "type": "listItem",
                "children": [{ "text": "Tooltipy i popovery." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Menu kontekstowe." }]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 35,
    "translations": {
      "uk": {
        "question": "35. Методи життєвого циклу компонента у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Методи життєвого циклу",
                "bold": true
              },
              {
                "text": " використовуються в класових компонентах React для керування етапами існування компонента: створення, оновлення та видалення."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні фази:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Монтування:", "bold": true },
                  { "text": " constructor, render, componentDidMount." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оновлення:", "bold": true },
                  {
                    "text": " shouldComponentUpdate, render, componentDidUpdate."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Розмонтування:", "bold": true },
                  { "text": " componentWillUnmount." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Обробка помилок:", "bold": true },
                  { "text": " getDerivedStateFromError, componentDidCatch." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У сучасному React ці методи переважно замінюються хуками у функціональних компонентах."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "35. What are component lifecycle methods in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Lifecycle methods",
                "bold": true
              },
              {
                "text": " are used in React class components to control different stages of a component’s life: creation, update, and removal."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Main phases:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Mounting:", "bold": true },
                  { "text": " constructor, render, componentDidMount." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Updating:", "bold": true },
                  {
                    "text": " shouldComponentUpdate, render, componentDidUpdate."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Unmounting:", "bold": true },
                  { "text": " componentWillUnmount." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Error handling:", "bold": true },
                  { "text": " getDerivedStateFromError, componentDidCatch." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In modern React, these lifecycle methods are mostly replaced by hooks."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "35. Jakie są metody cyklu życia komponentu w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Metody cyklu życia",
                "bold": true
              },
              {
                "text": " są używane w komponentach klasowych React do zarządzania etapami życia komponentu: tworzeniem, aktualizacją i usuwaniem."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne fazy:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Montowanie:", "bold": true },
                  { "text": " constructor, render, componentDidMount." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aktualizacja:", "bold": true },
                  {
                    "text": " shouldComponentUpdate, render, componentDidUpdate."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Odmontowanie:", "bold": true },
                  { "text": " componentWillUnmount." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Obsługa błędów:", "bold": true },
                  { "text": " getDerivedStateFromError, componentDidCatch." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W nowoczesnym React metody te są w większości zastępowane przez hooki."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 36,
    "translations": {
      "uk": {
        "question": "36. Що робить метод shouldComponentUpdate?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "shouldComponentUpdate",
                "code": true
              },
              {
                "text": " — це метод життєвого циклу в класових компонентах React, який визначає, чи потрібно виконувати повторний рендер компонента."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Повертає true:", "bold": true },
                  { "text": " компонент буде перерендерений." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Повертає false:", "bold": true },
                  {
                    "text": " рендер пропускається, навіть якщо props або state змінилися."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "36. What does shouldComponentUpdate do?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "shouldComponentUpdate",
                "code": true
              },
              {
                "text": " is a lifecycle method in React class components that decides whether the component should re-render."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Returns true:", "bold": true },
                  { "text": " the component re-renders." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Returns false:", "bold": true },
                  {
                    "text": " rendering is skipped even if props or state change."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "36. Co robi metoda shouldComponentUpdate?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "shouldComponentUpdate",
                "code": true
              },
              {
                "text": " to metoda cyklu życia w komponentach klasowych React, która decyduje, czy komponent powinien zostać ponownie wyrenderowany."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Zwraca true:", "bold": true },
                  { "text": " komponent zostanie wyrenderowany ponownie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zwraca false:", "bold": true },
                  {
                    "text": " renderowanie zostaje pominięte mimo zmian propsów lub stanu."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 37,
    "translations": {
      "uk": {
        "question": "37. Як виконати код перед видаленням компонента з дерева?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Щоб виконати код перед видаленням компонента з дерева в React, використовують такі підходи:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Класові компоненти:", "bold": true },
                  { "text": " " },
                  { "text": "componentWillUnmount", "code": true },
                  {
                    "text": "Для класових компонентів є метод життєвого циклу componentWillUnmount, який викликається перед видаленням компонента."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class MyComponent extends React.Component {\n  componentWillUnmount() {\n    console.log('Компонент буде видалено');\n  }\n\n  render() {\n    return <div>Мій компонент</div>;\n  }\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Функціональні компоненти:", "bold": true },
                  { "text": " " },
                  { "text": "useEffect", "code": true },
                  { "text": " з очищенням" },
                  {
                    "text": "У функціональних компонентах очищення можна зробити в useEffect, повернувши функцію, яка виконається перед видаленням компонента."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    return () => {\n      console.log('Компонент буде видалено');\n    };\n  }, []);\n\n  return <div>Мій компонент</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Обробка перед закриттям сторінки (beforeunload)",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Якщо потрібно виконати код перед закриттям вкладки або перезавантаженням сторінки:"
              }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "useEffect(() => {\n  const handleUnload = () => {\n    console.log('Сторінка закривається');\n  };\n\n  window.addEventListener('beforeunload', handleUnload);\n  return () => window.removeEventListener('beforeunload', handleUnload);\n}, []);"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "componentWillUnmount", "code": true },
                  { "text": " – для класових компонентів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useEffect", "code": true },
                  { "text": " із " },
                  { "text": "return", "code": true },
                  { "text": " – для функціональних." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "beforeunload", "code": true },
                  {
                    "text": " – для випадків, коли потрібно реагувати на вихід із сторінки."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "37. How to run code before a component is removed from the tree?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "To execute code before a component is removed from the React tree, the following approaches are used:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Class components:", "bold": true },
                  { "text": " " },
                  { "text": "componentWillUnmount", "code": true },
                  {
                    "text": "Class components provide the componentWillUnmount lifecycle method, which is called right before the component is removed."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class MyComponent extends React.Component {\n  componentWillUnmount() {\n    console.log('Component will be removed');\n  }\n\n  render() {\n    return <div>My component</div>;\n  }\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Function components:", "bold": true },
                  { "text": " " },
                  { "text": "useEffect", "code": true },
                  { "text": " with cleanup" },
                  {
                    "text": "In function components, cleanup logic is implemented in useEffect by returning a function that runs before unmount."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    return () => {\n      console.log('Component will be removed');\n    };\n  }, []);\n\n  return <div>My component</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Handling page unload (beforeunload)",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "If code must be executed before closing or reloading the page:"
              }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "useEffect(() => {\n  const handleUnload = () => {\n    console.log('Page is closing');\n  };\n\n  window.addEventListener('beforeunload', handleUnload);\n  return () => window.removeEventListener('beforeunload', handleUnload);\n}, []);"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Conclusion" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "componentWillUnmount", "code": true },
                  { "text": " for class components." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useEffect", "code": true },
                  { "text": " with " },
                  { "text": "return", "code": true },
                  { "text": " for function components." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "beforeunload", "code": true },
                  { "text": " for reacting to page exit." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "37. Jak wykonać kod przed usunięciem komponentu z drzewa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Aby wykonać kod przed usunięciem komponentu z drzewa React, stosuje się następujące podejścia:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponenty klasowe:", "bold": true },
                  { "text": " " },
                  { "text": "componentWillUnmount", "code": true },
                  {
                    "text": "Dla komponentów klasowych dostępna jest metoda cyklu życia componentWillUnmount, wywoływana tuż przed usunięciem komponentu."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class MyComponent extends React.Component {\n  componentWillUnmount() {\n    console.log('Komponent zostanie usunięty');\n  }\n\n  render() {\n    return <div>Mój komponent</div>;\n  }\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponenty funkcyjne:", "bold": true },
                  { "text": " " },
                  { "text": "useEffect", "code": true },
                  { "text": " z czyszczeniem" },
                  {
                    "text": "W komponentach funkcyjnych logikę czyszczenia implementuje się w useEffect, zwracając funkcję wywoływaną przed odmontowaniem."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    return () => {\n      console.log('Komponent zostanie usunięty');\n    };\n  }, []);\n\n  return <div>Mój komponent</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Obsługa zamykania strony (beforeunload)",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jeśli konieczne jest wykonanie kodu przed zamknięciem karty lub przeładowaniem strony:"
              }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "useEffect(() => {\n  const handleUnload = () => {\n    console.log('Strona jest zamykana');\n  };\n\n  window.addEventListener('beforeunload', handleUnload);\n  return () => window.removeEventListener('beforeunload', handleUnload);\n}, []);"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wniosek" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "componentWillUnmount", "code": true },
                  { "text": " dla komponentów klasowych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useEffect", "code": true },
                  { "text": " z " },
                  { "text": "return", "code": true },
                  { "text": " dla komponentów funkcyjnych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "beforeunload", "code": true },
                  { "text": " do reagowania na opuszczenie strony." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 38,
    "translations": {
      "uk": {
        "question": "38. Чому фрагменти (Fragment) кращі за контейнерні div?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Фрагменти (" },
              { "text": "<React.Fragment>", "code": true },
              { "text": " або " },
              { "text": "<>...</>", "code": true },
              { "text": ") кращі за контейнерні " },
              { "text": "<div>", "code": true },
              { "text": " у React з кількох причин:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Зменшення зайвого HTML", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Фрагменти не додають додатковий елемент у DOM, що зменшує вкладеність і спрощує структуру."
                          },
                          {
                            "type": "code",
                            "language": "jsx",
                            "content": "<>\n  <h1>Title</h1>\n  <p>Text</p>\n</>"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Відсутність побічних ефектів стилів",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "<div>", "code": true },
                          {
                            "text": " може впливати на CSS і ламати верстку. Фрагменти цього не роблять."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Коректна робота з таблицями", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Фрагменти можна використовувати всередині table без порушення HTML-специфікації."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Продуктивність", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Менше DOM-вузлів означає швидший рендеринг і менше споживання памʼяті."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "38. Why are Fragments better than container divs?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Fragments (" },
              { "text": "<React.Fragment>", "code": true },
              { "text": " or " },
              { "text": "<>...</>", "code": true },
              { "text": ") are better than container " },
              { "text": "<div>", "code": true },
              { "text": " elements in React for several reasons:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Less unnecessary HTML", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Fragments do not add extra nodes to the DOM, keeping the markup clean."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "No styling side effects", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "<div>", "code": true },
                          {
                            "text": " wrappers can interfere with CSS layouts. Fragments avoid this."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Table compatibility", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Fragments can be used inside tables where div elements are invalid."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Performance", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Fewer DOM nodes result in faster rendering and lower memory usage."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "38. Dlaczego Fragmenty są lepsze niż kontenerowe divy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Fragmenty (" },
              { "text": "<React.Fragment>", "code": true },
              { "text": " lub " },
              { "text": "<>...</>", "code": true },
              { "text": ") są lepsze niż kontenerowe " },
              { "text": "<div>", "code": true },
              { "text": " w React z kilku powodów:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Mniej zbędnego HTML", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Fragmenty nie dodają dodatkowych elementów do DOM."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Brak efektów ubocznych stylów", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "<div>", "code": true },
                          {
                            "text": " może zaburzać CSS i układ strony. Fragmenty tego unikają."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zgodność z tabelami", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Fragmenty mogą być używane w tabelach, gdzie div jest niedozwolony."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wydajność", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Mniej węzłów DOM oznacza szybsze renderowanie i mniejsze zużycie pamięci."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 39,
    "translations": {
      "uk": {
        "question": "39. Що таке Хуки (Hooks) в React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Хуки (Hooks)", "bold": true },
              {
                "text": " – це функції, які дозволяють використовувати стан та інші можливості React без написання класів."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні типи хуків:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "useState", "bold": true },
                  {
                    "text": " – додає стан у функціональні компоненти."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const [state, setState] = useState(initialState);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useEffect", "bold": true },
                  {
                    "text": " – виконує побічні ефекти у функціональних компонентах."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "useEffect(() => {\n  // side effect\n}, [dependencies]);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useContext", "bold": true },
                  {
                    "text": " – доступ до значень контексту без Consumer."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const value = useContext(MyContext);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useRef", "bold": true },
                  {
                    "text": " – зберігає посилання або значення між рендерами без зміни стану."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const myRef = useRef(initialValue);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useReducer", "bold": true },
                  {
                    "text": " – керування складним станом через редуктор."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const [state, dispatch] = useReducer(reducer, initialState);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useMemo", "bold": true },
                  {
                    "text": " – мемоізує обчислення значень."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const memoizedValue = useMemo(() => compute(a, b), [a, b]);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useCallback", "bold": true },
                  {
                    "text": " – мемоізує функції."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const memoizedCallback = useCallback(() => {\n  // function\n}, [dependencies]);"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Функціональні компоненти:", "bold": true },
                  {
                    "text": " логіка без класів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Читабельність:", "bold": true },
                  {
                    "text": " логіка розділена на хуки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Повторне використання логіки:", "bold": true },
                  {
                    "text": " без складних ієрархій."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "39. What are Hooks in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Hooks", "bold": true },
              {
                "text": " are functions that let you use state and other React features without writing classes."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Main types of hooks:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "useState", "bold": true },
                  { "text": " adds state to function components." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const [state, setState] = useState(initialState);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useEffect", "bold": true },
                  { "text": " handles side effects." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "useEffect(() => {\n  // side effect\n}, [dependencies]);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useContext", "bold": true },
                  { "text": " accesses context values." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const value = useContext(MyContext);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useRef", "bold": true },
                  { "text": " stores mutable references." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const myRef = useRef(initialValue);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useReducer", "bold": true },
                  { "text": " manages complex state." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const [state, dispatch] = useReducer(reducer, initialState);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useMemo", "bold": true },
                  { "text": " memoizes computed values." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const memoizedValue = useMemo(() => compute(a, b), [a, b]);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useCallback", "bold": true },
                  { "text": " memoizes functions." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const memoizedCallback = useCallback(() => {}, [dependencies]);"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key benefits:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "No classes:", "bold": true },
                  { "text": " only functions." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Better readability:", "bold": true },
                  { "text": " logic is separated." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Reusable logic:", "bold": true },
                  { "text": " shared via hooks." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "39. Czym są Hooki (Hooks) w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Hooki React", "bold": true },
              {
                "text": " to funkcje umożliwiające korzystanie ze stanu i innych możliwości React bez użycia klas."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne typy hooków:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "useState", "bold": true },
                  { "text": " dodaje stan do komponentów funkcyjnych." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const [state, setState] = useState(initialState);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useEffect", "bold": true },
                  { "text": " obsługuje efekty uboczne." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "useEffect(() => {\n  // efekt\n}, [dependencies]);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useContext", "bold": true },
                  { "text": " daje dostęp do kontekstu." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const value = useContext(MyContext);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useRef", "bold": true },
                  { "text": " przechowuje referencje." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const myRef = useRef(initialValue);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useReducer", "bold": true },
                  { "text": " zarządza złożonym stanem." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const [state, dispatch] = useReducer(reducer, initialState);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useMemo", "bold": true },
                  { "text": " memoizuje wartości." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const memoizedValue = useMemo(() => compute(a, b), [a, b]);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useCallback", "bold": true },
                  { "text": " memoizuje funkcje." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const memoizedCallback = useCallback(() => {}, [dependencies]);"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponenty funkcyjne:", "bold": true },
                  { "text": " bez klas." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Czytelność:", "bold": true },
                  { "text": " prostsza struktura logiki." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wielokrotne użycie logiki:", "bold": true },
                  { "text": " współdzielenie przez hooki." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 40,
    "translations": {
      "uk": {
        "question": "40. Переваги Хуків (Hooks) в React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Перевага", "bold": true }],
              [{ "text": "Опис", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Менше коду", "bold": true }],
                [
                  {
                    "text": "Хуки дозволяють уникнути класів і зменшити обсяг коду."
                  }
                ]
              ],
              [
                [{ "text": "Краща читабельність", "bold": true }],
                [
                  {
                    "text": "Логіка в хуках простіша для читання та підтримки."
                  }
                ]
              ],
              [
                [{ "text": "Повторне використання логіки", "bold": true }],
                [
                  {
                    "text": "Custom Hooks дозволяють перевикористовувати логіку між компонентами."
                  }
                ]
              ],
              [
                [{ "text": "Спрощене управління станом", "bold": true }],
                [
                  { "text": "useState", "code": true },
                  { "text": " та " },
                  { "text": "useReducer", "code": true },
                  { "text": " спрощують роботу зі станом." }
                ]
              ],
              [
                [{ "text": "Гнучка робота з ефектами", "bold": true }],
                [
                  { "text": "useEffect", "code": true },
                  { "text": " замінює методи життєвого циклу класів." }
                ]
              ],
              [
                [{ "text": "Легша міграція", "bold": true }],
                [
                  {
                    "text": "Спрощує перехід з класових компонентів на функціональні."
                  }
                ]
              ]
            ]
          }
        ]
      },
      "en": {
        "question": "40. Advantages of Hooks in React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Advantage", "bold": true }],
              [{ "text": "Description", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Less code", "bold": true }],
                [{ "text": "Hooks eliminate classes and reduce boilerplate." }]
              ],
              [
                [{ "text": "Better readability", "bold": true }],
                [{ "text": "Logic is easier to understand and maintain." }]
              ],
              [
                [{ "text": "Logic reuse", "bold": true }],
                [
                  {
                    "text": "Custom Hooks allow sharing logic across components."
                  }
                ]
              ],
              [
                [{ "text": "Simpler state management", "bold": true }],
                [
                  { "text": "useState", "code": true },
                  { "text": " and " },
                  { "text": "useReducer", "code": true },
                  { "text": " simplify state handling." }
                ]
              ],
              [
                [{ "text": "Flexible effects handling", "bold": true }],
                [
                  { "text": "useEffect", "code": true },
                  { "text": " replaces class lifecycle methods." }
                ]
              ],
              [
                [{ "text": "Easier migration", "bold": true }],
                [{ "text": "Makes moving from class components easier." }]
              ]
            ]
          }
        ]
      },
      "pl": {
        "question": "40. Zalety Hooków (Hooks) w React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Zaleta", "bold": true }],
              [{ "text": "Opis", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Mniej kodu", "bold": true }],
                [{ "text": "Hooki eliminują klasy i zmniejszają ilość kodu." }]
              ],
              [
                [{ "text": "Lepsza czytelność", "bold": true }],
                [
                  {
                    "text": "Logika jest prostsza do zrozumienia i utrzymania."
                  }
                ]
              ],
              [
                [{ "text": "Ponowne użycie logiki", "bold": true }],
                [{ "text": "Custom Hooks umożliwiają współdzielenie logiki." }]
              ],
              [
                [{ "text": "Prostsze zarządzanie stanem", "bold": true }],
                [
                  { "text": "useState", "code": true },
                  { "text": " oraz " },
                  { "text": "useReducer", "code": true },
                  { "text": " upraszczają zarządzanie stanem." }
                ]
              ],
              [
                [{ "text": "Elastyczna obsługa efektów", "bold": true }],
                [
                  { "text": "useEffect", "code": true },
                  { "text": " zastępuje metody cyklu życia klas." }
                ]
              ],
              [
                [{ "text": "Łatwiejsza migracja", "bold": true }],
                [{ "text": "Ułatwia przejście z komponentów klasowych." }]
              ]
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 41,
    "translations": {
      "uk": {
        "question": "41. Недоліки Хуків (Hooks) в React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Недолік", "bold": true }],
              [{ "text": "Опис", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Зайві ререндери", "bold": true }],
                [
                  { "text": "Неправильне використання " },
                  { "text": "useEffect", "code": true },
                  { "text": " може спричиняти зайві оновлення компонента." }
                ]
              ],
              [
                [{ "text": "Розпорошена логіка", "bold": true }],
                [
                  { "text": "Логіка часто розділена між кількома " },
                  { "text": "useEffect", "code": true },
                  { "text": ", що ускладнює розуміння." }
                ]
              ],
              [
                [
                  { "text": "Відсутність явного життєвого циклу", "bold": true }
                ],
                [
                  {
                    "text": "Хуки не мають чітких lifecycle-методів, як у класових компонентів."
                  }
                ]
              ],
              [
                [{ "text": "Ризики оптимізації", "bold": true }],
                [
                  { "text": "Невірне використання " },
                  { "text": "useCallback", "code": true },
                  { "text": " та " },
                  { "text": "useMemo", "code": true },
                  { "text": " може погіршити продуктивність." }
                ]
              ],
              [
                [{ "text": "Складність у великих проєктах", "bold": true }],
                [
                  {
                    "text": "У масштабних додатках хуки ускладнюють контроль стану й ефектів."
                  }
                ]
              ]
            ]
          }
        ]
      },
      "en": {
        "question": "41. Disadvantages of Hooks in React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Drawback", "bold": true }],
              [{ "text": "Description", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Extra re-renders", "bold": true }],
                [
                  { "text": "Incorrect use of " },
                  { "text": "useEffect", "code": true },
                  { "text": " can cause unnecessary re-renders." }
                ]
              ],
              [
                [{ "text": "Scattered logic", "bold": true }],
                [
                  { "text": "Logic may be split across multiple " },
                  { "text": "useEffect", "code": true },
                  { "text": " hooks, complicating debugging." }
                ]
              ],
              [
                [{ "text": "No explicit lifecycle", "bold": true }],
                [
                  {
                    "text": "Hooks do not expose clear lifecycle methods like class components."
                  }
                ]
              ],
              [
                [{ "text": "Optimization pitfalls", "bold": true }],
                [
                  { "text": "Improper use of " },
                  { "text": "useCallback", "code": true },
                  { "text": " and " },
                  { "text": "useMemo", "code": true },
                  { "text": " can hurt performance." }
                ]
              ],
              [
                [{ "text": "Complexity at scale", "bold": true }],
                [
                  {
                    "text": "In large applications, hooks can complicate state and side-effect management."
                  }
                ]
              ]
            ]
          }
        ]
      },
      "pl": {
        "question": "41. Wady Hooków (Hooks) w React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Wada", "bold": true }],
              [{ "text": "Opis", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Nadmierne renderowanie", "bold": true }],
                [
                  { "text": "Nieprawidłowe użycie " },
                  { "text": "useEffect", "code": true },
                  { "text": " może powodować zbędne renderowania." }
                ]
              ],
              [
                [{ "text": "Rozproszona logika", "bold": true }],
                [
                  { "text": "Logika bywa podzielona między wiele " },
                  { "text": "useEffect", "code": true },
                  { "text": ", co utrudnia debugowanie." }
                ]
              ],
              [
                [{ "text": "Brak jawnego cyklu życia", "bold": true }],
                [
                  {
                    "text": "Hooki nie posiadają wyraźnych metod cyklu życia jak komponenty klasowe."
                  }
                ]
              ],
              [
                [{ "text": "Problemy z optymalizacją", "bold": true }],
                [
                  { "text": "Błędne użycie " },
                  { "text": "useCallback", "code": true },
                  { "text": " i " },
                  { "text": "useMemo", "code": true },
                  { "text": " może obniżyć wydajność." }
                ]
              ],
              [
                [{ "text": "Złożoność w dużych projektach", "bold": true }],
                [
                  {
                    "text": "W rozbudowanych aplikacjach hooki komplikują zarządzanie stanem i efektami."
                  }
                ]
              ]
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 42,
    "translations": {
      "uk": {
        "question": "42. Правила (обмеження) використання Хуків (Hooks) в React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Правило", "bold": true }],
              [{ "text": "Опис", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Використання тільки у функціях", "bold": true }],
                [
                  {
                    "text": "Хуки можна викликати лише у функціональних компонентах або в кастомних хуках."
                  }
                ]
              ],
              [
                [{ "text": "Збереження порядку виклику", "bold": true }],
                [
                  { "text": "Хуки не можна викликати умовно (" },
                  { "text": "if", "code": true },
                  { "text": ", " },
                  { "text": "for", "code": true },
                  { "text": ", " },
                  { "text": "while", "code": true },
                  { "text": "), інакше порушиться порядок виклику." }
                ]
              ],
              [
                [{ "text": "Виклик тільки на верхньому рівні", "bold": true }],
                [
                  {
                    "text": "Хуки не можна викликати всередині вкладених функцій або обробників подій."
                  }
                ]
              ],
              [
                [{ "text": "Іменування кастомних хуків", "bold": true }],
                [
                  { "text": "Кастомні хуки мають починатися з " },
                  { "text": "use", "code": true },
                  { "text": " (наприклад, " },
                  { "text": "useAuth", "code": true },
                  { "text": ")." }
                ]
              ],
              [
                [{ "text": "Коректні залежності", "bold": true }],
                [
                  { "text": "У " },
                  { "text": "useEffect", "code": true },
                  { "text": ", " },
                  { "text": "useMemo", "code": true },
                  { "text": " та " },
                  { "text": "useCallback", "code": true },
                  { "text": " масив залежностей (" },
                  { "text": "[]", "code": true },
                  { "text": ") має бути вказаний правильно." }
                ]
              ]
            ]
          }
        ]
      },
      "en": {
        "question": "42. Rules (limitations) for using Hooks in React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Rule", "bold": true }],
              [{ "text": "Description", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Use only in functions", "bold": true }],
                [
                  {
                    "text": "Hooks can only be called inside function components or custom hooks."
                  }
                ]
              ],
              [
                [{ "text": "Preserve call order", "bold": true }],
                [
                  { "text": "Hooks must not be called conditionally (" },
                  { "text": "if", "code": true },
                  { "text": ", " },
                  { "text": "for", "code": true },
                  { "text": ", " },
                  { "text": "while", "code": true },
                  { "text": "), otherwise the call order breaks." }
                ]
              ],
              [
                [{ "text": "Top-level only", "bold": true }],
                [
                  {
                    "text": "Hooks must not be called inside nested functions or event handlers."
                  }
                ]
              ],
              [
                [{ "text": "Custom hook naming", "bold": true }],
                [
                  { "text": "Custom hooks must start with " },
                  { "text": "use", "code": true },
                  { "text": " (for example, " },
                  { "text": "useAuth", "code": true },
                  { "text": ")." }
                ]
              ],
              [
                [{ "text": "Correct dependencies", "bold": true }],
                [
                  { "text": "In " },
                  { "text": "useEffect", "code": true },
                  { "text": ", " },
                  { "text": "useMemo", "code": true },
                  { "text": " and " },
                  { "text": "useCallback", "code": true },
                  { "text": " dependency arrays (" },
                  { "text": "[]", "code": true },
                  { "text": ") must be specified correctly." }
                ]
              ]
            ]
          }
        ]
      },
      "pl": {
        "question": "42. Zasady (ograniczenia) używania Hooków (Hooks) w React?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Zasada", "bold": true }],
              [{ "text": "Opis", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Użycie tylko w funkcjach", "bold": true }],
                [
                  {
                    "text": "Hooki można wywoływać wyłącznie w komponentach funkcyjnych lub hookach własnych."
                  }
                ]
              ],
              [
                [{ "text": "Zachowanie kolejności wywołań", "bold": true }],
                [
                  { "text": "Hooków nie wolno wywoływać warunkowo (" },
                  { "text": "if", "code": true },
                  { "text": ", " },
                  { "text": "for", "code": true },
                  { "text": ", " },
                  { "text": "while", "code": true },
                  { "text": "), ponieważ zaburza to kolejność wywołań." }
                ]
              ],
              [
                [{ "text": "Tylko na najwyższym poziomie", "bold": true }],
                [
                  {
                    "text": "Hooków nie wolno wywoływać wewnątrz zagnieżdżonych funkcji ani obsługi zdarzeń."
                  }
                ]
              ],
              [
                [{ "text": "Nazewnictwo hooków własnych", "bold": true }],
                [
                  { "text": "Hooki własne muszą zaczynać się od " },
                  { "text": "use", "code": true },
                  { "text": " (np. " },
                  { "text": "useAuth", "code": true },
                  { "text": ")." }
                ]
              ],
              [
                [{ "text": "Poprawne zależności", "bold": true }],
                [
                  { "text": "W " },
                  { "text": "useEffect", "code": true },
                  { "text": ", " },
                  { "text": "useMemo", "code": true },
                  { "text": " oraz " },
                  { "text": "useCallback", "code": true },
                  { "text": " tablice zależności (" },
                  { "text": "[]", "code": true },
                  { "text": ") muszą być określone poprawnie." }
                ]
              ]
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 43,
    "translations": {
      "uk": {
        "question": "43. Що таке useReducer()?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "useReducer()", "code": true },
              {
                "text": " – це хук у React для керування станом у функціональних компонентах. Він є альтернативою "
              },
              { "text": "useState()", "code": true },
              {
                "text": " і краще підходить для складної логіки оновлення стану."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Синтаксис:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const [state, dispatch] = useReducer(reducer, initialState);"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reducer", "code": true },
                  { "text": " – функція, що приймає " },
                  { "text": "state", "code": true },
                  { "text": " і " },
                  { "text": "action", "code": true },
                  { "text": " та повертає новий стан." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "initialState", "code": true },
                  { "text": " – початковий стан." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dispatch", "code": true },
                  { "text": " – викликає reducer з певною дією." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коли використовувати:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Складна логіка стану." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оновлення залежать від попереднього стану." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Потреба у централізованому dispatch." }]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "43. What is useReducer()?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "useReducer()", "code": true },
              {
                "text": " is a React hook used for state management in function components. It is an alternative to "
              },
              { "text": "useState()", "code": true },
              {
                "text": " and is suited for more complex state logic."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Syntax:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const [state, dispatch] = useReducer(reducer, initialState);"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reducer", "code": true },
                  { "text": " – a function that takes " },
                  { "text": "state", "code": true },
                  { "text": " and " },
                  { "text": "action", "code": true },
                  { "text": " and returns a new state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "initialState", "code": true },
                  { "text": " – the initial state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dispatch", "code": true },
                  { "text": " – triggers state updates via actions." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "When to use:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Complex state logic." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "State updates depend on previous state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Need for centralized state transitions." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "43. Czym jest useReducer()?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "useReducer()", "code": true },
              {
                "text": " to hook React służący do zarządzania stanem w komponentach funkcyjnych. Jest alternatywą dla "
              },
              { "text": "useState()", "code": true },
              {
                "text": " i sprawdza się przy bardziej złożonej logice stanu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Składnia:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const [state, dispatch] = useReducer(reducer, initialState);"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reducer", "code": true },
                  { "text": " – funkcja przyjmująca " },
                  { "text": "state", "code": true },
                  { "text": " i " },
                  { "text": "action", "code": true },
                  { "text": " oraz zwracająca nowy stan." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "initialState", "code": true },
                  { "text": " – stan początkowy." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dispatch", "code": true },
                  { "text": " – wywołuje reducer z akcją." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kiedy używać:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Złożona logika stanu." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zmiany zależne od poprzedniego stanu." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Potrzeba ujednoliconego dispatch." }]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 44,
    "translations": {
      "uk": {
        "question": "44. Розкажіть про хуки useCallback(), useMemo(), useImperativeHandle(), useLayoutEffect()?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useCallback()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Мемоізує функцію, щоб вона не створювалася заново при кожному рендері. Корисно при передачі колбеків у дочірні компоненти."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useMemo()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Мемоізує результат обчислень і повторно обчислюється лише при зміні залежностей."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useImperativeHandle()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Дозволяє явно контролювати API ref у дочірньому компоненті. Використовується разом із forwardRef()."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useLayoutEffect()" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Працює як " },
              { "text": "useEffect()", "code": true },
              {
                "text": ", але виконується синхронно після змін DOM і до відмальовування браузером."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коли який хук використовувати?" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "useCallback()", "code": true },
                  { "text": " – мемоізація функцій." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useMemo()", "code": true },
                  { "text": " – мемоізація обчислень." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useImperativeHandle()", "code": true },
                  { "text": " – контроль ref дочірнього компонента." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useLayoutEffect()", "code": true },
                  { "text": " – робота з DOM перед відображенням." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "44. Explain the hooks useCallback(), useMemo(), useImperativeHandle(), useLayoutEffect()?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useCallback()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Memoizes a function so it is not recreated on every render. Useful when passing callbacks to child components."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useMemo()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Memoizes computed values and recalculates them only when dependencies change."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useImperativeHandle()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Allows explicit control over the ref API exposed by a child component. Used with forwardRef()."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useLayoutEffect()" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Works like " },
              { "text": "useEffect()", "code": true },
              {
                "text": ", but runs synchronously after DOM mutations and before the browser paints."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "When to use each hook?" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "useCallback()", "code": true },
                  { "text": " – memoizing functions." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useMemo()", "code": true },
                  { "text": " – memoizing calculations." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useImperativeHandle()", "code": true },
                  { "text": " – controlling child refs." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useLayoutEffect()", "code": true },
                  { "text": " – DOM measurements before paint." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "44. Opisz hooki useCallback(), useMemo(), useImperativeHandle(), useLayoutEffect()?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useCallback()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Memoizuje funkcję, aby nie była tworzona ponownie przy każdym renderze. Przydatne przy przekazywaniu callbacków."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useMemo()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Memoizuje wynik obliczeń i przelicza go tylko po zmianie zależności."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useImperativeHandle()" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Pozwala jawnie kontrolować API ref udostępniane przez komponent potomny. Używany z forwardRef()."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "useLayoutEffect()" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Działa jak " },
              { "text": "useEffect()", "code": true },
              {
                "text": ", ale wykonuje się synchronicznie po zmianach DOM i przed renderowaniem."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kiedy używać danego hooka?" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "useCallback()", "code": true },
                  { "text": " – memoizacja funkcji." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useMemo()", "code": true },
                  { "text": " – memoizacja obliczeń." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useImperativeHandle()", "code": true },
                  { "text": " – kontrola ref komponentu potomnego." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useLayoutEffect()", "code": true },
                  { "text": " – operacje na DOM przed renderem." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 45,
    "translations": {
      "uk": {
        "question": "45. Як реалізувати одноразове виконання операції під час початкового рендерингу?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для виконання операції лише один раз під час початкового рендерингу у функціональних компонентах використовують "
              },
              { "text": "useEffect", "code": true },
              { "text": " з порожнім масивом залежностей (" },
              { "text": "[]", "code": true },
              { "text": ")." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    console.log('Виконається один раз після монтування');\n  }, []);\n\n  return <div>Компонент</div>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Пояснення:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Порожній масив залежностей означає виконання ефекту лише після першого рендерингу."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Підхід застосовується для ініціалізації, API-запитів або підписок."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "45. How to run an operation only once during the initial render?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "To execute an operation only once during the initial render in function components, use "
              },
              { "text": "useEffect", "code": true },
              { "text": " with an empty dependency array (" },
              { "text": "[]", "code": true },
              { "text": ")." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    console.log('Runs once after mount');\n  }, []);\n\n  return <div>Component</div>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Explanation:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "An empty dependency array ensures the effect runs only after the first render."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Commonly used for initialization, API calls, and subscriptions."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "45. Jak wykonać operację tylko raz podczas początkowego renderowania?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Aby wykonać operację tylko raz podczas pierwszego renderowania komponentu funkcyjnego, użyj "
              },
              { "text": "useEffect", "code": true },
              { "text": " z pustą tablicą zależności (" },
              { "text": "[]", "code": true },
              { "text": ")." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    console.log('Wykona się tylko raz po zamontowaniu');\n  }, []);\n\n  return <div>Komponent</div>;\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wyjaśnienie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Pusta tablica zależności powoduje jednorazowe wykonanie efektu."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Stosowane do inicjalizacji, zapytań API i subskrypcji."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 46,
    "translations": {
      "uk": {
        "question": "46. Що таке контекст (Context)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Контекст (Context)", "bold": true },
              {
                "text": " в React – це механізм для передачі даних через дерево компонентів без прокидання пропсів на кожному рівні."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює контекст:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.createContext()", "bold": true },
                  { "text": " – створює обʼєкт контексту." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const MyContext = React.createContext(defaultValue);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Provider", "bold": true },
                  {
                    "text": " – компонент, який передає значення контексту всім дочірнім компонентам."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<MyContext.Provider value={value}>\n  <Child />\n</MyContext.Provider>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Consumer", "bold": true },
                  {
                    "text": " – компонент для отримання значення контексту (застарілий підхід)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useContext", "bold": true },
                  {
                    "text": " – хук для доступу до контексту у функціональних компонентах."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const value = useContext(MyContext);"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коли використовувати:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Глобальні дані: тема, мова, користувач." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Уникнення prop drilling." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Менше пропсів у компонентах." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Краще масштабується для глобального стану." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "46. What is Context?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Context", "bold": true },
              {
                "text": " in React is a mechanism for passing data through the component tree without prop drilling."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How context works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.createContext()", "bold": true },
                  { "text": " creates a context object." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Provider", "bold": true },
                  { "text": " supplies the context value to child components." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Consumer", "bold": true },
                  { "text": " reads context values (legacy approach)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useContext", "bold": true },
                  { "text": " hook to access context values." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "When to use:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Global data like theme or user." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Avoiding prop drilling." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Cleaner component interfaces." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Better scalability for shared state." }]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "46. Czym jest Context?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Context", "bold": true },
              {
                "text": " w React to mechanizm przekazywania danych przez drzewo komponentów bez przekazywania propsów."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa context:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.createContext()", "bold": true },
                  { "text": " tworzy obiekt kontekstu." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Provider", "bold": true },
                  {
                    "text": " udostępnia wartość kontekstu komponentom potomnym."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Consumer", "bold": true },
                  { "text": " odbiera dane z kontekstu (podejście starsze)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "useContext", "bold": true },
                  { "text": " hook do korzystania z kontekstu." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kiedy używać:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Dane globalne: motyw, użytkownik." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Unikanie prop drilling." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Mniej propsów w komponentach." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Lepsza skalowalność wspólnego stanu." }]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 47,
    "translations": {
      "uk": {
        "question": "47. Як в React працює механізм контексту (Context) для спільної передачі даних між компонентами?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Context", "bold": true },
              {
                "text": " дозволяє передавати спільні дані між компонентами без прокидання пропсів через кожен рівень дерева."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні етапи:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Створення контексту:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const MyContext = React.createContext();"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Надання значення через Provider:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<MyContext.Provider value={value}>\n  <Child />\n</MyContext.Provider>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Отримання значення:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const value = useContext(MyContext);"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові моменти:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Уникає " },
                  { "text": "prop drilling", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Зміна значення контексту викликає ререндер усіх споживачів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Використовується для глобальних даних, не локального стану."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "47. How does the React Context mechanism work for sharing data between components?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Context", "bold": true },
              {
                "text": " allows sharing data across the component tree without passing props through every level."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Main steps:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Create context:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const MyContext = React.createContext();"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Provide value with Provider:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<MyContext.Provider value={value}>\n  <Child />\n</MyContext.Provider>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Consume value:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const value = useContext(MyContext);"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key points:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Avoids " },
                  { "text": "prop drilling", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "All consumers re-render when context value changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Best suited for global shared data." }]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "47. Jak działa mechanizm Context w React do współdzielenia danych między komponentami?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Context", "bold": true },
              {
                "text": " umożliwia przekazywanie danych w drzewie komponentów bez przekazywania propsów na każdym poziomie."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne kroki:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Utworzenie kontekstu:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const MyContext = React.createContext();"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Przekazanie wartości przez Provider:",
                    "bold": true
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<MyContext.Provider value={value}>\n  <Child />\n</MyContext.Provider>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Pobranie wartości:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const value = useContext(MyContext);"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kluczowe punkty:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Eliminuje " },
                  { "text": "prop drilling", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zmiana kontekstu powoduje render wszystkich konsumentów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Przeznaczony dla danych globalnych." }]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 48,
    "translations": {
      "uk": {
        "question": "48. Що таке буріння пропсів (Prop Drilling)? Як його уникнути?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Prop Drilling", "bold": true },
              {
                "text": " - це передача пропсів через кілька рівнів вкладених компонентів, навіть якщо вони потрібні лише в глибоко вкладеному компоненті. Це ускладнює підтримку коду та знижує його читабельність."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад Prop Drilling:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const Parent = () => {\n  const user = { name: 'John' };\n  return <Child user={user} />;\n};\n\nconst Child = ({ user }) => {\n  return <GrandChild user={user} />;\n};\n\nconst GrandChild = ({ user }) => {\n  return <p>Ім'я: {user.name}</p>;\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Тут " },
              { "text": "user", "code": true },
              { "text": " передається через " },
              { "text": "Child", "code": true },
              { "text": ", хоча він йому не потрібен. Це і є " },
              { "text": "буріння пропсів", "bold": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як уникнути Prop Drilling?" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Метод", "bold": true }],
              [{ "text": "Опис", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Context API", "bold": true }],
                [
                  {
                    "text": "Дозволяє передавати дані безпосередньо потрібним компонентам."
                  }
                ]
              ],
              [
                [
                  {
                    "text": "Зовнішні стейти (Redux, Zustand, Jotai, Recoil)",
                    "bold": true
                  }
                ],
                [
                  {
                    "text": "Глобальне управління станом без передачі пропсів."
                  }
                ]
              ],
              [
                [{ "text": "Render Props", "bold": true }],
                [
                  {
                    "text": "Передача логіки через функції, а не через пропси."
                  }
                ]
              ],
              [
                [{ "text": "Custom Hooks", "bold": true }],
                [
                  {
                    "text": "Винесення спільної логіки в повторно використовувані хуки."
                  }
                ]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Приклад використання Context API замість Prop Drilling"
              }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { createContext, useContext } from 'react';\n\nconst UserContext = createContext();\n\nconst Parent = () => {\n  const user = { name: 'John' };\n  return (\n    <UserContext.Provider value={user}>\n      <GrandChild />\n    </UserContext.Provider>\n  );\n};\n\nconst GrandChild = () => {\n  const user = useContext(UserContext);\n  return <p>Ім'я: {user.name}</p>;\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Тут " },
              { "text": "user", "code": true },
              { "text": " доступний напряму у " },
              { "text": "GrandChild", "code": true },
              { "text": ", без проміжних компонентів." }
            ]
          }
        ]
      },
      "en": {
        "question": "48. What is Prop Drilling? How can it be avoided?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Prop Drilling", "bold": true },
              {
                "text": " is the practice of passing props through multiple nested components even if they are only needed by a deeply nested child. It makes code harder to maintain and less readable."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Prop Drilling example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const Parent = () => {\n  const user = { name: 'John' };\n  return <Child user={user} />;\n};\n\nconst Child = ({ user }) => {\n  return <GrandChild user={user} />;\n};\n\nconst GrandChild = ({ user }) => {\n  return <p>Name: {user.name}</p>;\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Here " },
              { "text": "user", "code": true },
              { "text": " is passed through " },
              { "text": "Child", "code": true },
              { "text": " even though it does not use it. This is " },
              { "text": "Prop Drilling", "bold": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How to avoid Prop Drilling?" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Method", "bold": true }],
              [{ "text": "Description", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Context API", "bold": true }],
                [
                  {
                    "text": "Provides data directly to the components that need it."
                  }
                ]
              ],
              [
                [
                  {
                    "text": "External state (Redux, Zustand, Jotai, Recoil)",
                    "bold": true
                  }
                ],
                [{ "text": "Global state management without passing props." }]
              ],
              [
                [{ "text": "Render Props", "bold": true }],
                [{ "text": "Sharing logic via functions instead of props." }]
              ],
              [
                [{ "text": "Custom Hooks", "bold": true }],
                [{ "text": "Extracting shared logic into reusable hooks." }]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Using Context API instead of Prop Drilling" }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { createContext, useContext } from 'react';\n\nconst UserContext = createContext();\n\nconst Parent = () => {\n  const user = { name: 'John' };\n  return (\n    <UserContext.Provider value={user}>\n      <GrandChild />\n    </UserContext.Provider>\n  );\n};\n\nconst GrandChild = () => {\n  const user = useContext(UserContext);\n  return <p>Name: {user.name}</p>;\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Here " },
              { "text": "user", "code": true },
              { "text": " is accessed directly in " },
              { "text": "GrandChild", "code": true },
              { "text": " without intermediate components." }
            ]
          }
        ]
      },
      "pl": {
        "question": "48. Czym jest Prop Drilling? Jak go unikać?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Prop Drilling", "bold": true },
              {
                "text": " to przekazywanie propsów przez wiele zagnieżdżonych komponentów, mimo że są potrzebne tylko w głęboko zagnieżdżonym komponencie. Utrudnia to utrzymanie i czytelność kodu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład Prop Drilling:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const Parent = () => {\n  const user = { name: 'John' };\n  return <Child user={user} />;\n};\n\nconst Child = ({ user }) => {\n  return <GrandChild user={user} />;\n};\n\nconst GrandChild = ({ user }) => {\n  return <p>Imię: {user.name}</p>;\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Tutaj " },
              { "text": "user", "code": true },
              { "text": " jest przekazywany przez " },
              { "text": "Child", "code": true },
              { "text": ", mimo że komponent go nie używa. To jest " },
              { "text": "Prop Drilling", "bold": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak unikać Prop Drilling?" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Metoda", "bold": true }],
              [{ "text": "Opis", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Context API", "bold": true }],
                [
                  {
                    "text": "Umożliwia bezpośredni dostęp do danych w wymaganych komponentach."
                  }
                ]
              ],
              [
                [
                  {
                    "text": "Zewnętrzny stan (Redux, Zustand, Jotai, Recoil)",
                    "bold": true
                  }
                ],
                [
                  {
                    "text": "Globalne zarządzanie stanem bez przekazywania propsów."
                  }
                ]
              ],
              [
                [{ "text": "Render Props", "bold": true }],
                [
                  {
                    "text": "Przekazywanie logiki za pomocą funkcji zamiast propsów."
                  }
                ]
              ],
              [
                [{ "text": "Custom Hooks", "bold": true }],
                [
                  {
                    "text": "Wydzielenie wspólnej logiki do wielokrotnego użytku."
                  }
                ]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Użycie Context API zamiast Prop Drilling" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { createContext, useContext } from 'react';\n\nconst UserContext = createContext();\n\nconst Parent = () => {\n  const user = { name: 'John' };\n  return (\n    <UserContext.Provider value={user}>\n      <GrandChild />\n    </UserContext.Provider>\n  );\n};\n\nconst GrandChild = () => {\n  const user = useContext(UserContext);\n  return <p>Imię: {user.name}</p>;\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Tutaj " },
              { "text": "user", "code": true },
              { "text": " jest dostępny bezpośrednio w " },
              { "text": "GrandChild", "code": true },
              { "text": " bez pośrednich komponentów." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 49,
    "translations": {
      "uk": {
        "question": "49. Що таке Redux?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux", "bold": true },
              {
                "text": " - це бібліотека для керування станом у JavaScript-додатках, особливо популярна у React. Вона використовує глобальне сховище (store) для зберігання всього стану додатка та забезпечує передбачувані зміни стану."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні принципи Redux:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Єдине джерело правди", "bold": true },
                  { "text": " - весь стан зберігається в одному глобальному " },
                  { "text": "store", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Стан лише для читання", "bold": true },
                  { "text": " - змінюється тільки через " },
                  { "text": "action", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зміни через чисті функції", "bold": true },
                  { "text": " - ред’юсери отримують стан і " },
                  { "text": "action", "code": true },
                  { "text": ", повертаючи новий стан." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні елементи Redux:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Store", "bold": true },
                  { "text": " - єдине сховище стану." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Actions", "bold": true },
                  { "text": " - описують намір змінити стан." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Reducers", "bold": true },
                  { "text": " - визначають, як змінюється стан." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dispatch", "bold": true },
                  { "text": " - відправляє " },
                  { "text": "action", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Selectors", "bold": true },
                  { "text": " - отримують дані зі " },
                  { "text": "store", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Redux доцільний у великих додатках зі складною логікою стану. У малих проєктах часто надлишковий."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "49. What is Redux?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux", "bold": true },
              {
                "text": " is a state management library for JavaScript applications, commonly used with React. It relies on a single global store to hold application state and enforces predictable state changes."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core Redux principles:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Single source of truth", "bold": true },
                  { "text": " - the entire state is stored in one global " },
                  { "text": "store", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "State is read-only", "bold": true },
                  { "text": " - it can only be changed via " },
                  { "text": "actions", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Changes via pure functions", "bold": true },
                  { "text": " - reducers take state and an " },
                  { "text": "action", "code": true },
                  { "text": " and return new state." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Main Redux elements:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Store", "bold": true },
                  { "text": " - holds the application state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Actions", "bold": true },
                  { "text": " - describe state change intentions." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Reducers", "bold": true },
                  { "text": " - define how state changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dispatch", "bold": true },
                  { "text": " - sends an " },
                  { "text": "action", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Selectors", "bold": true },
                  { "text": " - extract data from the " },
                  { "text": "store", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Redux fits large applications with complex data flows. For simple apps, it is often unnecessary."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "49. Czym jest Redux?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux", "bold": true },
              {
                "text": " to biblioteka do zarządzania stanem w aplikacjach JavaScript, często używana z Reactem. Opiera się na jednym globalnym magazynie stanu (store) i przewidywalnych zmianach stanu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne zasady Redux:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Jedno źródło prawdy", "bold": true },
                  { "text": " - cały stan znajduje się w jednym " },
                  { "text": "store", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Stan tylko do odczytu", "bold": true },
                  { "text": " - zmiany zachodzą wyłącznie przez " },
                  { "text": "actions", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zmiany przez czyste funkcje", "bold": true },
                  { "text": " - reducery otrzymują stan i " },
                  { "text": "action", "code": true },
                  { "text": ", zwracając nowy stan." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne elementy Redux:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Store", "bold": true },
                  { "text": " - przechowuje stan aplikacji." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Actions", "bold": true },
                  { "text": " - opisują zamiar zmiany stanu." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Reducers", "bold": true },
                  { "text": " - określają sposób zmiany stanu." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dispatch", "bold": true },
                  { "text": " - wysyła " },
                  { "text": "action", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Selectors", "bold": true },
                  { "text": " - pobierają dane ze " },
                  { "text": "store", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Redux jest sensowny w dużych aplikacjach ze złożonym stanem. W prostych projektach bywa przerostem formy."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 50,
    "translations": {
      "uk": {
        "question": "50. Які ти ще знаєш бібліотеки керування станом у React, окрім Redux?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Окрім Redux, у React екосистемі існує кілька альтернативних бібліотек для керування станом:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React Context API", "bold": true },
                  {
                    "text": " - вбудований механізм React для передачі стану без пропсів. Підходить для простих і середніх додатків."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zustand", "bold": true },
                  {
                    "text": " - мінімалістична бібліотека без reducers та actions. Працює через хуки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Recoil", "bold": true },
                  {
                    "text": " - бібліотека з атомами та селекторами для побудови гнучкого глобального стану."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jotai", "bold": true },
                  {
                    "text": " - спрощений підхід на основі атомів із мінімальною конфігурацією."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MobX", "bold": true },
                  {
                    "text": " - реактивне керування станом на основі observables."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Effector", "bold": true },
                  {
                    "text": " - реактивна та декларативна бібліотека для складних потоків даних."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "XState", "bold": true },
                  {
                    "text": " - бібліотека для моделювання стану через машини станів."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Вибір бібліотеки залежить від складності логіки, масштабів додатка та вимог до керованості стану."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "50. What state management libraries do you know in React besides Redux?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Besides Redux, there are several alternative state management libraries in the React ecosystem:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React Context API", "bold": true },
                  {
                    "text": " - a built-in React mechanism for sharing state without prop drilling."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zustand", "bold": true },
                  {
                    "text": " - a lightweight library without reducers or actions, based on hooks."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Recoil", "bold": true },
                  {
                    "text": " - atom-based state management with selectors for derived data."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jotai", "bold": true },
                  {
                    "text": " - a simpler atom-based approach with minimal boilerplate."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MobX", "bold": true },
                  { "text": " - reactive state management using observables." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Effector", "bold": true },
                  {
                    "text": " - a reactive and declarative library for complex data flows."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "XState", "bold": true },
                  {
                    "text": " - state management based on finite state machines."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The choice depends on application size, complexity, and state control requirements."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "50. Jakie biblioteki do zarządzania stanem w React znasz poza Reduxem?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Poza Reduxem w ekosystemie React dostępnych jest kilka alternatywnych bibliotek do zarządzania stanem:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React Context API", "bold": true },
                  {
                    "text": " - wbudowany mechanizm React do udostępniania stanu bez propsów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zustand", "bold": true },
                  {
                    "text": " - lekka biblioteka bez reducerów i akcji, oparta na hookach."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Recoil", "bold": true },
                  {
                    "text": " - zarządzanie stanem oparte na atomach i selektorach."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jotai", "bold": true },
                  { "text": " - uproszczona wersja podejścia atomowego." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MobX", "bold": true },
                  {
                    "text": " - reaktywne zarządzanie stanem z użyciem observables."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Effector", "bold": true },
                  {
                    "text": " - reaktywna i deklaratywna biblioteka do złożonych przepływów danych."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "XState", "bold": true },
                  { "text": " - zarządzanie stanem przy użyciu maszyn stanów." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Dobór biblioteki zależy od skali projektu, złożoności logiki i wymagań dotyczących kontroli stanu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 51,
    "translations": {
      "uk": {
        "question": "51. Що таке Redux Thunk?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Thunk", "bold": true },
              {
                "text": " - це middleware для Redux, яке дозволяє виконувати асинхронні операції перед оновленням "
              },
              { "text": "store", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "За замовчуванням " },
              { "text": "dispatch", "code": true },
              {
                "text": " приймає лише об'єкти. Redux Thunk дозволяє передавати функції, що дає змогу:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Виконувати асинхронну логіку перед зміною стану." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Мати доступ до " },
                  { "text": "dispatch", "code": true },
                  { "text": " та " },
                  { "text": "getState", "code": true },
                  { "text": " усередині " },
                  { "text": "thunk", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад використання:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const fetchData = () => {\n  return async dispatch => {\n    dispatch({ type: 'FETCH_START' });\n    try {\n      const res = await fetch('https://api.example.com/data');\n      const data = await res.json();\n      dispatch({ type: 'FETCH_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_ERROR', error });\n    }\n  };\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Виклик: " },
              { "text": "dispatch(fetchData())", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коли використовувати:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Запити до API." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Складну або поетапну логіку оновлення стану." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Кілька dispatch в одній дії." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для складних сценаріїв асинхронності доцільні альтернативи на кшталт Redux Saga або RTK Query."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "51. What is Redux Thunk?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Thunk", "bold": true },
              {
                "text": " is a Redux middleware that allows running asynchronous logic before updating the "
              },
              { "text": "store", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "By default, " },
              { "text": "dispatch", "code": true },
              {
                "text": " accepts only plain objects. Redux Thunk allows dispatching functions, which makes it possible to:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Run asynchronous logic before state updates." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Access " },
                  { "text": "dispatch", "code": true },
                  { "text": " and " },
                  { "text": "getState", "code": true },
                  { "text": " inside a " },
                  { "text": "thunk", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usage example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const fetchData = () => {\n  return async dispatch => {\n    dispatch({ type: 'FETCH_START' });\n    try {\n      const res = await fetch('https://api.example.com/data');\n      const data = await res.json();\n      dispatch({ type: 'FETCH_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_ERROR', error });\n    }\n  };\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Call it with " },
              { "text": "dispatch(fetchData())", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "When to use:" }]
          },
          {
            "type": "bulletList",
            "children": [
              { "type": "listItem", "children": [{ "text": "API requests." }] },
              {
                "type": "listItem",
                "children": [{ "text": "Delayed or multi-step logic." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Multiple dispatches in a single action." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "For complex async flows, alternatives like Redux Saga or RTK Query are often a better fit."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "51. Czym jest Redux Thunk?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Thunk", "bold": true },
              {
                "text": " to middleware dla Redux, które umożliwia wykonywanie logiki asynchronicznej przed aktualizacją "
              },
              { "text": "store", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Domyślnie " },
              { "text": "dispatch", "code": true },
              {
                "text": " przyjmuje tylko obiekty. Redux Thunk pozwala dispatchować funkcje, co umożliwia:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wykonywanie operacji asynchronicznych przed zmianą stanu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dostęp do " },
                  { "text": "dispatch", "code": true },
                  { "text": " oraz " },
                  { "text": "getState", "code": true },
                  { "text": " wewnątrz " },
                  { "text": "thunk", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład użycia:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const fetchData = () => {\n  return async dispatch => {\n    dispatch({ type: 'FETCH_START' });\n    try {\n      const res = await fetch('https://api.example.com/data');\n      const data = await res.json();\n      dispatch({ type: 'FETCH_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_ERROR', error });\n    }\n  };\n};"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Wywołanie: " },
              { "text": "dispatch(fetchData())", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kiedy używać:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Zapytania do API." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Złożona logika asynchroniczna." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Wiele dispatchów w jednej akcji." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Przy bardzo złożonych scenariuszach asynchronicznych lepszym wyborem są Redux Saga lub RTK Query."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 52,
    "translations": {
      "uk": {
        "question": "52. Як працює Redux Saga?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Saga", "bold": true },
              {
                "text": " - це middleware для Redux, яке використовує генератори (function*) для керування асинхронною логікою та побічними ефектами."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Слухає екшени", "bold": true },
                  { "text": " (" },
                  { "text": "takeEvery", "code": true },
                  { "text": ", " },
                  { "text": "takeLatest", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Виконує побічні ефекти", "bold": true },
                  { "text": " (API, таймери, затримки)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Диспатчить нові екшени", "bold": true },
                  { "text": " через " },
                  { "text": "put", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Сага для запиту до API:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import { call, put, takeEvery } from 'redux-saga/effects';\n\nfunction* fetchData() {\n  try {\n    const response = yield call(fetch, 'https://api.example.com/data');\n    const data = yield response.json();\n    yield put({ type: 'FETCH_SUCCESS', payload: data });\n  } catch (error) {\n    yield put({ type: 'FETCH_ERROR', error });\n  }\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Слухач екшенів:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function* watchFetchData() {\n  yield takeEvery('FETCH_REQUEST', fetchData);\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги Redux Saga:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Контроль складної асинхронної логіки." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Підтримка скасувань через " },
                  { "text": "takeLatest", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Потужні ефекти: " },
                  { "text": "call", "code": true },
                  { "text": ", " },
                  { "text": "put", "code": true },
                  { "text": ", " },
                  { "text": "select", "code": true },
                  { "text": ", " },
                  { "text": "delay", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Thunk", "bold": true },
              { "text": " простіший, але для складних сценаріїв " },
              { "text": "Redux Saga", "bold": true },
              { "text": " ефективніша." }
            ]
          }
        ]
      },
      "en": {
        "question": "52. How does Redux Saga work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Saga", "bold": true },
              {
                "text": " is a Redux middleware that uses generator functions (function*) to manage asynchronous logic and side effects."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Listens to actions", "bold": true },
                  { "text": " via " },
                  { "text": "takeEvery", "code": true },
                  { "text": " and " },
                  { "text": "takeLatest", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Executes side effects", "bold": true },
                  { "text": " such as API calls or delays." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dispatches new actions", "bold": true },
                  { "text": " using " },
                  { "text": "put", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Saga handling API request:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import { call, put, takeEvery } from 'redux-saga/effects';\n\nfunction* fetchData() {\n  try {\n    const response = yield call(fetch, 'https://api.example.com/data');\n    const data = yield response.json();\n    yield put({ type: 'FETCH_SUCCESS', payload: data });\n  } catch (error) {\n    yield put({ type: 'FETCH_ERROR', error });\n  }\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages of Redux Saga:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Handles complex async workflows." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Built-in cancellation with " },
                  { "text": "takeLatest", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Powerful effects: " },
                  { "text": "call", "code": true },
                  { "text": ", " },
                  { "text": "put", "code": true },
                  { "text": ", " },
                  { "text": "select", "code": true },
                  { "text": ", " },
                  { "text": "delay", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Thunk", "bold": true },
              { "text": " is simpler, but " },
              { "text": "Redux Saga", "bold": true },
              { "text": " is better suited for complex async logic." }
            ]
          }
        ]
      },
      "pl": {
        "question": "52. Jak działa Redux Saga?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Saga", "bold": true },
              {
                "text": " to middleware dla Redux, które wykorzystuje generatory (function*) do obsługi logiki asynchronicznej i efektów ubocznych."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Nasłuchuje akcje", "bold": true },
                  { "text": " przez " },
                  { "text": "takeEvery", "code": true },
                  { "text": " oraz " },
                  { "text": "takeLatest", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wykonuje efekty uboczne", "bold": true },
                  { "text": " jak zapytania API lub opóźnienia." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wysyła nowe akcje", "bold": true },
                  { "text": " za pomocą " },
                  { "text": "put", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Saga obsługująca API:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import { call, put, takeEvery } from 'redux-saga/effects';\n\nfunction* fetchData() {\n  try {\n    const response = yield call(fetch, 'https://api.example.com/data');\n    const data = yield response.json();\n    yield put({ type: 'FETCH_SUCCESS', payload: data });\n  } catch (error) {\n    yield put({ type: 'FETCH_ERROR', error });\n  }\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety Redux Saga:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Obsługa złożonej logiki asynchronicznej." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Obsługa anulowania przez " },
                  { "text": "takeLatest", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Bogaty zestaw efektów: " },
                  { "text": "call", "code": true },
                  { "text": ", " },
                  { "text": "put", "code": true },
                  { "text": ", " },
                  { "text": "select", "code": true },
                  { "text": ", " },
                  { "text": "delay", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Redux Thunk", "bold": true },
              { "text": " jest prostszy, ale " },
              { "text": "Redux Saga", "bold": true },
              { "text": " lepiej sprawdza się w złożonych przypadkach." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 53,
    "translations": {
      "uk": {
        "question": "53. Що таке React Fiber?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Fiber", "bold": true },
              {
                "text": " - це внутрішня архітектура рендерингу React, представлена з версії 16. Вона створена для підвищення продуктивності, підтримки асинхронного рендерингу та кращого керування оновленнями UI."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові особливості React Fiber:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Переривний рендеринг", "bold": true },
                  {
                    "text": " - React може зупиняти, відкладати або відновлювати рендеринг для обробки важливіших задач."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Асинхронний підхід", "bold": true },
                  {
                    "text": " - рендеринг виконується частинами без блокування головного потоку."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Пріоритети оновлень", "bold": true },
                  {
                    "text": " - різні типи оновлень UI мають різний пріоритет."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Розбиття на підзадачі", "bold": true },
                  {
                    "text": " - рендеринг поділяється на дрібні етапи, між якими React може обробляти події."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Fiber є фундаментом для Concurrent Rendering, Suspense та сучасних механізмів оптимізації React."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "53. What is React Fiber?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Fiber", "bold": true },
              {
                "text": " is the internal rendering architecture of React introduced in version 16. It was designed to improve performance, enable asynchronous rendering, and provide better control over UI updates."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key features of React Fiber:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Interruptible rendering", "bold": true },
                  {
                    "text": " - React can pause, resume, or cancel rendering work."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Asynchronous rendering", "bold": true },
                  {
                    "text": " - rendering work is split into chunks without blocking the main thread."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Update prioritization", "bold": true },
                  {
                    "text": " - different updates have different priorities."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Task scheduling", "bold": true },
                  {
                    "text": " - rendering is broken into small units that can yield to other tasks."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React Fiber is the foundation for Concurrent Rendering, Suspense, and modern React performance optimizations."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "53. Czym jest React Fiber?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Fiber", "bold": true },
              {
                "text": " to wewnętrzna architektura renderowania Reacta wprowadzona w wersji 16. Została zaprojektowana w celu poprawy wydajności, obsługi renderowania asynchronicznego oraz lepszego zarządzania aktualizacjami UI."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kluczowe cechy React Fiber:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Renderowanie przerywalne", "bold": true },
                  {
                    "text": " - React może wstrzymywać i wznawiać proces renderowania."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Renderowanie asynchroniczne", "bold": true },
                  {
                    "text": " - praca renderowania jest dzielona na części."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Priorytety aktualizacji", "bold": true },
                  {
                    "text": " - różne aktualizacje mają różny priorytet."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Planowanie zadań", "bold": true },
                  {
                    "text": " - renderowanie jest podzielone na małe jednostki pracy."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React Fiber stanowi podstawę dla Concurrent Rendering, Suspense i nowoczesnych optymalizacji Reacta."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 54,
    "translations": {
      "uk": {
        "question": "54. Що таке Lifting State Up у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Lifting State Up", "bold": true },
              {
                "text": " - це підхід у React, за якого стан піднімається до найближчого спільного батьківського компонента, щоб кілька дочірніх компонентів могли використовувати одні й ті самі дані."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основна ідея:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Компоненти зі спільними даними не повинні зберігати окремі стани.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Стан зберігається у спільного батьківського компонента і передається вниз через props.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як це працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Батьківський компонент зберігає стан.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Він передає стан і функції його оновлення дочірнім компонентам через props.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Дочірні компоненти повідомляють про зміни через передані callback-функції.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Lifting State Up використовується для синхронізації UI без глобального стану."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "54. What is Lifting State Up in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Lifting State Up", "bold": true },
              {
                "text": " is a React pattern where state is moved to the closest common parent component so multiple child components can share the same data."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core idea:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Components that share data should not maintain separate local state.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "State is stored in a common parent and passed down via props.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The parent component owns the state.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "It passes state and update functions to children via props.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Children notify the parent about changes using callbacks.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Lifting State Up enables shared state without introducing global state management."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "54. Czym jest Lifting State Up w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Lifting State Up", "bold": true },
              {
                "text": " to podejście w React, w którym stan jest przenoszony do najbliższego wspólnego komponentu nadrzędnego, aby mógł być współdzielony przez komponenty potomne."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główna idea:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Komponenty współdzielące dane nie powinny mieć oddzielnego stanu.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Stan znajduje się w komponencie nadrzędnym i jest przekazywany przez props.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak to działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Komponent nadrzędny przechowuje stan.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Przekazuje stan i funkcje aktualizacji do komponentów potomnych.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Komponenty potomne informują o zmianach za pomocą callbacków.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Lifting State Up pozwala synchronizować UI bez użycia globalnego stanu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 55,
    "translations": {
      "uk": {
        "question": "55. Що таке контрольовані компоненти (Controlled Components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Контрольовані компоненти",
                "bold": true
              },
              {
                "text": " — це компоненти React, у яких значення елементів форми повністю контролюється станом компонента через "
              },
              { "text": "state", "code": true },
              {
                "text": ". Усі зміни відбуваються через обробники подій."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як це працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Значення форми зберігається у state.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Подія onChange оновлює state.", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "UI завжди відображає актуальний state.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Цей підхід забезпечує повний контроль над даними форми та спрощує валідацію."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "55. What are Controlled Components?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Controlled Components", "bold": true },
              {
                "text": " are React components where form values are fully controlled by component state via "
              },
              { "text": "state", "code": true },
              {
                "text": ". All changes are handled through event handlers."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Form values are stored in state.", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "onChange updates the state.", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "UI always reflects the current state.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This pattern provides predictable behavior and easier validation for forms."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "55. Czym są kontrolowane komponenty (Controlled Components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Kontrolowane komponenty", "bold": true },
              {
                "text": " to komponenty React, w których wartości formularza są w pełni kontrolowane przez stan komponentu za pomocą "
              },
              { "text": "state", "code": true },
              {
                "text": ". Wszystkie zmiany obsługiwane są przez zdarzenia."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak to działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wartości formularza są przechowywane w stanie.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zdarzenie onChange aktualizuje stan.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Interfejs zawsze odzwierciedla aktualny stan.",
                    "bold": true
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Takie podejście zapewnia przewidywalność i łatwiejszą walidację formularzy."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 56,
    "translations": {
      "uk": {
        "question": "56. Що таке неконтрольовані компоненти (Uncontrolled Components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Неконтрольовані компоненти", "bold": true },
              {
                "text": " — це React-компоненти, у яких значення елементів форми зберігаються безпосередньо в DOM, а не в "
              },
              { "text": "state", "code": true },
              {
                "text": " React. Доступ до значень здійснюється через "
              },
              { "text": "ref", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні характеристики:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Стан керується DOM.", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Не використовує useState або setState.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Значення отримуються через refs.", "bold": true }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Підхід корисний для простих форм або інтеграції зі сторонніми бібліотеками."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "56. What are Uncontrolled Components?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Uncontrolled Components", "bold": true },
              {
                "text": " are React components where form values are stored directly in the DOM instead of React "
              },
              { "text": "state", "code": true },
              {
                "text": ". Values are accessed using "
              },
              { "text": "refs", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key characteristics:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "State is managed by the DOM.", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Does not rely on useState or setState.",
                    "bold": true
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Values are accessed via refs.", "bold": true }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This approach is suitable for simple forms or integration with non-React libraries."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "56. Czym są komponenty niekontrolowane (Uncontrolled Components)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Komponenty niekontrolowane", "bold": true },
              {
                "text": " to komponenty React, w których wartości formularza są przechowywane bezpośrednio w DOM, a nie w "
              },
              { "text": "state", "code": true },
              {
                "text": " Reacta. Dostęp do wartości odbywa się za pomocą "
              },
              { "text": "ref", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne cechy:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Stan jest zarządzany przez DOM.", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Brak użycia useState lub setState.", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dostęp do danych przez refs.", "bold": true }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Podejście sprawdza się w prostych formularzach lub przy integracji z zewnętrznymi bibliotekami."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 57,
    "translations": {
      "uk": {
        "question": "57. Як створити форму в React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Форми в React будуються на базі HTML-елемента "
              },
              { "text": "<form>", "code": true },
              {
                "text": " і можуть бути реалізовані як керовані або некеровані компоненти."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Керована форма:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Значення полів зберігаються у "
              },
              { "text": "state", "code": true },
              {
                "text": " та оновлюються через обробники подій."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Некерована форма:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Значення полів зберігаються у DOM, доступ здійснюється через "
              },
              { "text": "ref", "code": true },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Керовані форми підходять для складної логіки та валідації. Некеровані — для простих сценаріїв."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "57. How do you create a form in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Forms in React are built using the "
              },
              { "text": "<form>", "code": true },
              {
                "text": " element and can be implemented as controlled or uncontrolled components."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Controlled form:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Form values are stored in "
              },
              { "text": "state", "code": true },
              {
                "text": " and updated via event handlers."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Uncontrolled form:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Form values are stored in the DOM and accessed using "
              },
              { "text": "ref", "code": true },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Controlled forms are better for complex logic and validation. Uncontrolled forms suit simple cases."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "57. Jak utworzyć formularz w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Formularze w React tworzy się przy użyciu elementu "
              },
              { "text": "<form>", "code": true },
              {
                "text": " i realizuje jako komponenty kontrolowane lub niekontrolowane."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Formularz kontrolowany:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wartości pól są przechowywane w "
              },
              { "text": "state", "code": true },
              {
                "text": " i aktualizowane przez obsługę zdarzeń."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Formularz niekontrolowany:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wartości pól są przechowywane w DOM, a dostęp odbywa się przez "
              },
              { "text": "ref", "code": true },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Formularze kontrolowane są lepsze dla złożonej logiki. Niekontrolowane sprawdzają się w prostych przypadkach."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 58,
    "translations": {
      "uk": {
        "question": "58. Як застосувати перевірку пропсів (props) у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для перевірки пропсів у React використовують ",
                "bold": false
              },
              {
                "text": "PropTypes",
                "bold": true
              },
              {
                "text": ". Вони дозволяють перевіряти типи пропсів під час розробки."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад використання:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import PropTypes from 'prop-types';\n\nfunction UserCard({ name, age }) {\n  return <div>{name} ({age})</div>;\n}\n\nUserCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "PropTypes виконують перевірку лише під час розробки та не впливають на runtime у продакшені."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "58. How do you validate props in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "To validate props in React, developers use ",
                "bold": false
              },
              {
                "text": "PropTypes",
                "bold": true
              },
              {
                "text": ". They provide runtime type checking during development."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usage example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import PropTypes from 'prop-types';\n\nfunction UserCard({ name, age }) {\n  return <div>{name} ({age})</div>;\n}\n\nUserCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "PropTypes are checked only in development mode and do not enforce types at runtime in production."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "58. Jak sprawdzić poprawność propsów w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Do walidacji propsów w React używa się ",
                "bold": false
              },
              {
                "text": "PropTypes",
                "bold": true
              },
              {
                "text": ", które umożliwiają sprawdzanie typów podczas developmentu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład użycia:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import PropTypes from 'prop-types';\n\nfunction UserCard({ name, age }) {\n  return <div>{name} ({age})</div>;\n}\n\nUserCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "PropTypes działają wyłącznie w trybie developerskim i nie zapewniają bezpieczeństwa typów w produkcji."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 59,
    "translations": {
      "uk": {
        "question": "59. Чим React Router відрізняється від звичайної маршрутизації?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Різниця між React Router і звичайною маршрутизацією:" }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Критерій", "bold": true }],
              [{ "text": "React Router", "bold": true }],
              [{ "text": "Звичайна маршрутизація (Server-Side)", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Тип маршрутизації", "bold": true }],
                [{ "text": "Клієнтська (SPA)" }],
                [{ "text": "Серверна (MPA)" }]
              ],
              [
                [{ "text": "Навігація", "bold": true }],
                [{ "text": "Без перезавантаження сторінки" }],
                [{ "text": "З повним перезавантаженням" }]
              ],
              [
                [{ "text": "Продуктивність", "bold": true }],
                [{ "text": "Вища після першого завантаження" }],
                [{ "text": "Нижча через повторні запити" }]
              ],
              [
                [{ "text": "SEO", "bold": true }],
                [{ "text": "Потребує SSR для повної підтримки" }],
                [{ "text": "Добра за замовчуванням" }]
              ],
              [
                [{ "text": "Рендеринг", "bold": true }],
                [{ "text": "Компоненти React" }],
                [{ "text": "HTML з сервера" }]
              ]
            ]
          }
        ]
      },
      "en": {
        "question": "59. How is React Router different from traditional routing?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Difference between React Router and traditional routing:"
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Criterion", "bold": true }],
              [{ "text": "React Router", "bold": true }],
              [{ "text": "Traditional Routing (Server-Side)", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Routing type", "bold": true }],
                [{ "text": "Client-side (SPA)" }],
                [{ "text": "Server-side (MPA)" }]
              ],
              [
                [{ "text": "Navigation", "bold": true }],
                [{ "text": "No page reload" }],
                [{ "text": "Full page reload" }]
              ],
              [
                [{ "text": "Performance", "bold": true }],
                [{ "text": "Faster after initial load" }],
                [{ "text": "Slower due to repeated requests" }]
              ],
              [
                [{ "text": "SEO", "bold": true }],
                [{ "text": "Requires SSR for full support" }],
                [{ "text": "Good by default" }]
              ],
              [
                [{ "text": "Rendering", "bold": true }],
                [{ "text": "React components" }],
                [{ "text": "Server-rendered HTML" }]
              ]
            ]
          }
        ]
      },
      "pl": {
        "question": "59. Czym różni się React Router od tradycyjnego routingu?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Różnice między React Router a tradycyjnym routingiem:"
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Kryterium", "bold": true }],
              [{ "text": "React Router", "bold": true }],
              [{ "text": "Routing tradycyjny (Server-Side)", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Typ routingu", "bold": true }],
                [{ "text": "Kliencki (SPA)" }],
                [{ "text": "Serwerowy (MPA)" }]
              ],
              [
                [{ "text": "Nawigacja", "bold": true }],
                [{ "text": "Bez przeładowania strony" }],
                [{ "text": "Z przeładowaniem strony" }]
              ],
              [
                [{ "text": "Wydajność", "bold": true }],
                [{ "text": "Wyższa po starcie" }],
                [{ "text": "Niższa przez kolejne żądania" }]
              ],
              [
                [{ "text": "SEO", "bold": true }],
                [{ "text": "Wymaga SSR" }],
                [{ "text": "Dobre domyślnie" }]
              ],
              [
                [{ "text": "Renderowanie", "bold": true }],
                [{ "text": "Komponenty React" }],
                [{ "text": "HTML z serwera" }]
              ]
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 60,
    "translations": {
      "uk": {
        "question": "60. Як передавати пропси в React Router?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У React Router пропси передаються не напряму, а через маршрути, навігацію або параметри URL."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Через Route (React Router v5)", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<Route path=\"/profile\" render={props => <Profile {...props} user=\"John\" />} />"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Через навігацію (state)", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "navigate('/profile', { state: { user: 'John' } });"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Через параметри маршруту", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const { id } = useParams();"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У React Router v6 основні способи — state навігації та параметри URL."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "60. How do you pass props in React Router?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In React Router, props are passed indirectly via routes, navigation state, or URL parameters."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Via Route (React Router v5)", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<Route path=\"/profile\" render={props => <Profile {...props} user=\"John\" />} />"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Via navigation state", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "navigate('/profile', { state: { user: 'John' } });"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Via URL parameters", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const { id } = useParams();"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In React Router v6, navigation state and URL params are the primary approaches."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "60. Jak przekazywać propsy w React Router?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W React Router propsy przekazuje się pośrednio przez routing, stan nawigacji lub parametry URL."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Przez Route (React Router v5)", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<Route path=\"/profile\" render={props => <Profile {...props} user=\"John\" />} />"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przez state nawigacji", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "navigate('/profile', { state: { user: 'John' } });"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przez parametry URL", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const { id } = useParams();"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W React Router v6 główne metody to state nawigacji i parametry URL."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 61,
    "translations": {
      "uk": {
        "question": "61. Способи стилізації в React-компонентах?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні способи стилізації в React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Inline-стилі", "bold": true },
                  { "text": " — стилі передаються через атрибут " },
                  { "text": "style", "code": true },
                  { "text": " у вигляді JS-об’єкта." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CSS-файли", "bold": true },
                  { "text": " — класичні CSS, імпортовані в компонент." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CSS Modules", "bold": true },
                  { "text": " — локальна ізоляція стилів на рівні компонента." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "CSS-in-JS (styled-components, Emotion)",
                    "bold": true
                  },
                  { "text": " — стилі описуються безпосередньо в JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Utility-first (Tailwind CSS)", "bold": true },
                  { "text": " — стилізація через готові utility-класи." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sass / SCSS", "bold": true },
                  { "text": " — розширений CSS з вкладеністю та змінними." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Вибір підходу залежить від масштабу проєкту, вимог до ізоляції стилів та підходів команди."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "61. What styling approaches are used in React components?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Main styling approaches in React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Inline styles", "bold": true },
                  { "text": " — styles passed via the " },
                  { "text": "style", "code": true },
                  { "text": " prop as a JS object." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CSS files", "bold": true },
                  { "text": " — traditional CSS imported into components." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CSS Modules", "bold": true },
                  { "text": " — locally scoped styles per component." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "CSS-in-JS (styled-components, Emotion)",
                    "bold": true
                  },
                  { "text": " — styles written directly in JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Utility-first (Tailwind CSS)", "bold": true },
                  { "text": " — styling via predefined utility classes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sass / SCSS", "bold": true },
                  { "text": " — extended CSS with variables and nesting." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The choice depends on project scale, style isolation needs, and team preferences."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "61. Jakie są sposoby stylizacji komponentów w React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne sposoby stylizacji w React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Style inline", "bold": true },
                  { "text": " — przekazywane przez atrybut " },
                  { "text": "style", "code": true },
                  { "text": " jako obiekt JS." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Pliki CSS", "bold": true },
                  {
                    "text": " — klasyczne arkusze CSS importowane do komponentów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CSS Modules", "bold": true },
                  { "text": " — lokalna izolacja stylów." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "CSS-in-JS (styled-components, Emotion)",
                    "bold": true
                  },
                  { "text": " — style definiowane w JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Utility-first (Tailwind CSS)", "bold": true },
                  { "text": " — stylizacja za pomocą klas użytkowych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sass / SCSS", "bold": true },
                  { "text": " — rozszerzony CSS z dodatkowymi możliwościami." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Dobór metody zależy od skali projektu, potrzeby izolacji stylów i preferencji zespołu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 62,
    "translations": {
      "uk": {
        "question": "62. У чому перевага модульних стилів (CSS Modules)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "CSS Modules", "bold": true },
              {
                "text": " — це підхід до стилізації, який забезпечує локальну область видимості стилів на рівні компонента."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Локальний scope", "bold": true },
                  {
                    "text": " — стилі застосовуються лише до конкретного компонента і не конфліктують з іншими."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Унікальні імена класів", "bold": true },
                  {
                    "text": " — імена генеруються автоматично, що усуває перезапис стилів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Простіше масштабування", "bold": true },
                  {
                    "text": " — стилі залишаються керованими у великих проєктах."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "CSS Modules зменшують кількість помилок і спрощують підтримку стилів."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "62. What are the advantages of CSS Modules?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "CSS Modules", "bold": true },
              {
                "text": " provide locally scoped styles at the component level."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Local scope", "bold": true },
                  {
                    "text": " — styles apply only to the component and avoid global conflicts."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Unique class names", "bold": true },
                  {
                    "text": " — class names are automatically generated, preventing overrides."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Easier maintenance", "bold": true },
                  {
                    "text": " — styles remain manageable as the project grows."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "CSS Modules help keep styles predictable and isolated."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "62. Jakie są zalety CSS Modules?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "CSS Modules", "bold": true },
              {
                "text": " zapewniają lokalny zakres stylów na poziomie komponentu."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lokalny zakres", "bold": true },
                  {
                    "text": " — style dotyczą tylko danego komponentu i nie kolidują z innymi."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Unikalne nazwy klas", "bold": true },
                  {
                    "text": " — generowane automatycznie, bez ryzyka nadpisania."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Łatwiejsze utrzymanie", "bold": true },
                  {
                    "text": " — style są czytelniejsze w dużych projektach."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "CSS Modules pomagają utrzymać porządek i izolację stylów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 63,
    "translations": {
      "uk": {
        "question": "63. Які підходи ви знаєте для оптимізації продуктивності React-додатків?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Мемоїзація компонентів", "bold": true },
                  {
                    "text": " — використання ",
                    "bold": false
                  },
                  { "text": "React.memo", "code": true },
                  { "text": " та " },
                  { "text": "PureComponent", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Мемоїзація значень і функцій", "bold": true },
                  {
                    "text": " — ",
                    "bold": false
                  },
                  { "text": "useMemo", "code": true },
                  { "text": ", " },
                  { "text": "useCallback", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Code Splitting", "bold": true },
                  {
                    "text": " — динамічні імпорти з ",
                    "bold": false
                  },
                  { "text": "React.lazy", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Віртуалізація списків", "bold": true },
                  {
                    "text": " — рендер лише видимих елементів",
                    "bold": false
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Контроль ререндерів", "bold": true },
                  {
                    "text": " — уникайте зайвих оновлень",
                    "bold": false
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оптимізація стану", "bold": true },
                  {
                    "text": " — мінімальний і локальний state",
                    "bold": false
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ключова ідея: менше ререндерів, менше DOM, менше роботи в main thread."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "63. What approaches are used to optimize React application performance?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Component memoization", "bold": true },
                  { "text": " — using " },
                  { "text": "React.memo", "code": true },
                  { "text": " and " },
                  { "text": "PureComponent", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Memoizing values and callbacks", "bold": true },
                  { "text": " — " },
                  { "text": "useMemo", "code": true },
                  { "text": ", " },
                  { "text": "useCallback", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Code splitting", "bold": true },
                  { "text": " — dynamic imports with " },
                  { "text": "React.lazy", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "List virtualization", "bold": true },
                  { "text": " — render only visible items" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Render control", "bold": true },
                  { "text": " — avoid unnecessary re-renders" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "State optimization", "bold": true },
                  { "text": " — keep state minimal and local" }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Core principle: reduce renders, DOM nodes, and main-thread work."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "63. Jakie podejścia stosuje się do optymalizacji wydajności aplikacji React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Memoizacja komponentów", "bold": true },
                  { "text": " — " },
                  { "text": "React.memo", "code": true },
                  { "text": ", " },
                  { "text": "PureComponent", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Memoizacja wartości i funkcji", "bold": true },
                  { "text": " — " },
                  { "text": "useMemo", "code": true },
                  { "text": ", " },
                  { "text": "useCallback", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Code splitting", "bold": true },
                  { "text": " — dynamiczne importy z " },
                  { "text": "React.lazy", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wirtualizacja list", "bold": true },
                  { "text": " — renderowanie tylko widocznych elementów" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontrola renderowania", "bold": true },
                  { "text": " — unikanie zbędnych renderów" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optymalizacja stanu", "bold": true },
                  { "text": " — minimalny i lokalny state" }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zasada: mniej renderów, mniej DOM i mniej pracy w głównym wątku."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 64,
    "translations": {
      "uk": {
        "question": "64. Різниця між memo і useMemo?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Різниця між memo і useMemo" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Критерій", "bold": true }],
              [{ "text": "memo", "bold": true }],
              [{ "text": "useMemo", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Що це?", "bold": true }],
                [{ "text": "Функція вищого порядку (HOC)" }],
                [{ "text": "Хук" }]
              ],
              [
                [{ "text": "Призначення", "bold": true }],
                [{ "text": "Запобігає повторному рендеру компонента" }],
                [{ "text": "Кешує результат обчислення" }]
              ],
              [
                [{ "text": "Де використовується?", "bold": true }],
                [{ "text": "Навколо компонента" }],
                [{ "text": "Всередині компонента" }]
              ],
              [
                [{ "text": "Що кешує?", "bold": true }],
                [{ "text": "Результат рендеру компонента" }],
                [{ "text": "Значення, що повертає функція" }]
              ],
              [
                [{ "text": "Типовий кейс", "bold": true }],
                [{ "text": "Компонент часто рендериться з тими ж пропсами" }],
                [{ "text": "Важке обчислення залежить від deps" }]
              ]
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "memo оптимізує рендер компонента. useMemo оптимізує обчислення всередині компонента."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "64. What is the difference between memo and useMemo?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Difference between memo and useMemo" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Criteria", "bold": true }],
              [{ "text": "memo", "bold": true }],
              [{ "text": "useMemo", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "What is it?", "bold": true }],
                [{ "text": "Higher-order component (HOC)" }],
                [{ "text": "Hook" }]
              ],
              [
                [{ "text": "Purpose", "bold": true }],
                [{ "text": "Prevents unnecessary component re-renders" }],
                [{ "text": "Caches computation results" }]
              ],
              [
                [{ "text": "Where used?", "bold": true }],
                [{ "text": "Wraps a component" }],
                [{ "text": "Inside a component" }]
              ],
              [
                [{ "text": "What is cached?", "bold": true }],
                [{ "text": "Rendered output of a component" }],
                [{ "text": "Return value of a function" }]
              ],
              [
                [{ "text": "Typical use case", "bold": true }],
                [{ "text": "Component renders often with same props" }],
                [{ "text": "Expensive calculation with dependencies" }]
              ]
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "memo optimizes rendering. useMemo optimizes calculations."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "64. Jaka jest różnica między memo a useMemo?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Różnica między memo i useMemo" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Kryterium", "bold": true }],
              [{ "text": "memo", "bold": true }],
              [{ "text": "useMemo", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Czym jest?", "bold": true }],
                [{ "text": "Komponent wyższego rzędu (HOC)" }],
                [{ "text": "Hook" }]
              ],
              [
                [{ "text": "Cel", "bold": true }],
                [{ "text": "Zapobiega zbędnym renderom komponentu" }],
                [{ "text": "Buforuje wynik obliczeń" }]
              ],
              [
                [{ "text": "Gdzie używany?", "bold": true }],
                [{ "text": "Opakowuje komponent" }],
                [{ "text": "Wewnątrz komponentu" }]
              ],
              [
                [{ "text": "Co jest buforowane?", "bold": true }],
                [{ "text": "Wynik renderowania komponentu" }],
                [{ "text": "Wartość zwracana przez funkcję" }]
              ],
              [
                [{ "text": "Typowy przypadek", "bold": true }],
                [{ "text": "Częste renderowanie z tymi samymi propsami" }],
                [{ "text": "Kosztowne obliczenia zależne od deps" }]
              ]
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "memo optymalizuje renderowanie. useMemo optymalizuje obliczenia."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 65,
    "translations": {
      "uk": {
        "question": "65. Навіщо setState() потрібно передавати функцію?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Функцію в ",
                "bold": false
              },
              { "text": "setState()", "code": true },
              {
                "text": " передають тоді, коли новий стан залежить від попереднього. Це необхідно через асинхронність та батчинг оновлень стану."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Суть проблеми:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Пряме використання значення стану може призвести до помилок, якщо кілька оновлень виконуються поспіль."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Правильний підхід:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Функція отримує актуальний попередній стан і гарантує коректний результат."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "65. Why should you pass a function to setState()?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A function is passed to ",
                "bold": false
              },
              { "text": "setState()", "code": true },
              {
                "text": " when the next state depends on the previous one. This is required because state updates are asynchronous and batched."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core issue:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Using the current state value directly may produce incorrect results when multiple updates occur."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Correct approach:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The function form receives the latest state and guarantees correct updates."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "65. Dlaczego do setState() należy przekazywać funkcję?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Funkcję przekazuje się do ",
                "bold": false
              },
              { "text": "setState()", "code": true },
              {
                "text": ", gdy nowy stan zależy od poprzedniego. Wynika to z asynchronicznego i grupowanego charakteru aktualizacji stanu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Istota problemu:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Bezpośrednie użycie stanu może prowadzić do błędów przy wielu aktualizacjach."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Poprawne rozwiązanie:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wersja funkcyjna zawsze otrzymuje aktualny poprzedni stan."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 66,
    "translations": {
      "uk": {
        "question": "66. Як рефи (refs) у React використовуються для взаємодії з DOM елементами?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Рефи (refs) у React використовуються для прямого доступу до DOM-елементів або екземплярів компонентів, минаючи пропси та state."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Створення рефа", "bold": true },
                  { "text": " — через " },
                  { "text": "useRef()", "code": true },
                  { "text": " або " },
                  { "text": "createRef()", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Привʼязка до DOM", "bold": true },
                  { "text": " — передача рефа в атрибут " },
                  { "text": "ref", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Доступ до елемента", "bold": true },
                  { "text": " — через " },
                  { "text": "ref.current", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Типові сценарії", "bold": true },
                  {
                    "text": " — фокус, скрол, вимірювання розмірів, інтеграція з не-React бібліотеками."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Рефи не призначені для керування станом і повинні використовуватись обмежено."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "66. How are refs used in React to interact with DOM elements?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Refs in React provide direct access to DOM elements or component instances, bypassing props and state."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Creating refs", "bold": true },
                  { "text": " — using " },
                  { "text": "useRef()", "code": true },
                  { "text": " or " },
                  { "text": "createRef()", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Binding to DOM", "bold": true },
                  { "text": " — passing the ref via the " },
                  { "text": "ref", "code": true },
                  { "text": " attribute" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Accessing the element", "bold": true },
                  { "text": " — through " },
                  { "text": "ref.current", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Common use cases", "bold": true },
                  {
                    "text": " — focus management, scrolling, measurements, third-party integrations."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Refs should not be used for state management and must be applied sparingly."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "66. Jak w React wykorzystuje się refy do interakcji z elementami DOM?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Refy w React umożliwiają bezpośredni dostęp do elementów DOM lub instancji komponentów, z pominięciem propsów i stanu."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Tworzenie refów", "bold": true },
                  { "text": " — za pomocą " },
                  { "text": "useRef()", "code": true },
                  { "text": " lub " },
                  { "text": "createRef()", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Powiązanie z DOM", "bold": true },
                  { "text": " — przekazanie refa do atrybutu " },
                  { "text": "ref", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dostęp do elementu", "bold": true },
                  { "text": " — przez " },
                  { "text": "ref.current", "code": true }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Typowe zastosowania", "bold": true },
                  {
                    "text": " — fokus, przewijanie, pomiary, integracje z bibliotekami zewnętrznymi."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Refy nie służą do zarządzania stanem i powinny być używane oszczędnie."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "question": "67. Як використовувати InnerHtml у React?",
    "category": "react",
    "answerBlocks": [
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "У React для вставки HTML-контенту в DOM використовується атрибут dangerouslySetInnerHTML. Це дає можливість вставити HTML безпосередньо в компонент, однак такий підхід може бути небезпечним, тому й називається \"dangerously\", оскільки він дозволяє вбудовувати сирий HTML, що може призвести до XSS-атак, якщо дані не очищені."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Приклад використання "
          },
          {
            "text": "dangerouslySetInnerHTML",
            "code": true
          },
          {
            "text": ":"
          }
        ]
      },
      {
        "type": "code",
        "language": "jsx",
        "content": "const MyComponent = () => {\r\n  const htmlContent = '<p>Це <strong>HTML</strong> контент.</p>';\r\n\r\n  return <div dangerouslySetInnerHTML={{ __html: htmlContent }} />;\r\n};\r"
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Пояснення:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "dangerouslySetInnerHTML",
                "code": true
              },
              {
                "text": " приймає об'єкт, в якому ключ "
              },
              {
                "text": "__html",
                "code": true
              },
              {
                "text": " містить рядок HTML-коду."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Це дозволяє вбудовувати HTML всередину компонента, але не безпечно, якщо контент надходить з ненадійних джерел."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Коли використовувати:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Якщо ви впевнені в безпечності даних (наприклад, від власних серверів)."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Коли вам потрібно вбудувати динамічний HTML-контент, такий як сторінки чи статті з HTML."
              }
            ]
          }
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "children": [
          {
            "text": "Застереження:"
          }
        ]
      },
      {
        "type": "bulletList",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "text": "Безпека: Ніколи не використовуйте dangerouslySetInnerHTML для вставки даних, отриманих від користувача чи зовнішніх джерел, без попередньої очистки від шкідливих скриптів."
              }
            ]
          },
          {
            "type": "listItem",
            "children": [
              {
                "text": "Для очищення контенту використовуйте бібліотеки, такі як DOMPurify, щоб уникнути XSS атак."
              }
            ]
          }
        ]
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Приклад очищення даних перед вставкою:",
            "bold": true
          }
        ]
      },
      {
        "type": "code",
        "language": "jsx",
        "content": "import DOMPurify from 'dompurify';\r\n\r\nconst MyComponent = () => {\r\n  const dirtyHtml = \"<img src=x onerror=alert('XSS')>\";\r\n  const cleanHtml = DOMPurify.sanitize(dirtyHtml);\r\n\r\n  return <div dangerouslySetInnerHTML={{ __html: cleanHtml }} />;\r\n};\r"
      },
      {
        "type": "paragraph",
        "children": [
          {
            "text": "Отже, "
          },
          {
            "text": "dangerouslySetInnerHTML",
            "code": true
          },
          {
            "text": " слід використовувати обережно і тільки в тих випадках, коли ви впевнені в безпеці контенту."
          }
        ]
      }
    ]
  },
  {
    "category": "react",
    "order": 68,
    "translations": {
      "uk": {
        "question": "68. Що таке ReactDOMServer?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "ReactDOMServer", "bold": true },
              {
                "text": " — це бібліотека, що входить до складу React і використовується для серверного рендерингу (SSR) React-компонентів. Вона дозволяє генерувати HTML на сервері та передавати його клієнту, що покращує продуктивність і SEO."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні методи:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOMServer.renderToString():",
                    "bold": true
                  },
                  {
                    "text": " Рендерить React-елементи в HTML-рядок для початкового завантаження сторінки."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import ReactDOMServer from 'react-dom/server';\nconst html = ReactDOMServer.renderToString(<App />);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOMServer.renderToStaticMarkup():",
                    "bold": true
                  },
                  {
                    "text": " Генерує чистий HTML без React-атрибутів. Підходить для повністю статичних сторінок."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const html = ReactDOMServer.renderToStaticMarkup(<App />);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOMServer.hydrate():", "bold": true },
                  {
                    "text": " Використовується на клієнті для підключення реактивності до серверно-рендереного HTML."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.hydrate(<App />, document.getElementById('root'));"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використання:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "SSR (Server-Side Rendering):", "bold": true },
                  {
                    "text": " Рендеринг компонентів на сервері з передачею готового HTML клієнту."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO:", "bold": true },
                  {
                    "text": " Пошукові системи отримують готовий HTML без виконання JavaScript."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "ReactDOMServer",
                "code": true
              },
              {
                "text": " використовується для створення попередньо зрендерених сторінок з кращою швидкістю завантаження та SEO."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "68. What is ReactDOMServer?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "ReactDOMServer", "bold": true },
              {
                "text": " is a library included in React that enables server-side rendering (SSR) of React components. It generates HTML on the server and sends it to the client, improving performance and SEO."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core methods:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOMServer.renderToString():",
                    "bold": true
                  },
                  {
                    "text": " Renders React elements to an HTML string for the initial page load."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import ReactDOMServer from 'react-dom/server';\nconst html = ReactDOMServer.renderToString(<App />);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOMServer.renderToStaticMarkup():",
                    "bold": true
                  },
                  {
                    "text": " Produces plain HTML without React-specific attributes. Useful for fully static pages."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const html = ReactDOMServer.renderToStaticMarkup(<App />);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOMServer.hydrate():", "bold": true },
                  {
                    "text": " Used on the client to attach React interactivity to server-rendered HTML."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.hydrate(<App />, document.getElementById('root'));"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usage:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "SSR (Server-Side Rendering):", "bold": true },
                  {
                    "text": " Components are rendered on the server and delivered as ready HTML."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO:", "bold": true },
                  {
                    "text": " Search engines can index pages without executing JavaScript."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "ReactDOMServer",
                "code": true
              },
              {
                "text": " enables pre-rendered pages with faster load times and improved SEO."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "68. Czym jest ReactDOMServer?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "ReactDOMServer", "bold": true },
              {
                "text": " to biblioteka wchodząca w skład React, służąca do renderowania komponentów po stronie serwera (SSR). Generuje HTML na serwerze i przesyła go do klienta, co poprawia wydajność i SEO."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne metody:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOMServer.renderToString():",
                    "bold": true
                  },
                  {
                    "text": " Renderuje elementy React do łańcucha HTML dla początkowego załadowania strony."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import ReactDOMServer from 'react-dom/server';\nconst html = ReactDOMServer.renderToString(<App />);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOMServer.renderToStaticMarkup():",
                    "bold": true
                  },
                  {
                    "text": " Generuje czysty HTML bez atrybutów React. Nadaje się do stron statycznych."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const html = ReactDOMServer.renderToStaticMarkup(<App />);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOMServer.hydrate():", "bold": true },
                  {
                    "text": " Służy po stronie klienta do podłączenia interaktywności do HTML wygenerowanego na serwerze."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.hydrate(<App />, document.getElementById('root'));"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zastosowanie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "SSR (Server-Side Rendering):", "bold": true },
                  {
                    "text": " Renderowanie komponentów na serwerze i wysyłanie gotowego HTML do klienta."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO:", "bold": true },
                  {
                    "text": " Wyszukiwarki mogą indeksować treść bez uruchamiania JavaScript."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "ReactDOMServer",
                "code": true
              },
              {
                "text": " umożliwia tworzenie wstępnie renderowanych stron z lepszą wydajnością i SEO."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 69,
    "translations": {
      "uk": {
        "question": "69. Яке використання пакету react-dom?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Пакет " },
              { "text": "react-dom", "code": true },
              {
                "text": " використовується для взаємодії React із реальним DOM у веб-додатках. Основні функції:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.render():", "bold": true },
                  {
                    "text": " Використовується для рендерингу React-компонента в реальний DOM."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.render(<App />, document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.hydrate():", "bold": true },
                  {
                    "text": " Використовується для гідратації серверно-зрендереного HTML."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.hydrate(<App />, document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.createPortal():", "bold": true },
                  {
                    "text": " Дозволяє рендерити елементи поза основною ієрархією DOM."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.createPortal(<Modal />, document.getElementById('modal-root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOM.unmountComponentAtNode():",
                    "bold": true
                  },
                  {
                    "text": " Видаляє React-компонент з DOM."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.unmountComponentAtNode(document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.findDOMNode():", "bold": true },
                  {
                    "text": " Надає доступ до DOM-елемента компонента. Вважається застарілим підходом."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "69. What is the usage of the react-dom package?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": "react-dom", "code": true },
              {
                "text": " package is responsible for connecting React with the real DOM in web applications. Core features include:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.render():", "bold": true },
                  {
                    "text": " Renders a React component into the real DOM."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.render(<App />, document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.hydrate():", "bold": true },
                  {
                    "text": " Attaches React to server-rendered HTML."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.hydrate(<App />, document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.createPortal():", "bold": true },
                  {
                    "text": " Renders children into a different DOM subtree."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.createPortal(<Modal />, document.getElementById('modal-root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOM.unmountComponentAtNode():",
                    "bold": true
                  },
                  {
                    "text": " Removes a React component from the DOM."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.unmountComponentAtNode(document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.findDOMNode():", "bold": true },
                  {
                    "text": " Provides access to a component’s DOM node. Considered legacy."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "69. Jakie jest zastosowanie pakietu react-dom?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Pakiet " },
              { "text": "react-dom", "code": true },
              {
                "text": " służy do integracji React z rzeczywistym DOM w aplikacjach webowych. Główne funkcje:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.render():", "bold": true },
                  {
                    "text": " Renderuje komponent React do rzeczywistego DOM."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.render(<App />, document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.hydrate():", "bold": true },
                  {
                    "text": " Podłącza React do HTML wygenerowanego po stronie serwera."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.hydrate(<App />, document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.createPortal():", "bold": true },
                  {
                    "text": " Pozwala renderować elementy poza standardową hierarchią DOM."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.createPortal(<Modal />, document.getElementById('modal-root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ReactDOM.unmountComponentAtNode():",
                    "bold": true
                  },
                  {
                    "text": " Usuwa komponent React z DOM."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "ReactDOM.unmountComponentAtNode(document.getElementById('root'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ReactDOM.findDOMNode():", "bold": true },
                  {
                    "text": " Zapewnia dostęp do elementu DOM komponentu. Metoda przestarzała."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 70,
    "translations": {
      "uk": {
        "question": "70. Як використовувати React.lazy та React.Suspense для запуску коду програми?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React.lazy", "code": true },
              { "text": " та " },
              { "text": "React.Suspense", "code": true },
              { "text": " використовуються для " },
              { "text": "динамічного завантаження компонентів", "bold": true },
              { "text": " у React з метою " },
              { "text": "розподілу коду", "bold": true },
              {
                "text": " (code splitting). Компоненти завантажуються лише за потреби, що зменшує початкове навантаження."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як це працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.lazy()", "bold": true },
                  { "text": " дозволяє відкладено імпортувати компонент." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React.Suspense", "bold": true },
                  {
                    "text": " обгортає ледачі компоненти та показує fallback-контент під час завантаження."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Динамічний імпорт компонента:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const MyComponent = React.lazy(() => import('./MyComponent'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Використання React.Suspense:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function App() {\n  return (\n    <React.Suspense fallback={<div>Завантаження...</div>}>\n      <MyComponent />\n    </React.Suspense>\n  );\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Менший розмір початкового бандлу." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Швидше початкове завантаження застосунку." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "70. How to use React.lazy and React.Suspense to load application code?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React.lazy", "code": true },
              { "text": " and " },
              { "text": "React.Suspense", "code": true },
              { "text": " are used for " },
              { "text": "dynamic component loading", "bold": true },
              { "text": " in React via " },
              { "text": "code splitting", "bold": true },
              {
                "text": ". Code is loaded only when required, reducing initial load time."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.lazy()", "bold": true },
                  { "text": " enables deferred importing of components." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React.Suspense", "bold": true },
                  {
                    "text": " wraps lazy components and displays fallback content during loading."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lazy-loaded component:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const MyComponent = React.lazy(() => import('./MyComponent'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Suspense wrapper:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function App() {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <MyComponent />\n    </React.Suspense>\n  );\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Benefits:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Smaller initial bundle size." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Faster initial application load." }]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "70. Jak używać React.lazy i React.Suspense do ładowania kodu aplikacji?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React.lazy", "code": true },
              { "text": " oraz " },
              { "text": "React.Suspense", "code": true },
              { "text": " służą do " },
              { "text": "dynamicznego ładowania komponentów", "bold": true },
              { "text": " w React poprzez " },
              { "text": "podział kodu", "bold": true },
              {
                "text": " (code splitting). Kod jest pobierany tylko wtedy, gdy jest potrzebny."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak to działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.lazy()", "bold": true },
                  { "text": " umożliwia leniwe importowanie komponentów." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React.Suspense", "bold": true },
                  {
                    "text": " wyświetla zawartość zastępczą podczas ładowania komponentów."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponent ładowany dynamicznie:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "const MyComponent = React.lazy(() => import('./MyComponent'));"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Użycie React.Suspense:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function App() {\n  return (\n    <React.Suspense fallback={<div>Ładowanie...</div>}>\n      <MyComponent />\n    </React.Suspense>\n  );\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Mniejszy początkowy rozmiar pakietu." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Szybsze uruchomienie aplikacji." }]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 71,
    "translations": {
      "uk": {
        "question": "71. Найкращі практики безпеки в React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Найкращі практики безпеки в React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Запобігання XSS:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Очищуйте всі користувацькі дані перед відображенням."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Уникайте " },
                          { "text": "dangerouslySetInnerHTML", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Захист від інʼєкцій коду:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Не використовуйте " },
                          { "text": "eval()", "code": true },
                          { "text": " та подібні API." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Безпечна робота з API:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Використовуйте HTTPS." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Застосовуйте HTTPOnly та Secure cookies."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Захист від CSRF:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Використовуйте CSRF-токени." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Використовуйте cookie з флагом " },
                          { "text": "SameSite", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Контроль доступу:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Не довіряйте клієнтській валідації." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Перевіряйте права на сервері." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оновлення залежностей:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Регулярно перевіряйте залежності через "
                          },
                          { "text": "npm audit", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Керування секретами:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Не зберігайте секрети в клієнтському коді."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ці практики зменшують типові ризики безпеки в React-додатках."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "71. Best security practices in React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Best security practices in React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Prevent XSS:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Sanitize all user input before rendering."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Avoid " },
                          { "text": "dangerouslySetInnerHTML", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Avoid code injection:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Do not use " },
                          { "text": "eval()", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Secure API access:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Always use HTTPS." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Use HTTPOnly and Secure cookies." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Protect against CSRF:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Use CSRF tokens." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Use cookies with " },
                          { "text": "SameSite", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Access control:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Never trust client-side validation." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Enforce checks on the server." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dependency updates:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Audit dependencies using " },
                          { "text": "npm audit", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Secrets management:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Never store secrets in client code." }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "These practices reduce common security risks in React applications."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "71. Najlepsze praktyki bezpieczeństwa w React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Najlepsze praktyki bezpieczeństwa w React:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Zapobieganie XSS:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Sanityzuj dane użytkownika przed renderowaniem."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Unikaj " },
                          { "text": "dangerouslySetInnerHTML", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Ochrona przed wstrzyknięciem kodu:",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Nie używaj " },
                          { "text": "eval()", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Bezpieczne API:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Korzystaj z HTTPS." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Stosuj cookies HTTPOnly i Secure." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ochrona CSRF:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Używaj tokenów CSRF." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Ustaw flagę " },
                          { "text": "SameSite", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontrola dostępu:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Nie ufaj walidacji po stronie klienta." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Weryfikuj uprawnienia na serwerze." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aktualizacja zależności:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Sprawdzaj zależności za pomocą " },
                          { "text": "npm audit", "code": true }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zarządzanie sekretami:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Nie przechowuj sekretów w kodzie frontendowym."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Stosowanie tych zasad ogranicza typowe podatności w aplikacjach React."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 72,
    "translations": {
      "uk": {
        "question": "72. Як обробляти помилки в React за допомогою Error Boundary?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Error Boundaries", "bold": true },
              {
                "text": " у React дозволяють перехоплювати помилки під час рендерингу, у методах життєвого циклу та конструкторах компонентів без падіння всього додатку."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні моменти:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Error Boundary — це компонент-обгортка, який ловить помилки у своїх дочірніх компонентах."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Error Boundaries", "bold": true },
                  {
                    "text": " не ловлять помилки всередині самих себе."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Реалізація Error Boundary:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Створення компонента:", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "static getDerivedStateFromError(error)",
                            "code": true
                          },
                          { "text": " — оновлює стан при помилці." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "componentDidCatch(error, info)",
                            "code": true
                          },
                          { "text": " — логування або відправка помилки." }
                        ]
                      }
                    ]
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Щось пішло не так.</h1>;\n    }\n    return this.props.children;\n  }\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Використання:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<ErrorBoundary>\n  <MyComponent />\n</ErrorBoundary>"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Обмеження:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Не ловить помилки в обробниках подій, async-коді, таймерах та HTTP-запитах."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "72. How to handle errors in React using Error Boundaries?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Error Boundaries", "bold": true },
              {
                "text": " allow React applications to catch rendering and lifecycle errors without crashing the entire app."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key points:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "An Error Boundary is a wrapper component that catches errors in its children."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Error Boundaries", "bold": true },
                  {
                    "text": " do not catch errors inside themselves."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Implementation:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Create Error Boundary:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Usage:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<ErrorBoundary>\n  <MyComponent />\n</ErrorBoundary>"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Limitations:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Does not catch errors in event handlers, async code, or network requests."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "72. Jak obsługiwać błędy w React za pomocą Error Boundary?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Error Boundaries", "bold": true },
              {
                "text": " pozwalają przechwytywać błędy renderowania i cyklu życia bez zatrzymywania całej aplikacji."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Najważniejsze informacje:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Error Boundary to komponent opakowujący, który łapie błędy w komponentach potomnych."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Error Boundaries", "bold": true },
                  {
                    "text": " nie przechwytują błędów we własnym kodzie."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Implementacja:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Tworzenie komponentu:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "class ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Coś poszło nie tak.</h1>;\n    }\n    return this.props.children;\n  }\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Użycie:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "<ErrorBoundary>\n  <MyComponent />\n</ErrorBoundary>"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ograniczenia:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Nie obsługuje błędów w obsłudze zdarzeń, kodzie asynchronicznym ani zapytaniach sieciowych."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 73,
    "translations": {
      "uk": {
        "question": "73. Що таке інверсія спадкування (Inheritance Inversion)?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Інверсія спадкування (Inheritance Inversion)",
                    "bold": true
                  },
                  {
                    "text": " — це антипатерн, за якого базовий клас втрачає автономну логіку та фактично залежить від своїх нащадків."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Проблеми інверсії спадкування" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Порушення принципу підстановки Лісков (LSP)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Складність розширення базового класу." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Тісна звʼязність між класами." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад поганої практики" }]
          },
          {
            "type": "code",
            "language": "js",
            "content": "class Parent {\n  method() {\n    throw new Error('Метод має бути реалізований у нащадку');\n  }\n}\n\nclass Child extends Parent {\n  method() {\n    return 'Реалізація в нащадку';\n  }\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Базовий клас не має власної поведінки і примушує нащадків її визначати."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Альтернатива: композиція" }]
          },
          {
            "type": "code",
            "language": "js",
            "content": "class Behavior {\n  method() {\n    return 'Реалізація без інверсії';\n  }\n}\n\nclass Parent {\n  constructor() {\n    this.behavior = new Behavior();\n  }\n\n  method() {\n    return this.behavior.method();\n  }\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Композиція зменшує залежності та підвищує гнучкість коду."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "73. What is inheritance inversion?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Inheritance Inversion", "bold": true },
                  {
                    "text": " is an anti-pattern where a base class depends on its subclasses or delegates core behavior to them."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Problems with inheritance inversion" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Violates the Liskov Substitution Principle." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hard to extend or refactor base classes." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Creates tight coupling." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Bad practice example" }]
          },
          {
            "type": "code",
            "language": "js",
            "content": "class Parent {\n  method() {\n    throw new Error('Must be implemented by child');\n  }\n}\n\nclass Child extends Parent {\n  method() {\n    return 'Child implementation';\n  }\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The base class has no real behavior and forces subclasses to define it."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Alternative: composition" }]
          },
          {
            "type": "code",
            "language": "js",
            "content": "class Behavior {\n  method() {\n    return 'Implementation without inversion';\n  }\n}\n\nclass Parent {\n  constructor() {\n    this.behavior = new Behavior();\n  }\n\n  method() {\n    return this.behavior.method();\n  }\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Composition removes subclass dependency and improves maintainability."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "73. Czym jest inwersja dziedziczenia?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Inwersja dziedziczenia", "bold": true },
                  {
                    "text": " to antywzorzec, w którym klasa bazowa zależy od klas potomnych."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Problemy inwersji dziedziczenia" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Naruszenie zasady podstawienia Liskov." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Trudna rozbudowa klasy bazowej." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Silne powiązania między klasami." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład złej praktyki" }]
          },
          {
            "type": "code",
            "language": "js",
            "content": "class Parent {\n  method() {\n    throw new Error('Musi być zaimplementowane w klasie potomnej');\n  }\n}\n\nclass Child extends Parent {\n  method() {\n    return 'Implementacja potomna';\n  }\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Klasa bazowa nie posiada własnej logiki."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Alternatywa: kompozycja" }]
          },
          {
            "type": "code",
            "language": "js",
            "content": "class Behavior {\n  method() {\n    return 'Implementacja bez inwersji';\n  }\n}\n\nclass Parent {\n  constructor() {\n    this.behavior = new Behavior();\n  }\n\n  method() {\n    return this.behavior.method();\n  }\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Kompozycja zmniejsza zależności i poprawia elastyczność."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 74,
    "translations": {
      "uk": {
        "question": "74. Що таке \"опитування\" (Polling)? Як його реалізувати у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Опитування (Polling)", "bold": true },
              {
                "text": " — це періодичне надсилання запитів до сервера для отримання оновлених даних, коли push-механізми недоступні."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Реалізація Polling у React" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Polling реалізують через " },
              { "text": "setInterval", "code": true },
              { "text": ", " },
              { "text": "setTimeout", "code": true },
              { "text": " або хук " },
              { "text": "useEffect", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Використання setInterval:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "useEffect(() => {\n  const fetchData = async () => {\n    const res = await fetch('/api/data');\n    setData(await res.json());\n  };\n\n  fetchData();\n  const id = setInterval(fetchData, 5000);\n  return () => clearInterval(id);\n}, []);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Використання setTimeout:", "bold": true },
                  {
                    "text": " Дозволяє уникнути накладання запитів."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "setTimeout викликає наступний запит лише після завершення попереднього."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "74. What is polling? How is it implemented in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Polling", "bold": true },
              {
                "text": " is a technique where the client periodically requests updated data from the server when push mechanisms are unavailable."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Polling implementation in React" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Polling can be implemented using " },
              { "text": "setInterval", "code": true },
              { "text": ", " },
              { "text": "setTimeout", "code": true },
              { "text": " and the " },
              { "text": "useEffect", "code": true },
              { "text": " hook." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Using setInterval:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "useEffect(() => {\n  const fetchData = async () => {\n    const res = await fetch('/api/data');\n    setData(await res.json());\n  };\n\n  fetchData();\n  const id = setInterval(fetchData, 5000);\n  return () => clearInterval(id);\n}, []);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Using setTimeout:", "bold": true },
                  {
                    "text": " Prevents overlapping requests."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "With setTimeout, the next request starts only after the previous one completes."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "74. Czym jest polling? Jak zaimplementować go w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Polling", "bold": true },
              {
                "text": " to technika okresowego odpytywania serwera o nowe dane, gdy mechanizmy push nie są dostępne."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Implementacja Polling w React" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Polling można zaimplementować za pomocą " },
              { "text": "setInterval", "code": true },
              { "text": ", " },
              { "text": "setTimeout", "code": true },
              { "text": " oraz hooka " },
              { "text": "useEffect", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Użycie setInterval:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "useEffect(() => {\n  const fetchData = async () => {\n    const res = await fetch('/api/data');\n    setData(await res.json());\n  };\n\n  fetchData();\n  const id = setInterval(fetchData, 5000);\n  return () => clearInterval(id);\n}, []);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Użycie setTimeout:", "bold": true },
                  {
                    "text": " Zapobiega nakładaniu się zapytań."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "setTimeout uruchamia kolejne zapytanie dopiero po zakończeniu poprzedniego."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 75,
    "translations": {
      "uk": {
        "question": "75. Як у React реалізувати двостороннє зв'язування даних?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У React двостороннє зв’язування даних реалізується через "
              },
              {
                "text": "керовані компоненти",
                "bold": true
              },
              {
                "text": ", де стан ("
              },
              {
                "text": "state",
                "code": true
              },
              {
                "text": ") синхронізується з полем вводу ("
              },
              {
                "text": "input",
                "code": true
              },
              {
                "text": ")."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад реалізації" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useState } from 'react';\n\nconst TwoWayBinding = () => {\n  const [value, setValue] = useState('');\n\n  return (\n    <input\n      value={value}\n      onChange={e => setValue(e.target.value)}\n    />\n  );\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Зміна значення в полі вводу одразу оновлює стан, а стан керує відображенням."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "75. How is two-way data binding implemented in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In React, two-way data binding is implemented using "
              },
              {
                "text": "controlled components",
                "bold": true
              },
              {
                "text": ", where component "
              },
              {
                "text": "state",
                "code": true
              },
              {
                "text": " is synchronized with an "
              },
              {
                "text": "input",
                "code": true
              },
              {
                "text": " element."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useState } from 'react';\n\nconst TwoWayBinding = () => {\n  const [value, setValue] = useState('');\n\n  return (\n    <input\n      value={value}\n      onChange={e => setValue(e.target.value)}\n    />\n  );\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "User input updates state, and state controls what is rendered."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "75. Jak w React zaimplementować dwukierunkowe wiązanie danych?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W React dwukierunkowe wiązanie danych realizuje się za pomocą "
              },
              {
                "text": "komponentów kontrolowanych",
                "bold": true
              },
              {
                "text": ", gdzie "
              },
              {
                "text": "state",
                "code": true
              },
              {
                "text": " jest synchronizowany z polem "
              },
              {
                "text": "input",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { useState } from 'react';\n\nconst TwoWayBinding = () => {\n  const [value, setValue] = useState('');\n\n  return (\n    <input\n      value={value}\n      onChange={e => setValue(e.target.value)}\n    />\n  );\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zmiana wartości w polu aktualizuje stan, a stan steruje interfejsem."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 76,
    "translations": {
      "uk": {
        "question": "76. Що таке зворотний потік даних (Reverse Data Flow) у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Зворотний потік даних (Reverse Data Flow) у React — це передача змін від дочірнього компонента до батьківського. На практиці це реалізується без прямого доступу до стану батька."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як це реалізується:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Callback-функції", "bold": true },
                  {
                    "text": ": батьківський компонент передає функцію через пропси, а дочірній викликає її при зміні даних."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Приклад:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Parent() {\n  const [value, setValue] = useState('');\n\n  const handleChange = v => setValue(v);\n\n  return <Child onValueChange={handleChange} />;\n}\n\nfunction Child({ onValueChange }) {\n  return <input onChange={e => onValueChange(e.target.value)} />;\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Таким чином дочірній компонент ініціює зміну стану, але сам стан залишається у батьківському компоненті."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "76. What is Reverse Data Flow in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Reverse Data Flow in React means passing data changes from a child component back to a parent component, without breaking one-way data flow."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it is implemented:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Callback functions", "bold": true },
                  {
                    "text": ": the parent passes a function via props and the child invokes it on changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Example:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Parent() {\n  const [value, setValue] = useState('');\n\n  const handleChange = v => setValue(v);\n\n  return <Child onValueChange={handleChange} />;\n}\n\nfunction Child({ onValueChange }) {\n  return <input onChange={e => onValueChange(e.target.value)} />;\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The child triggers updates, but state ownership remains in the parent."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "76. Czym jest odwrotny przepływ danych (Reverse Data Flow) w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Reverse Data Flow w React oznacza przekazywanie zmian danych z komponentu potomnego do komponentu nadrzędnego."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak jest realizowany:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Funkcje callback", "bold": true },
                  {
                    "text": ": komponent nadrzędny przekazuje funkcję przez propsy, a potomny ją wywołuje."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przykład:", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function Parent() {\n  const [value, setValue] = useState('');\n\n  const handleChange = v => setValue(v);\n\n  return <Child onValueChange={handleChange} />;\n}\n\nfunction Child({ onValueChange }) {\n  return <input onChange={e => onValueChange(e.target.value)} />;\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Komponent potomny inicjuje zmianę, ale stan pozostaje w komponencie nadrzędnym."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 77,
    "translations": {
      "uk": {
        "question": "77. Що таке мутація стану і як їй запобігти?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Мутація стану — це пряме змінювання обʼєктів або масивів у стані без створення нової копії. У React це ламає механізм виявлення змін і може призвести до відсутності перерендеру."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як запобігти мутації стану:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Створювати копії даних", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Масиви: " },
                          {
                            "text": "setItems([...items, newItem])",
                            "code": true
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Обʼєкти: " },
                          {
                            "text": "setUser({ ...user, name: 'John' })",
                            "code": true
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Використовувати немутуючі методи",
                    "bold": true
                  },
                  {
                    "text": " "
                  },
                  { "text": "map()", "code": true },
                  { "text": ", " },
                  { "text": "filter()", "code": true },
                  { "text": ", " },
                  { "text": "reduce()", "code": true }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Немутуючі оновлення дозволяють React коректно визначати зміни стану."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "77. What is state mutation and how can it be prevented?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "State mutation is the direct modification of objects or arrays stored in state without creating a new copy. In React, this breaks change detection and may prevent re-rendering."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How to prevent state mutation:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Create copies of data", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Arrays: " },
                          {
                            "text": "setItems([...items, newItem])",
                            "code": true
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Objects: " },
                          {
                            "text": "setUser({ ...user, name: 'John' })",
                            "code": true
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Use non-mutating methods", "bold": true },
                  { "text": " " },
                  { "text": "map()", "code": true },
                  { "text": ", " },
                  { "text": "filter()", "code": true },
                  { "text": ", " },
                  { "text": "reduce()", "code": true }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Immutable updates allow React to reliably detect state changes."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "77. Czym jest mutacja stanu i jak jej zapobiegać?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Mutacja stanu to bezpośrednia modyfikacja obiektów lub tablic w stanie bez tworzenia nowej kopii. W React prowadzi to do problemów z wykrywaniem zmian."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak zapobiegać mutacji stanu:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Tworzyć kopie danych", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Tablice: " },
                          {
                            "text": "setItems([...items, newItem])",
                            "code": true
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Obiekty: " },
                          {
                            "text": "setUser({ ...user, name: 'John' })",
                            "code": true
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Używać metod niemutujących", "bold": true },
                  { "text": " " },
                  { "text": "map()", "code": true },
                  { "text": ", " },
                  { "text": "filter()", "code": true },
                  { "text": ", " },
                  { "text": "reduce()", "code": true }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Niemutujące aktualizacje umożliwiają React poprawne śledzenie zmian stanu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 78,
    "translations": {
      "uk": {
        "question": "78. Що таке строгий режим (Strict Mode) React? Його переваги?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Strict Mode", "bold": true },
              {
                "text": " — це інструмент React для виявлення потенційних проблем у коді під час розробки. У продакшені не має жодного ефекту."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Активується обгорткою в " },
              { "text": "<React.StrictMode>", "code": true }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "root.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги Strict Mode" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Виявляє застарілі та небезпечні lifecycle-методи."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Навмисно двічі викликає рендер і "
                  },
                  { "text": "useEffect", "code": true },
                  {
                    "text": " у dev-режимі для виявлення побічних ефектів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Попереджає про використання застарілого API."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Strict Mode корисний для раннього виявлення проблем, але може ускладнювати дебаг через подвійні виклики."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "78. What is React Strict Mode? Its benefits?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Strict Mode", "bold": true },
              {
                "text": " is a development-only tool in React that helps detect potential issues in the code. It has no effect in production."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Enabled by wrapping components with " },
              { "text": "<React.StrictMode>", "code": true }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "root.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Benefits of Strict Mode" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Detects unsafe and deprecated lifecycle methods."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Intentionally double-invokes render and " },
                  { "text": "useEffect", "code": true },
                  { "text": " to expose side effects." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Warns about deprecated APIs and patterns." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Strict Mode improves code quality but may complicate debugging due to intentional double renders."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "78. Czym jest tryb ścisły (Strict Mode) w React? Jakie są jego zalety?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Strict Mode", "bold": true },
              {
                "text": " to narzędzie React działające tylko w trybie developerskim, służące do wykrywania potencjalnych problemów."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Aktywowany przez opakowanie w " },
              { "text": "<React.StrictMode>", "code": true }
            ]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "root.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety Strict Mode" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wykrywa przestarzałe i niebezpieczne metody cyklu życia."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podwójnie wywołuje render i " },
                  { "text": "useEffect", "code": true },
                  { "text": " w celu wykrycia efektów ubocznych." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Ostrzega przed przestarzałym API." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Strict Mode poprawia jakość kodu, ale może utrudniać debugowanie."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 79,
    "translations": {
      "uk": {
        "question": "79. Які рекомендовані способи перевірки статичних типів?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "TypeScript", "bold": true },
                  {
                    "text": " — основний інструмент статичної типізації для React. Перевіряє типи на етапі компіляції та запобігає більшості класів помилок."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PropTypes", "bold": true },
                  {
                    "text": " — runtime-перевірка типів пропсів у React. Не є статичною типізацією."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "MyComponent.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n};"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Flow", "bold": true },
                  {
                    "text": " — статична типізація для JavaScript. Менш поширений і поступається TypeScript."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ESLint з плагінами", "bold": true },
                  {
                    "text": " — допоміжний контроль типів, але не замінює повноцінну типізацію."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Рекомендований вибір — " },
              { "text": "TypeScript", "bold": true },
              { "text": ". Він дає реальну статичну типізацію." }
            ]
          }
        ]
      },
      "en": {
        "question": "79. What are the recommended ways to check static types?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "TypeScript", "bold": true },
                  {
                    "text": " — the primary solution for static typing in React. Types are checked at compile time."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PropTypes", "bold": true },
                  {
                    "text": " — runtime validation of React props. Not true static typing."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "MyComponent.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n};"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Flow", "bold": true },
                  {
                    "text": " — a static type checker for JavaScript. Less common than TypeScript."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ESLint plugins", "bold": true },
                  {
                    "text": " — partial type-related checks, not a full typing system."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "The recommended choice is " },
              { "text": "TypeScript", "bold": true },
              { "text": ". It provides real static typing." }
            ]
          }
        ]
      },
      "pl": {
        "question": "79. Jakie są zalecane sposoby sprawdzania typów statycznych?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "TypeScript", "bold": true },
                  {
                    "text": " — podstawowe narzędzie statycznej typizacji w React. Sprawdza typy podczas kompilacji."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PropTypes", "bold": true },
                  {
                    "text": " — walidacja typów propsów w czasie działania. To nie jest typizacja statyczna."
                  },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "MyComponent.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n};"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Flow", "bold": true },
                  {
                    "text": " — system typów dla JavaScript, obecnie rzadziej używany."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wtyczki ESLint", "bold": true },
                  {
                    "text": " — dodatkowa kontrola, ale bez pełnej typizacji."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Rekomendowane rozwiązanie to " },
              { "text": "TypeScript", "bold": true },
              { "text": ", bo daje pełną kontrolę typów." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 80,
    "translations": {
      "uk": {
        "question": "80. Як реалізувати анімацію в React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "CSS-анімації", "bold": true },
                  { "text": " — простий варіант для базових ефектів." },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": ".box { animation: fadeIn 1s ease-in; }"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Transition Group", "bold": true },
                  {
                    "text": " — керування анімаціями при монтуванні та демонтуванні компонентів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Framer Motion", "bold": true },
                  {
                    "text": " — декларативна бібліотека для складних анімацій."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Spring", "bold": true },
                  { "text": " — анімації з фізичною моделлю руху." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Inline-стилі + state", "bold": true },
                  { "text": " — керування стилями через стан компонента." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для складних сценаріїв доцільніше використовувати "
              },
              { "text": "Framer Motion", "bold": true },
              { "text": " або " },
              { "text": "React Spring", "bold": true },
              { "text": "." }
            ]
          }
        ]
      },
      "en": {
        "question": "80. How can animations be implemented in React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "CSS animations", "bold": true },
                  { "text": " — the simplest solution for basic effects." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Transition Group", "bold": true },
                  { "text": " — animations for component mount and unmount." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Framer Motion", "bold": true },
                  { "text": " — declarative animations for complex UI." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Spring", "bold": true },
                  { "text": " — physics-based animation library." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Inline styles with state", "bold": true },
                  { "text": " — animation driven by component state." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "For advanced animations, " },
              { "text": "Framer Motion", "bold": true },
              { "text": " or " },
              { "text": "React Spring", "bold": true },
              { "text": " are preferred." }
            ]
          }
        ]
      },
      "pl": {
        "question": "80. Jak zaimplementować animacje w React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Animacje CSS", "bold": true },
                  { "text": " — najprostsze rozwiązanie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Transition Group", "bold": true },
                  {
                    "text": " — animacje przy dodawaniu i usuwaniu komponentów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Framer Motion", "bold": true },
                  { "text": " — biblioteka do złożonych animacji." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Spring", "bold": true },
                  { "text": " — animacje oparte na fizyce." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Style inline i state", "bold": true },
                  { "text": " — animowanie poprzez stan komponentu." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Do bardziej złożonych efektów warto użyć " },
              { "text": "Framer Motion", "bold": true },
              { "text": " lub " },
              { "text": "React Spring", "bold": true },
              { "text": "." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 81,
    "translations": {
      "uk": {
        "question": "81. Які самі популярні пакети для анімації у React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Популярні пакети для анімації в React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Framer Motion", "bold": true },
                  {
                    "text": " — де-факто стандарт для React-анімацій. Декларативний API, підтримка gesture, layout і complex transitions."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Spring", "bold": true },
                  {
                    "text": " — фізично базовані анімації з пружинами. Гнучкий, але складніший у контролі."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GSAP", "bold": true },
                  {
                    "text": " — надпотужна low-level бібліотека для складних таймлайнів і високої продуктивності."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Transition Group", "bold": true },
                  {
                    "text": " — базові анімації входу та виходу компонентів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Lottie for React", "bold": true },
                  {
                    "text": " — відтворення JSON-анімацій з After Effects."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "81. What are the most popular animation libraries for React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Popular animation libraries for React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Framer Motion", "bold": true },
                  {
                    "text": " — the de facto standard for React animations. Declarative API with layout and gesture support."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Spring", "bold": true },
                  {
                    "text": " — physics-based animations using springs. Flexible but harder to reason about."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GSAP", "bold": true },
                  {
                    "text": " — extremely powerful low-level animation engine with timelines."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Transition Group", "bold": true },
                  {
                    "text": " — basic enter and exit transitions for components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Lottie for React", "bold": true },
                  {
                    "text": " — plays After Effects animations exported as JSON."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "81. Jakie są najpopularniejsze biblioteki animacji w React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Popularne biblioteki animacji w React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Framer Motion", "bold": true },
                  {
                    "text": " — standard dla animacji w React. Deklaratywne API i animacje layoutu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Spring", "bold": true },
                  {
                    "text": " — animacje oparte na fizyce i sprężynach."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GSAP", "bold": true },
                  {
                    "text": " — bardzo wydajna biblioteka do złożonych animacji i timeline’ów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Transition Group", "bold": true },
                  {
                    "text": " — animacje wejścia i wyjścia komponentów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Lottie for React", "bold": true },
                  {
                    "text": " — odtwarzanie animacji JSON z After Effects."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 82,
    "translations": {
      "uk": {
        "question": "82. React DevTools: Як використовувати для налагодження?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Встановлення", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Встанови розширення React Developer Tools для Chrome або Firefox."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Для Electron або React Native використай CLI."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вкладка Components", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Перегляд дерева компонентів." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Інспекція props, state, context і хуків."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Тимчасове редагування state/props для перевірок."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вкладка Profiler", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Запис і аналіз рендерів." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Виявлення зайвих і дорогих рендерів." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Strict Mode", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Подвійні рендери у dev нормальні і допомагають знайти побічні ефекти."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Components для логіки і стану. Profiler для продуктивності."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "82. React DevTools: How to use it for debugging?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Installation", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Install React Developer Tools for Chrome or Firefox."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Use the CLI for Electron or React Native."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Components tab", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Inspect component tree." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "View props, state, context, hooks." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Temporarily edit values for testing." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Profiler tab", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Record and analyze renders." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Find unnecessary or expensive renders." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Strict Mode", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Double renders in dev are expected and intentional."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Use Components for logic and state. Use Profiler for performance."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "82. React DevTools: Jak używać do debugowania?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Instalacja", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zainstaluj React Developer Tools dla Chrome lub Firefox."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Użyj CLI dla Electron lub React Native."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zakładka Components", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Podgląd drzewa komponentów." }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Inspekcja props, state, context i hooków."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Tymczasowa edycja wartości do testów." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zakładka Profiler", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Nagrywanie i analiza renderów." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Wykrywanie zbędnych renderów." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Strict Mode", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Podwójne renderowanie w dev jest zamierzone."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Components do logiki i stanu. Profiler do wydajności."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 83,
    "translations": {
      "uk": {
        "question": "83. Які самі популярні лінтери для React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Самі популярні лінтери для React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "ESLint", "bold": true },
                  { "text": " - найпоширеніший лінтер для " },
                  { "text": "JavaScript", "code": true },
                  { "text": ", який підтримує " },
                  { "text": "React", "code": true },
                  { "text": " через плагін " },
                  { "text": "eslint-plugin-react", "code": true },
                  {
                    "text": ". Перевіряє стиль коду, знаходить помилки та інтегрується з іншими інструментами, зокрема "
                  },
                  { "text": "Prettier", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Prettier", "bold": true },
                  {
                    "text": " - інструмент автоматичного форматування коду, який часто використовують разом з "
                  },
                  { "text": "ESLint", "code": true },
                  { "text": " для єдиного стилю." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "TSLint", "bold": true },
                  { "text": " - лінтер для " },
                  { "text": "TypeScript", "code": true },
                  { "text": ", сумісний з " },
                  { "text": "React", "code": true },
                  { "text": ", але вважається застарілим і замінений на " },
                  { "text": "ESLint", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ці інструменти використовують для контролю якості коду та зниження кількості помилок."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "83. What are the most popular linters for React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Most popular linters for React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "ESLint", "bold": true },
                  { "text": " - the most widely used linter for " },
                  { "text": "JavaScript", "code": true },
                  { "text": ", supporting " },
                  { "text": "React", "code": true },
                  { "text": " via the " },
                  { "text": "eslint-plugin-react", "code": true },
                  {
                    "text": " plugin. It enforces code style, detects errors, and integrates with tools like "
                  },
                  { "text": "Prettier", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Prettier", "bold": true },
                  {
                    "text": " - an automatic code formatter, commonly used together with "
                  },
                  { "text": "ESLint", "code": true },
                  { "text": " to maintain consistent code style." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "TSLint", "bold": true },
                  { "text": " - a linter for " },
                  { "text": "TypeScript", "code": true },
                  { "text": ", compatible with " },
                  { "text": "React", "code": true },
                  { "text": ", but now deprecated in favor of " },
                  { "text": "ESLint", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "These tools help maintain code quality and reduce errors in large projects."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "83. Jakie są najpopularniejsze lintery dla React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Najpopularniejsze lintery dla React:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "ESLint", "bold": true },
                  { "text": " - najczęściej używany linter dla " },
                  { "text": "JavaScript", "code": true },
                  { "text": ", obsługujący " },
                  { "text": "React", "code": true },
                  { "text": " dzięki wtyczce " },
                  { "text": "eslint-plugin-react", "code": true },
                  {
                    "text": ". Wymusza styl kodu, wykrywa błędy i współpracuje z narzędziami takimi jak "
                  },
                  { "text": "Prettier", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Prettier", "bold": true },
                  {
                    "text": " - narzędzie do automatycznego formatowania kodu, często używane razem z "
                  },
                  { "text": "ESLint", "code": true },
                  { "text": " w celu zachowania spójnego stylu." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "TSLint", "bold": true },
                  { "text": " - linter dla " },
                  { "text": "TypeScript", "code": true },
                  { "text": ", możliwy do użycia z " },
                  { "text": "React", "code": true },
                  { "text": ", lecz obecnie zastąpiony przez " },
                  { "text": "ESLint", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Narzędzia te służą do utrzymania jakości kodu i ograniczania liczby błędów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 84,
    "translations": {
      "uk": {
        "question": "84. Що таке Next.js?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Next.js", "bold": true },
              {
                "text": " - це React-фреймворк, який надає готові рішення для серверного рендерингу (SSR), статичної генерації (SSG), API-роутів, маршрутизації, оптимізації продуктивності та SEO."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні можливості:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Гібридний рендеринг:", "bold": true },
                  { "text": " підтримка SSR, SSG та ISR." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Автоматична маршрутизація:", "bold": true },
                  { "text": " файли у pages/ автоматично стають маршрутами." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "API-роути:", "bold": true },
                  { "text": " створення серверних ендпоінтів у pages/api/*." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оптимізація продуктивності:", "bold": true },
                  { "text": " автоматичний код-сплітинг і зменшення бандлу." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Підтримка App Router:", "bold": true },
                  {
                    "text": " використання React Server Components і app/ замість pages/."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Вбудована підтримка Tailwind, TypeScript, ESLint та інших технологій",
                    "bold": true
                  },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Застосовується для створення продуктивних вебзастосунків, блогів, e-commerce та складних інтерфейсів."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "84. What is Next.js?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Next.js", "bold": true },
              {
                "text": " is a React framework that provides built-in solutions for server-side rendering (SSR), static site generation (SSG), API routes, routing, performance optimization, and SEO."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key features:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Hybrid rendering:", "bold": true },
                  { "text": " support for SSR, SSG, and ISR." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatic routing:", "bold": true },
                  { "text": " files in pages/ become routes automatically." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "API routes:", "bold": true },
                  { "text": " building backend endpoints in pages/api/*." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Performance optimization:", "bold": true },
                  { "text": " automatic code splitting and smaller bundles." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "App Router support:", "bold": true },
                  {
                    "text": " based on React Server Components and the app/ directory."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Built-in support for Tailwind, TypeScript, ESLint, and other tools",
                    "bold": true
                  },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Used to build high-performance web applications, blogs, e-commerce platforms, and complex user interfaces."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "84. Czym jest Next.js?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Next.js", "bold": true },
              {
                "text": " to framework React oferujący gotowe rozwiązania dla renderowania po stronie serwera (SSR), generowania statycznego (SSG), tras API, routingu, optymalizacji wydajności oraz SEO."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne możliwości:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Renderowanie hybrydowe:", "bold": true },
                  { "text": " obsługa SSR, SSG oraz ISR." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatyczny routing:", "bold": true },
                  { "text": " pliki w pages/ automatycznie stają się trasami." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Trasy API:", "bold": true },
                  {
                    "text": " tworzenie endpointów backendowych w pages/api/*."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optymalizacja wydajności:", "bold": true },
                  {
                    "text": " automatyczny podział kodu i mniejsze bundlowanie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Obsługa App Router:", "bold": true },
                  {
                    "text": " podejście oparte na React Server Components i katalogu app/."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wbudowana obsługa Tailwind, TypeScript, ESLint i innych technologii",
                    "bold": true
                  },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Stosowany do budowy wydajnych aplikacji webowych, blogów, e-commerce oraz złożonych interfejsów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 85,
    "translations": {
      "uk": {
        "question": "85. Які головні відмінності між Next.js і React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Головні відмінності між Next.js і React:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Критерій", "bold": true }],
              [{ "text": "React", "bold": true }],
              [{ "text": "Next.js", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Тип", "bold": true }],
                [{ "text": "Бібліотека для створення UI" }],
                [{ "text": "Фреймворк на базі React" }]
              ],
              [
                [{ "text": "Рендеринг", "bold": true }],
                [{ "text": "Тільки клієнтський (CSR)" }],
                [{ "text": "Підтримує CSR, SSR, SSG, ISR" }]
              ],
              [
                [{ "text": "Маршрутизація", "bold": true }],
                [{ "text": "Реалізується вручну через React Router" }],
                [
                  { "text": "Файлова маршрутизація (" },
                  { "text": "pages/", "code": true },
                  { "text": " або " },
                  { "text": "app/", "code": true },
                  { "text": ")" }
                ]
              ],
              [
                [{ "text": "SEO", "bold": true }],
                [{ "text": "Обмежена підтримка через CSR" }],
                [{ "text": "Повноцінна підтримка SEO (SSR, SSG)" }]
              ],
              [
                [{ "text": "API-роути", "bold": true }],
                [{ "text": "Відсутні" }],
                [
                  { "text": "Вбудовані API-ендпоінти (" },
                  { "text": "pages/api/", "code": true },
                  { "text": ")" }
                ]
              ],
              [
                [{ "text": "Кешування", "bold": true }],
                [{ "text": "Немає вбудованих механізмів" }],
                [
                  {
                    "text": "ISR для оновлення сторінок без повної регенерації"
                  }
                ]
              ],
              [
                [{ "text": "Оптимізація продуктивності", "bold": true }],
                [{ "text": "Покладається на сторонні рішення" }],
                [{ "text": "Вбудовані оптимізації та код-сплітинг" }]
              ],
              [
                [{ "text": "Серверні компоненти", "bold": true }],
                [{ "text": "Залежить від налаштувань" }],
                [
                  { "text": "Вбудована підтримка React Server Components (" },
                  { "text": "app/", "code": true },
                  { "text": ")" }
                ]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React", "bold": true },
                  { "text": " підходить для клієнтських SPA." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Next.js", "bold": true },
                  {
                    "text": " орієнтований на SEO, гібридний рендеринг та продуктивність."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "85. What are the main differences between Next.js and React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Main differences between Next.js and React:" }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Criteria", "bold": true }],
              [{ "text": "React", "bold": true }],
              [{ "text": "Next.js", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Type", "bold": true }],
                [{ "text": "UI library" }],
                [{ "text": "Framework built on React" }]
              ],
              [
                [{ "text": "Rendering", "bold": true }],
                [{ "text": "Client-side only (CSR)" }],
                [{ "text": "Supports CSR, SSR, SSG, ISR" }]
              ],
              [
                [{ "text": "Routing", "bold": true }],
                [{ "text": "Manual setup via React Router" }],
                [
                  { "text": "File-based routing (" },
                  { "text": "pages/", "code": true },
                  { "text": " or " },
                  { "text": "app/", "code": true },
                  { "text": ")" }
                ]
              ],
              [
                [{ "text": "SEO", "bold": true }],
                [{ "text": "Limited due to CSR" }],
                [{ "text": "Strong SEO support (SSR, SSG)" }]
              ],
              [
                [{ "text": "API routes", "bold": true }],
                [{ "text": "Not available" }],
                [
                  { "text": "Built-in API endpoints (" },
                  { "text": "pages/api/", "code": true },
                  { "text": ")" }
                ]
              ],
              [
                [{ "text": "Caching", "bold": true }],
                [{ "text": "No built-in mechanisms" }],
                [{ "text": "ISR for incremental page updates" }]
              ],
              [
                [{ "text": "Performance optimization", "bold": true }],
                [{ "text": "Relies on external tools" }],
                [{ "text": "Built-in optimizations and code splitting" }]
              ],
              [
                [{ "text": "Server Components", "bold": true }],
                [{ "text": "Configuration dependent" }],
                [
                  { "text": "Native support for React Server Components (" },
                  { "text": "app/", "code": true },
                  { "text": ")" }
                ]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Conclusion:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React", "bold": true },
                  { "text": " fits client-rendered SPAs." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Next.js", "bold": true },
                  {
                    "text": " is better for SEO-focused and high-performance applications."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "85. Jakie są główne różnice między Next.js a React?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne różnice między Next.js a React:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Kryterium", "bold": true }],
              [{ "text": "React", "bold": true }],
              [{ "text": "Next.js", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Typ", "bold": true }],
                [{ "text": "Biblioteka UI" }],
                [{ "text": "Framework oparty na React" }]
              ],
              [
                [{ "text": "Renderowanie", "bold": true }],
                [{ "text": "Tylko po stronie klienta (CSR)" }],
                [{ "text": "CSR, SSR, SSG, ISR" }]
              ],
              [
                [{ "text": "Routing", "bold": true }],
                [{ "text": "Konfiguracja ręczna (React Router)" }],
                [
                  { "text": "Routing plikowy (" },
                  { "text": "pages/", "code": true },
                  { "text": " lub " },
                  { "text": "app/", "code": true },
                  { "text": ")" }
                ]
              ],
              [
                [{ "text": "SEO", "bold": true }],
                [{ "text": "Ograniczone przez CSR" }],
                [{ "text": "Dobra obsługa SEO (SSR, SSG)" }]
              ],
              [
                [{ "text": "Trasy API", "bold": true }],
                [{ "text": "Brak" }],
                [
                  { "text": "Wbudowane endpointy API (" },
                  { "text": "pages/api/", "code": true },
                  { "text": ")" }
                ]
              ],
              [
                [{ "text": "Cache", "bold": true }],
                [{ "text": "Brak mechanizmów wbudowanych" }],
                [{ "text": "ISR umożliwiający częściowe odświeżanie" }]
              ],
              [
                [{ "text": "Optymalizacja wydajności", "bold": true }],
                [{ "text": "Zależna od narzędzi zewnętrznych" }],
                [{ "text": "Wbudowane optymalizacje i code splitting" }]
              ],
              [
                [{ "text": "Komponenty serwerowe", "bold": true }],
                [{ "text": "Zależne od konfiguracji" }],
                [
                  { "text": "Natywna obsługa React Server Components (" },
                  { "text": "app/", "code": true },
                  { "text": ")" }
                ]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wniosek:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React", "bold": true },
                  { "text": " sprawdzi się w SPA po stronie klienta." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Next.js", "bold": true },
                  {
                    "text": " jest lepszy dla SEO i aplikacji o wysokiej wydajności."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 86,
    "translations": {
      "uk": {
        "question": "86. Для чого потрібен React Helmet Async?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Helmet Async", "bold": true },
              { "text": " - це оптимізована версія " },
              { "text": "React Helmet", "bold": true },
              { "text": ", яка використовується для динамічного оновлення " },
              { "text": "<head>", "code": true },
              {
                "text": " (мета-теги, заголовки, Open Graph тощо) у React-додатках."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Навіщо потрібен?" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO-оптимізація", "bold": true },
                  {
                    "text": " – динамічна зміна title, meta description, ключових слів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Динамічний `<head>`", "bold": true },
                  { "text": " – керування head без перезавантаження сторінки." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Підтримка SSR", "bold": true },
                  {
                    "text": " – коректна робота в SSR без асинхронних конфліктів."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад використання:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { Helmet } from 'react-helmet-async';\n\nfunction MyComponent() {\n  return (\n    <Helmet>\n      <title>Головна сторінка</title>\n      <meta name=\"description\" content=\"Це опис для головної сторінки\" />\n    </Helmet>\n  );\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "SSR (Next.js, Express):" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { HelmetProvider, Helmet } from 'react-helmet-async';\n\nconst helmetContext = {};\nconst html = renderToString(\n  <HelmetProvider context={helmetContext}>\n    <App />\n  </HelmetProvider>\n);\nconst { helmet } = helmetContext;"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Чому краще за " },
              { "text": "react-helmet", "code": true },
              { "text": "?" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Працює з SSR без помилок асинхронності." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Легший і швидший." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Сумісний з " },
                  { "text": "StrictMode", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для React-додатків з SEO та SSR варто використовувати "
              },
              { "text": "react-helmet-async", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "en": {
        "question": "86. What is React Helmet Async used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Helmet Async", "bold": true },
              { "text": " is an optimized version of " },
              { "text": "React Helmet", "bold": true },
              { "text": " used to dynamically manage the " },
              { "text": "<head>", "code": true },
              {
                "text": " section (meta tags, titles, Open Graph) in React applications."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Why is it needed?" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "SEO optimization", "bold": true },
                  { "text": " – dynamic control over title and meta tags." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dynamic `<head>`", "bold": true },
                  { "text": " – page-level head management without reloads." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SSR support", "bold": true },
                  { "text": " – works correctly with server-side rendering." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usage example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "import { Helmet } from 'react-helmet-async';\n\nfunction MyComponent() {\n  return (\n    <Helmet>\n      <title>Home page</title>\n      <meta name=\"description\" content=\"Home page description\" />\n    </Helmet>\n  );\n}"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Why better than react-helmet?" }]
          },
          {
            "type": "bulletList",
            "children": [
              { "type": "listItem", "children": [{ "text": "Safe for SSR." }] },
              {
                "type": "listItem",
                "children": [{ "text": "Smaller and faster." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Compatible with " },
                  { "text": "StrictMode", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Conclusion:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "For React apps with SSR and SEO requirements, use " },
              { "text": "react-helmet-async", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "pl": {
        "question": "86. Do czego służy React Helmet Async?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React Helmet Async", "bold": true },
              { "text": " to zoptymalizowana wersja " },
              { "text": "React Helmet", "bold": true },
              { "text": " do dynamicznego zarządzania sekcją " },
              { "text": "<head>", "code": true },
              {
                "text": " (meta tagi, tytuły, Open Graph) w aplikacjach React."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dlaczego jest potrzebny?" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Optymalizacja SEO", "bold": true },
                  { "text": " – dynamiczne zarządzanie meta danymi." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dynamiczny `<head>`", "bold": true },
                  { "text": " – zmiany bez przeładowania strony." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wsparcie SSR", "bold": true },
                  {
                    "text": " – poprawne działanie z renderowaniem po stronie serwera."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dlaczego lepszy od react-helmet?" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Bezpieczny dla SSR." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Lżejszy i szybszy." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Działa poprawnie z " },
                  { "text": "StrictMode", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wniosek:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Dla aplikacji React z SEO i SSR należy używać " },
              { "text": "react-helmet-async", "code": true },
              { "text": "." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 87,
    "translations": {
      "uk": {
        "question": "87. Що таке розподілений компонент (Distributed Component)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Розподілений компонент (Distributed Component)",
                "bold": true
              },
              {
                "text": " - це архітектурна концепція, за якої компонент поділяється на незалежні частини, що можуть виконуватися або рендеритися окремо, але логічно працюють як єдине ціле."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади реалізації:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Код-сплітинг (Code Splitting)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Компоненти завантажуються лише за потреби, що зменшує початковий розмір бандла."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Container-Presentational Pattern", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Розділення бізнес-логіки та UI для кращої підтримки та повторного використання."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Мікрофронтенди (Micro Frontends)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Автономні частини інтерфейсу, що розробляються та деплояться незалежно."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коли використовувати:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Для оптимізації продуктивності та зменшення початкового завантаження."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Для відокремлення логіки від відображення." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Для масштабованих та командно-орієнтованих проєктів."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "87. What is a Distributed Component?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A Distributed Component", "bold": true },
              {
                "text": " is an architectural concept where a component is split into independent parts that can render or execute logic separately while functioning as a single unit."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Implementation examples:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Code Splitting", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Components are loaded only when needed, reducing initial bundle size."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Container-Presentational Pattern", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Separates business logic from UI for better maintainability."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Micro Frontends", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Independent UI parts developed and deployed separately."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "When to use:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "To improve performance via lazy loading." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "To simplify code maintenance and reuse." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "For large-scale and team-distributed applications."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "87. Czym jest komponent rozproszony (Distributed Component)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Komponent rozproszony (Distributed Component)",
                "bold": true
              },
              {
                "text": " to koncepcja architektoniczna, w której komponent jest podzielony na niezależne części działające osobno, ale razem tworzące spójną całość."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady zastosowania:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Code Splitting", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Komponenty są ładowane tylko wtedy, gdy są potrzebne."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wzorzec Container-Presentational", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Oddzielenie logiki aplikacji od warstwy wizualnej."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mikrofrontendy (Micro Frontends)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Niezależne części interfejsu rozwijane przez różne zespoły."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kiedy stosować:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "W celu poprawy wydajności i czasu ładowania." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dla lepszej struktury i utrzymania kodu." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "W dużych i skalowalnych aplikacjach." }]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 88,
    "translations": {
      "uk": {
        "question": "88. Що таке компонент-перемикач (Switching Component)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Компонент-перемикач (Switching Component)",
                "bold": true
              },
              {
                "text": " — це патерн у React, за якого компонент умовно рендерить один із дочірніх компонентів залежно від стану, пропсів, маршруту або даних."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад: перемикання за умовою" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const SwitchingComponent = ({ type }) => {\n  switch (type) {\n    case 'success': return <SuccessMessage />;\n    case 'error': return <ErrorMessage />;\n    default: return <DefaultMessage />;\n  }\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Такий підхід централізує умовний рендеринг і спрощує підтримку коду."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "88. What is a Switching Component?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A Switching Component", "bold": true },
              {
                "text": " is a React pattern where a component conditionally renders one of its child components based on state, props, routes, or data."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example: conditional switching" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const SwitchingComponent = ({ type }) => {\n  switch (type) {\n    case 'success': return <SuccessMessage />;\n    case 'error': return <ErrorMessage />;\n    default: return <DefaultMessage />;\n  }\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This pattern keeps conditional rendering explicit and easier to maintain."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "88. Czym jest komponent przełączający (Switching Component)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Komponent przełączający (Switching Component)",
                "bold": true
              },
              {
                "text": " to wzorzec w React, w którym komponent renderuje różne komponenty potomne w zależności od warunku, stanu lub danych."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład: renderowanie warunkowe" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const SwitchingComponent = ({ type }) => {\n  switch (type) {\n    case 'success': return <SuccessMessage />;\n    case 'error': return <ErrorMessage />;\n    default: return <DefaultMessage />;\n  }\n};"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wzorzec ten porządkuje logikę warunkową i poprawia czytelność kodu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 89,
    "translations": {
      "uk": {
        "question": "89. Що таке Reselect та як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Reselect", "bold": true },
              {
                "text": " - це бібліотека для створення мемоізованих селекторів у Redux. Вона оптимізує отримання похідних даних зі стану та зменшує кількість зайвих рендерів."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює Reselect?" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Reselect використовує ", "text2": null },
              { "text": "мемоізацію", "bold": true },
              {
                "text": ", щоб повторно використовувати результат обчислень, якщо вхідні дані не змінилися."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Input-селектори", "bold": true },
                  { "text": " отримують дані зі state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Результуючий селектор", "bold": true },
                  { "text": " обчислює похідні дані." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Результат кешується", "bold": true },
                  { "text": " і перевикористовується при незмінних входах." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Менше обчислень при кожному рендері." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Менше непотрібних рендерів компонентів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Покращення продуктивності Redux-додатків." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "89. What is Reselect and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Reselect", "bold": true },
              {
                "text": " is a library for creating memoized selectors in Redux. It optimizes derived data access and reduces unnecessary re-renders."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How does Reselect work?" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Reselect uses ", "text2": null },
              { "text": "memoization", "bold": true },
              {
                "text": " to reuse computed results when input data has not changed."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Input selectors", "bold": true },
                  { "text": " read data from the state." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Result selector", "bold": true },
                  { "text": " computes derived values." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Results are cached", "bold": true },
                  { "text": " and reused when inputs are unchanged." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Benefits:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Fewer computations per render." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Prevents unnecessary component re-renders." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Improves Redux application performance." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "89. Czym jest Reselect i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Reselect", "bold": true },
              {
                "text": " to biblioteka do tworzenia memoizowanych selektorów w Redux. Służy do optymalizacji obliczeń i ograniczenia zbędnych renderów."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa Reselect?" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Reselect wykorzystuje ", "text2": null },
              { "text": "memoizację", "bold": true },
              {
                "text": ", aby ponownie używać wyników obliczeń, jeśli dane wejściowe się nie zmieniły."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Selektory wejściowe", "bold": true },
                  { "text": " pobierają dane ze stanu." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Selektor wynikowy", "bold": true },
                  { "text": " oblicza dane pochodne." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wyniki są buforowane", "bold": true },
                  { "text": " i używane ponownie przy tych samych danych." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Mniej zbędnych obliczeń." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mniej niepotrzebnych renderów komponentów." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Lepsza wydajność aplikacji Redux." }]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 90,
    "translations": {
      "uk": {
        "question": "90. Які типи даних може повернути render?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Метод " },
              { "text": "render()", "code": true },
              { "text": " у React може повертати:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "JSX або React-елемент", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "render() {\n  return <div>Hello, World!</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Масив елементів", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "render() {\n  return [\n    <li key=\"1\">Item 1</li>,\n    <li key=\"2\">Item 2</li>\n  ];\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Фрагменти (React.Fragment)", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "render() {\n  return (\n    <>\n      <h1>Title</h1>\n      <p>Description</p>\n    </>\n  );\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "null", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "render() {\n  return null;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Булеві значення", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "render() {\n  return false;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Рядки та числа", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "render() {\n  return \"Hello, World!\";\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Портали", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import { createPortal } from 'react-dom';\n\nrender() {\n  return createPortal(\n    <div>Modal</div>,\n    document.getElementById('modal-root')\n  );\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Найчастіше render повертає JSX, але React підтримує й інші типи для гнучкого рендерингу."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "90. What data types can render return?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": "render()", "code": true },
              { "text": " method in React can return:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "JSX or a React element", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "An array of elements", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Fragments (React.Fragment)", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "null", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Boolean values (ignored)", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Strings and numbers", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Portals", "bold": true }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "JSX is the common case, but React supports multiple return types for flexible rendering."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "90. Jakie typy danych może zwrócić render?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Metoda " },
              { "text": "render()", "code": true },
              { "text": " w React może zwracać:" }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "JSX lub element React", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Tablicę elementów", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Fragmenty (React.Fragment)", "bold": true }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "null", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Wartości logiczne", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Tekst i liczby", "bold": true }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Portale", "bold": true }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Najczęściej zwracany jest JSX, ale React dopuszcza wiele form renderowania."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 91,
    "translations": {
      "uk": {
        "question": "91. Як React обробляє чи обмежує використання пропсів певного типу?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React обмежує типи пропсів за допомогою " },
              { "text": "PropTypes", "code": true },
              { "text": " або " },
              { "text": "TypeScript", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "PropTypes", "bold": true },
                  { "text": " — runtime-перевірка типів у JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "TypeScript", "bold": true },
                  { "text": " — статична перевірка типів на етапі компіляції." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "TypeScript забезпечує суворий контроль до запуску коду. PropTypes дає лише попередження під час виконання."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "91. How does React handle or restrict props of specific types?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React restricts prop types using " },
              { "text": "PropTypes", "code": true },
              { "text": " or " },
              { "text": "TypeScript", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "PropTypes", "bold": true },
                  { "text": " — runtime type checking in JavaScript." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "TypeScript", "bold": true },
                  { "text": " — compile-time static type checking." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Conclusion:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "TypeScript prevents invalid props before runtime. PropTypes only warns during execution."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "91. Jak React ogranicza użycie propsów określonego typu?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React ogranicza typy propsów za pomocą " },
              { "text": "PropTypes", "code": true },
              { "text": " lub " },
              { "text": "TypeScript", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "PropTypes", "bold": true },
                  { "text": " — sprawdzanie typów w czasie działania." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "TypeScript", "bold": true },
                  {
                    "text": " — statyczna kontrola typów na etapie kompilacji."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wniosek:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "TypeScript wykrywa błędy wcześniej. PropTypes daje tylko ostrzeżenia w runtime."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 92,
    "translations": {
      "uk": {
        "question": "92. Різниця між рендерингом та монтуванням?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Різниця між рендерингом та монтуванням у React." }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Процес", "bold": true }],
              [{ "text": "Опис", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Монтування (Mounting)", "bold": true }],
                [
                  {
                    "text": "Компонент створюється і додається в DOM вперше. Викликаються "
                  },
                  { "text": "constructor", "code": true },
                  { "text": ", " },
                  { "text": "render", "code": true },
                  { "text": ", " },
                  { "text": "componentDidMount", "code": true },
                  { "text": " або " },
                  { "text": "useEffect", "code": true },
                  { "text": " з порожнім масивом залежностей." }
                ]
              ],
              [
                [{ "text": "Рендеринг (Rendering)", "bold": true }],
                [
                  { "text": "Оновлення UI через повторний виклик " },
                  { "text": "render()", "code": true },
                  { "text": " або функціонального компонента при зміні " },
                  { "text": "state", "code": true },
                  { "text": " чи " },
                  { "text": "props", "code": true },
                  { "text": "." }
                ]
              ]
            ]
          }
        ]
      },
      "en": {
        "question": "92. What is the difference between rendering and mounting?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The difference between rendering and mounting in React."
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Process", "bold": true }],
              [{ "text": "Description", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Mounting", "bold": true }],
                [
                  {
                    "text": "The component is created and inserted into the DOM for the first time. Calls include "
                  },
                  { "text": "constructor", "code": true },
                  { "text": ", " },
                  { "text": "render", "code": true },
                  { "text": ", " },
                  { "text": "componentDidMount", "code": true },
                  { "text": " or " },
                  { "text": "useEffect", "code": true },
                  { "text": " with an empty dependency array." }
                ]
              ],
              [
                [{ "text": "Rendering", "bold": true }],
                [
                  { "text": "UI updates via repeated calls to " },
                  { "text": "render()", "code": true },
                  {
                    "text": " or re execution of a functional component when "
                  },
                  { "text": "state", "code": true },
                  { "text": " or " },
                  { "text": "props", "code": true },
                  { "text": " change." }
                ]
              ]
            ]
          }
        ]
      },
      "pl": {
        "question": "92. Jaka jest różnica między renderowaniem a montowaniem?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Różnica między renderowaniem a montowaniem w React."
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Proces", "bold": true }],
              [{ "text": "Opis", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "Montowanie (Mounting)", "bold": true }],
                [
                  {
                    "text": "Komponent jest tworzony i po raz pierwszy dodawany do DOM. Wywoływane są "
                  },
                  { "text": "constructor", "code": true },
                  { "text": ", " },
                  { "text": "render", "code": true },
                  { "text": ", " },
                  { "text": "componentDidMount", "code": true },
                  { "text": " lub " },
                  { "text": "useEffect", "code": true },
                  { "text": " z pustą tablicą zależności." }
                ]
              ],
              [
                [{ "text": "Renderowanie (Rendering)", "bold": true }],
                [
                  { "text": "Aktualizacja UI poprzez ponowne wywołanie " },
                  { "text": "render()", "code": true },
                  { "text": " lub funkcji komponentu przy zmianie " },
                  { "text": "state", "code": true },
                  { "text": " albo " },
                  { "text": "props", "code": true },
                  { "text": "." }
                ]
              ]
            ]
          }
        ]
      }
    }
  },

  {
    "category": "react",
    "order": 93,
    "translations": {
      "uk": {
        "question": "93. Що таке реактивний потік даних (reactive data flow) у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Реактивний потік даних (Reactive Data Flow) у React",
                "bold": true
              },
              {
                "text": " означає, що зміни в стані або пропсах автоматично призводять до оновлення UI без ручного керування ререндерингом."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні принципи:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Односторонній потік даних", "bold": true },
                  { "text": " – дані передаються зверху вниз." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Декларативність", "bold": true },
                  {
                    "text": " – описується результат, а не процес оновлення."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Автоматичний ререндер", "bold": true },
                  { "text": " – UI оновлюється при зміні state або props." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "93. What is reactive data flow in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Reactive data flow in React",
                "bold": true
              },
              {
                "text": " means that changes in state or props automatically trigger UI updates without manual re rendering."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core principles:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "One way data flow", "bold": true },
                  { "text": " – data flows from parent to child components." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Declarative model", "bold": true },
                  {
                    "text": " – developers describe what to render, not how."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatic updates", "bold": true },
                  { "text": " – UI updates when state or props change." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "93. Czym jest reaktywny przepływ danych w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Reaktywny przepływ danych w React",
                "bold": true
              },
              {
                "text": " oznacza, że zmiany stanu lub propsów automatycznie powodują aktualizację interfejsu użytkownika."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne zasady:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Jednokierunkowy przepływ danych", "bold": true },
                  { "text": " – dane przekazywane są z góry w dół." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Deklaratywność", "bold": true },
                  {
                    "text": " – opisujemy rezultat, a nie mechanizm aktualizacji."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatyczne renderowanie", "bold": true },
                  {
                    "text": " – UI aktualizuje się przy zmianie state lub props."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },

  {
    "category": "react",
    "order": 94,
    "translations": {
      "uk": {
        "question": "94. Чи є React реактивним?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React не є повністю реактивною бібліотекою. Він використовує реактивні ідеї, але реалізує їх через власну модель рендерингу."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Автоматичне оновлення UI", "bold": true },
                  {
                    "text": " – UI оновлюється при зміні state або props через повторний рендер."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Хуки та функціональні компоненти",
                    "bold": true
                  },
                  {
                    "text": " – "
                  },
                  { "text": "useState", "code": true },
                  { "text": ", " },
                  { "text": "useEffect", "code": true },
                  {
                    "text": " створюють реактивну поведінку, але без автоматичних спостерігачів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Обмежена реактивність", "bold": true },
                  {
                    "text": " – React реагує лише на зміни state і props, а не на довільні змінні."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React реактивний на рівні UI, але не є повністю реактивним фреймворком."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "94. Is React reactive?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React is not a fully reactive library. It applies reactive ideas through its rendering model."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatic UI updates", "bold": true },
                  {
                    "text": " – the UI updates when state or props change via re rendering."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hooks and functional components", "bold": true },
                  { "text": " – " },
                  { "text": "useState", "code": true },
                  { "text": ", " },
                  { "text": "useEffect", "code": true },
                  {
                    "text": " enable reactive behavior without automatic dependency tracking."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Limited reactivity", "bold": true },
                  {
                    "text": " – React reacts only to state and props changes, not arbitrary variables."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React is reactive at the UI level but not a fully reactive framework."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "94. Czy React jest reaktywny?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React nie jest w pełni reaktywną biblioteką. Wykorzystuje idee reaktywności poprzez własny mechanizm renderowania."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatyczna aktualizacja UI", "bold": true },
                  {
                    "text": " – interfejs aktualizuje się przy zmianie state lub props."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hooki i komponenty funkcyjne", "bold": true },
                  { "text": " – " },
                  { "text": "useState", "code": true },
                  { "text": ", " },
                  { "text": "useEffect", "code": true },
                  {
                    "text": " zapewniają reaktywność bez automatycznego śledzenia zależności."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ograniczona reaktywność", "bold": true },
                  {
                    "text": " – React reaguje wyłącznie na zmiany state i props."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React jest reaktywny na poziomie UI, ale nie jest w pełni reaktywnym frameworkiem."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 95,
    "translations": {
      "uk": {
        "question": "95. Які варіанти реалізації drag-and-drop у React ти знаєш?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Drag-and-drop у React можна реалізувати кількома підходами, від нативних API до спеціалізованих бібліотек."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "HTML5 Drag-and-Drop API", "bold": true },
                  { "text": " – нативні події браузера." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "react-dnd", "bold": true },
                  { "text": " – гнучка бібліотека для складних сценаріїв." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dnd-kit", "bold": true },
                  { "text": " – сучасне та легке рішення." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Вибір підходу залежить від складності drag-and-drop логіки та вимог до контролю."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "95. What drag-and-drop implementation options do you know in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Drag and drop in React can be implemented using native browser APIs or dedicated libraries."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "HTML5 Drag-and-Drop API", "bold": true },
                  { "text": " – built in browser events." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "react-dnd", "bold": true },
                  { "text": " – flexible solution for complex use cases." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dnd-kit", "bold": true },
                  { "text": " – modern and lightweight alternative." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The choice depends on the required complexity and level of control."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "95. Jakie znasz sposoby implementacji drag-and-drop w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Drag-and-drop w React można zaimplementować przy użyciu natywnych API lub bibliotek zewnętrznych."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "HTML5 Drag-and-Drop API", "bold": true },
                  { "text": " – wbudowane mechanizmy przeglądarki." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "react-dnd", "bold": true },
                  {
                    "text": " – elastyczna biblioteka do złożonych przypadków."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dnd-kit", "bold": true },
                  { "text": " – nowoczesne i lekkie rozwiązanie." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wybór zależy od złożoności logiki i potrzebnej kontroli."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 96,
    "translations": {
      "uk": {
        "question": "96. Як відрендерити HTML код у React-компоненті?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Для рендерингу HTML у React використовується " },
              { "text": "dangerouslySetInnerHTML", "code": true },
              {
                "text": ". Це небезпечно при роботі з несанітизованими даними через ризик XSS."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function MyComponent() {\n  const htmlContent = \"<p style='color:red;'>Це HTML-код</p>\";\n\n  return <div dangerouslySetInnerHTML={{ __html: htmlContent }} />;\n}"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "HTML з зовнішніх джерел потрібно обовʼязково санітизувати."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "96. How do you render HTML code in a React component?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "To render raw HTML in React, use " },
              { "text": "dangerouslySetInnerHTML", "code": true },
              {
                "text": ". It is unsafe when used with unsanitized input due to XSS risks."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function MyComponent() {\n  const htmlContent = \"<p style='color:red;'>This is HTML</p>\";\n\n  return <div dangerouslySetInnerHTML={{ __html: htmlContent }} />;\n}"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Always sanitize dynamic HTML before rendering." }
            ]
          }
        ]
      },
      "pl": {
        "question": "96. Jak wyrenderować kod HTML w komponencie React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Do renderowania HTML w React używa się " },
              { "text": "dangerouslySetInnerHTML", "code": true },
              {
                "text": ". Jest to niebezpieczne przy danych niesanitizowanych ze względu na XSS."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "function MyComponent() {\n  const htmlContent = \"<p style='color:red;'>To jest HTML</p>\";\n\n  return <div dangerouslySetInnerHTML={{ __html: htmlContent }} />;\n}"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Dynamiczny HTML musi być wcześniej sanitizowany." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 97,
    "translations": {
      "uk": {
        "question": "97. Як реалізувати додавання класу за умовою в React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У React умовне додавання CSS класів виконується через "
              },
              { "text": "className", "code": true },
              { "text": " з використанням умовної логіки." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні підходи:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Тернарний оператор", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent({ isActive }) {\n  return <div className={isActive ? 'active' : 'inactive'}>Hello</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Шаблонні рядки", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent({ isHighlighted }) {\n  return <div className={`base ${isHighlighted ? 'highlighted' : ''}`}>Hello</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Бібліотека clsx", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import clsx from 'clsx';\n\nfunction MyComponent({ isActive, isDisabled }) {\n  return (\n    <div className={clsx('base', { active: isActive, disabled: isDisabled })}>Hello</div>\n  );\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для складних умов використання бібліотек підвищує читабельність коду."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "97. How do you conditionally add a class in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "In React, conditional class assignment is done via " },
              { "text": "className", "code": true },
              { "text": " combined with conditional logic." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Common approaches:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Ternary operator", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent({ isActive }) {\n  return <div className={isActive ? 'active' : 'inactive'}>Hello</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Template literals", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent({ isHighlighted }) {\n  return <div className={`base ${isHighlighted ? 'highlighted' : ''}`}>Hello</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "clsx library", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import clsx from 'clsx';\n\nfunction MyComponent({ isActive, isDisabled }) {\n  return (\n    <div className={clsx('base', { active: isActive, disabled: isDisabled })}>Hello</div>\n  );\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Libraries are preferred when conditional logic becomes complex."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "97. Jak warunkowo dodać klasę w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W React warunkowe dodawanie klas CSS odbywa się przez "
              },
              { "text": "className", "code": true },
              { "text": " z użyciem logiki warunkowej." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne podejścia:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Operator trójargumentowy", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent({ isActive }) {\n  return <div className={isActive ? 'active' : 'inactive'}>Hello</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Template stringi", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "function MyComponent({ isHighlighted }) {\n  return <div className={`base ${isHighlighted ? 'highlighted' : ''}`}>Hello</div>;\n}"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Biblioteka clsx", "bold": true },
                  {
                    "type": "code",
                    "language": "jsx",
                    "content": "import clsx from 'clsx';\n\nfunction MyComponent({ isActive, isDisabled }) {\n  return (\n    <div className={clsx('base', { active: isActive, disabled: isDisabled })}>Hello</div>\n  );\n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Przy bardziej złożonych warunkach biblioteki poprawiają czytelność kodu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 98,
    "translations": {
      "uk": {
        "question": "98. Як виконати код перед видаленням компонента з дерева?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У React код перед видаленням компонента виконується через спеціальні хуки або методи життєвого циклу."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Класові компоненти", "bold": true },
                  { "text": " – використовується метод " },
                  { "text": "componentWillUnmount", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Функціональні компоненти", "bold": true },
                  { "text": " – використовується " },
                  { "text": "useEffect", "code": true },
                  { "text": " з функцією очищення." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Цей код виконується безпосередньо перед демонтуванням компонента."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "98. How do you run code before a component is removed from the tree?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In React, code before a component is removed is executed using lifecycle methods or hooks."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Class components", "bold": true },
                  { "text": " – use the " },
                  { "text": "componentWillUnmount", "code": true },
                  { "text": " lifecycle method." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Functional components", "bold": true },
                  { "text": " – use " },
                  { "text": "useEffect", "code": true },
                  { "text": " with a cleanup function." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This logic runs right before the component is unmounted."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "98. Jak wykonać kod przed usunięciem komponentu z drzewa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W React kod przed usunięciem komponentu wykonuje się za pomocą metod cyklu życia lub hooków."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponenty klasowe", "bold": true },
                  { "text": " – używają metody " },
                  { "text": "componentWillUnmount", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Komponenty funkcyjne", "bold": true },
                  { "text": " – używają " },
                  { "text": "useEffect", "code": true },
                  { "text": " z funkcją czyszczącą." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Kod ten uruchamia się bezpośrednio przed odmontowaniem komponentu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 99,
    "translations": {
      "uk": {
        "question": "99. Що таке useReducer()?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "useReducer()", "code": true },
              {
                "text": " — це хук React для керування станом у функціональних компонентах. Він є альтернативою "
              },
              { "text": "useState()", "code": true },
              {
                "text": " і використовується, коли логіка оновлення стану складна або залежить від попереднього стану."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Синтаксис:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const [state, dispatch] = useReducer(reducer, initialState);"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reducer", "code": true },
                  {
                    "text": " — функція, що приймає state і action та повертає новий стан."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dispatch", "code": true },
                  { "text": " — викликає reducer з action." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "99. What is useReducer()?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "useReducer()", "code": true },
              {
                "text": " is a React hook used for state management in functional components. It is an alternative to "
              },
              { "text": "useState()", "code": true },
              {
                "text": " and is suited for complex state logic or state transitions based on previous state."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Syntax:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const [state, dispatch] = useReducer(reducer, initialState);"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reducer", "code": true },
                  {
                    "text": " — a function that returns new state based on state and action."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dispatch", "code": true },
                  { "text": " — triggers state updates via actions." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "99. Czym jest useReducer()?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "useReducer()", "code": true },
              {
                "text": " to hook React służący do zarządzania stanem w komponentach funkcyjnych. Jest alternatywą dla "
              },
              { "text": "useState()", "code": true },
              {
                "text": " i sprawdza się przy złożonej logice zmiany stanu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Składnia:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const [state, dispatch] = useReducer(reducer, initialState);"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reducer", "code": true },
                  {
                    "text": " — funkcja zwracająca nowy stan na podstawie akcji."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dispatch", "code": true },
                  { "text": " — wywołuje reducer z akcją." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 100,
    "translations": {
      "uk": {
        "question": "100. Як використовувати React.lazy та React.Suspense для запуску коду програми?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React.lazy", "code": true },
              { "text": " та " },
              { "text": "React.Suspense", "code": true },
              {
                "text": " використовуються для динамічного завантаження компонентів і розбиття коду (code splitting)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як це працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.lazy()", "code": true },
                  {
                    "text": " відкладено завантажує компонент через dynamic import."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React.Suspense", "code": true },
                  {
                    "text": " показує fallback-контент, поки компонент не завантажився."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const MyComponent = React.lazy(() => import('./MyComponent'));\n\nfunction App() {\n  return (\n    <React.Suspense fallback={<div>Завантаження...</div>}>\n      <MyComponent />\n    </React.Suspense>\n  );\n}"
          }
        ]
      },
      "en": {
        "question": "100. How do you use React.lazy and React.Suspense to load application code?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React.lazy", "code": true },
              { "text": " and " },
              { "text": "React.Suspense", "code": true },
              {
                "text": " are used for dynamic component loading and code splitting."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.lazy()", "code": true },
                  {
                    "text": " loads a component lazily using dynamic import."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React.Suspense", "code": true },
                  {
                    "text": " renders fallback UI while the component is loading."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const MyComponent = React.lazy(() => import('./MyComponent'));\n\nfunction App() {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <MyComponent />\n    </React.Suspense>\n  );\n}"
          }
        ]
      },
      "pl": {
        "question": "100. Jak używać React.lazy i React.Suspense do ładowania kodu aplikacji?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "React.lazy", "code": true },
              { "text": " oraz " },
              { "text": "React.Suspense", "code": true },
              {
                "text": " służą do dynamicznego ładowania komponentów i podziału kodu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak to działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React.lazy()", "code": true },
                  {
                    "text": " ładuje komponent z opóźnieniem przez dynamic import."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React.Suspense", "code": true },
                  {
                    "text": " wyświetla fallback, dopóki komponent się nie załaduje."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "const MyComponent = React.lazy(() => import('./MyComponent'));\n\nfunction App() {\n  return (\n    <React.Suspense fallback={<div>Ładowanie...</div>}>\n      <MyComponent />\n    </React.Suspense>\n  );\n}"
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 101,
    "translations": {
      "uk": {
        "question": "101. Які підходи використовуються для виконання HTTP-запитів у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React не має власного API для HTTP-запитів, тому використовуються стандартні можливості JavaScript або сторонні бібліотеки."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fetch API", "bold": true },
                  {
                    "text": " — нативний браузерний спосіб для простих HTTP-запитів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Axios", "bold": true },
                  {
                    "text": " — бібліотека з підтримкою interceptors, тайм-аутів і зручнішого API."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Query (TanStack Query)", "bold": true },
                  {
                    "text": " — керування серверним станом, кешування, refetch, retries."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GraphQL клієнти (Apollo)", "bold": true },
                  { "text": " — робота з GraphQL API." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Custom Hooks", "bold": true },
                  {
                    "text": " — винесення логіки запитів для повторного використання."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "101. What approaches are used to perform HTTP requests in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React does not provide a built-in HTTP API, so standard JavaScript tools or external libraries are used."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fetch API", "bold": true },
                  { "text": " — native browser API for basic requests." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Axios", "bold": true },
                  {
                    "text": " — library with interceptors, timeouts, and cleaner syntax."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Query (TanStack Query)", "bold": true },
                  {
                    "text": " — server state management with caching and refetching."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GraphQL clients (Apollo)", "bold": true },
                  { "text": " — for GraphQL based APIs." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Custom Hooks", "bold": true },
                  { "text": " — reusable abstraction for request logic." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "101. Jakie podejścia stosuje się do wykonywania zapytań HTTP w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "React nie posiada wbudowanego mechanizmu HTTP, dlatego używa się narzędzi JavaScript lub bibliotek zewnętrznych."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fetch API", "bold": true },
                  {
                    "text": " — natywne API przeglądarki do prostych zapytań."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Axios", "bold": true },
                  {
                    "text": " — biblioteka z interceptorami i wygodniejszym API."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Query (TanStack Query)", "bold": true },
                  {
                    "text": " — zarządzanie stanem danych z serwera i cache."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Klienci GraphQL (Apollo)", "bold": true },
                  { "text": " — obsługa API GraphQL." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Custom Hooks", "bold": true },
                  { "text": " — wielokrotne użycie logiki zapytań." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 102,
    "translations": {
      "uk": {
        "question": "102. Яка різниця між createElement і cloneElement?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Метод", "bold": true }],
              [{ "text": "Опис", "bold": true }],
              [{ "text": "Основне застосування", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "React.createElement", "code": true }],
                [
                  {
                    "text": "Створює новий React-елемент з типу, пропсів і дітей."
                  }
                ],
                [
                  {
                    "text": "Базове створення елементів, на чому працює JSX."
                  }
                ]
              ],
              [
                [{ "text": "React.cloneElement", "code": true }],
                [
                  {
                    "text": "Клонує існуючий React-елемент із можливістю змінити пропси або children."
                  }
                ],
                [{ "text": "Модифікація вже створених елементів." }]
              ]
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "createElement", "code": true },
                  { "text": " створює елемент з нуля." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "cloneElement", "code": true },
                  { "text": " працює лише з уже існуючим елементом." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "102. What is the difference between createElement and cloneElement?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Method", "bold": true }],
              [{ "text": "Description", "bold": true }],
              [{ "text": "Primary use", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "React.createElement", "code": true }],
                [
                  {
                    "text": "Creates a new React element from type, props, and children."
                  }
                ],
                [{ "text": "Core mechanism behind JSX rendering." }]
              ],
              [
                [{ "text": "React.cloneElement", "code": true }],
                [
                  {
                    "text": "Clones an existing React element and overrides props or children."
                  }
                ],
                [{ "text": "Modifying existing React elements." }]
              ]
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "createElement", "code": true },
                  { "text": " creates a brand new element." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "cloneElement", "code": true },
                  { "text": " requires an existing element to work with." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "102. Jaka jest różnica między createElement a cloneElement?",
        "answerBlocks": [
          {
            "type": "table",
            "header": [
              [{ "text": "Metoda", "bold": true }],
              [{ "text": "Opis", "bold": true }],
              [{ "text": "Główne zastosowanie", "bold": true }]
            ],
            "rows": [
              [
                [{ "text": "React.createElement", "code": true }],
                [
                  {
                    "text": "Tworzy nowy element React na podstawie typu, propsów i children."
                  }
                ],
                [{ "text": "Podstawa działania JSX." }]
              ],
              [
                [{ "text": "React.cloneElement", "code": true }],
                [
                  {
                    "text": "Klonuje istniejący element React i pozwala zmienić jego propsy lub children."
                  }
                ],
                [{ "text": "Modyfikowanie istniejących elementów." }]
              ]
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "createElement", "code": true },
                  { "text": " tworzy nowy element." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "cloneElement", "code": true },
                  { "text": " działa na istniejącym elemencie." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 103,
    "translations": {
      "uk": {
        "question": "103. Чи підтримує функція lazy іменований експорт?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Ні. " },
              { "text": "React.lazy", "code": true },
              {
                "text": " працює лише з default export. Іменований експорт напряму не підтримується."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Обхідне рішення:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "export const MyComponent = () => <div>Hello</div>;\n\nconst LazyComponent = React.lazy(() =>\n  import('./MyComponent').then(m => ({ default: m.MyComponent }))\n);"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Іменований експорт явно приводиться до default."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "103. Does React.lazy support named exports?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "No. " },
              { "text": "React.lazy", "code": true },
              {
                "text": " works only with default exports. Named exports are not supported directly."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Workaround:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "export const MyComponent = () => <div>Hello</div>;\n\nconst LazyComponent = React.lazy(() =>\n  import('./MyComponent').then(m => ({ default: m.MyComponent }))\n);"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The named export is explicitly mapped to default."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "103. Czy React.lazy obsługuje eksport nazwany?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Nie. " },
              { "text": "React.lazy", "code": true },
              {
                "text": " obsługuje wyłącznie eksport domyślny."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Rozwiązanie obejściowe:" }]
          },
          {
            "type": "code",
            "language": "jsx",
            "content": "export const MyComponent = () => <div>Hello</div>;\n\nconst LazyComponent = React.lazy(() =>\n  import('./MyComponent').then(m => ({ default: m.MyComponent }))\n);"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Eksport nazwany jest mapowany na default."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 104,
    "translations": {
      "uk": {
        "question": "104. Які переваги React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Висока продуктивність", "bold": true },
                  {
                    "text": " — використання Virtual DOM зменшує кількість оновлень реального DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Компонентна архітектура", "bold": true },
                  {
                    "text": " — повторне використання компонентів спрощує підтримку коду."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Односторонній потік даних", "bold": true },
                  { "text": " — спрощує контроль стану та налагодження." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Хуки", "bold": true },
                  {
                    "text": " — дозволяють керувати станом та ефектами без класів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Розвинена екосистема", "bold": true },
                  { "text": " — велика кількість бібліотек і інструментів." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "104. What are the advantages of React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "High performance", "bold": true },
                  { "text": " — Virtual DOM minimizes real DOM updates." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Component based architecture", "bold": true },
                  { "text": " — reusable components improve maintainability." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "One way data flow", "bold": true },
                  { "text": " — simplifies state tracking and debugging." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hooks", "bold": true },
                  {
                    "text": " — manage state and side effects without classes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Strong ecosystem", "bold": true },
                  { "text": " — rich tooling and library support." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "104. Jakie są zalety React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wysoka wydajność", "bold": true },
                  {
                    "text": " — Virtual DOM ogranicza aktualizacje prawdziwego DOM."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Architektura komponentowa", "bold": true },
                  { "text": " — komponenty są wielokrotnego użytku." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jednokierunkowy przepływ danych", "bold": true },
                  { "text": " — ułatwia kontrolę stanu aplikacji." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hooki", "bold": true },
                  { "text": " — zarządzanie stanem bez użycia klas." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Bogaty ekosystem", "bold": true },
                  { "text": " — wiele bibliotek i narzędzi." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 105,
    "translations": {
      "uk": {
        "question": "105. Які обмеження React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Надмірні перерендери", "bold": true },
                  {
                    "text": " — без оптимізації можливі проблеми з продуктивністю."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Складне керування станом", "bold": true },
                  { "text": " — великі додатки потребують додаткових рішень." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Однонаправлений потік даних", "bold": true },
                  {
                    "text": " — ускладнює передачу даних через глибоку ієрархію."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відсутність повної реактивності", "bold": true },
                  {
                    "text": " — оновлення через Virtual DOM не завжди оптимальні."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Залежність від JavaScript", "bold": true },
                  { "text": " — без JS функціональність обмежена." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Поріг входу", "bold": true },
                  {
                    "text": " — хуки, контекст і оптимізація вимагають досвіду."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "105. What are the limitations of React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Excessive re-renders", "bold": true },
                  { "text": " — poor optimization can hurt performance." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Complex state management", "bold": true },
                  { "text": " — larger apps require extra tooling." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "One-way data flow", "bold": true },
                  {
                    "text": " — passing data through deep trees is cumbersome."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Limited reactivity", "bold": true },
                  { "text": " — Virtual DOM updates are not always optimal." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "JavaScript dependency", "bold": true },
                  { "text": " — limited functionality without JS." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Learning curve", "bold": true },
                  { "text": " — hooks and optimization require experience." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "105. Jakie są ograniczenia React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Nadmierne renderowanie", "bold": true },
                  { "text": " — brak optymalizacji obniża wydajność." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Złożone zarządzanie stanem", "bold": true },
                  { "text": " — duże aplikacje wymagają dodatkowych narzędzi." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jednokierunkowy przepływ danych", "bold": true },
                  { "text": " — utrudnia przekazywanie danych w głąb drzewa." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ograniczona reaktywność", "bold": true },
                  { "text": " — Virtual DOM nie zawsze jest optymalny." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zależność od JavaScript", "bold": true },
                  { "text": " — brak pełnej funkcjonalności bez JS." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Krzywa uczenia", "bold": true },
                  { "text": " — hooki i optymalizacja wymagają praktyki." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 106,
    "translations": {
      "uk": {
        "question": "106. Для чого призначений метод registerServiceWorker() у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "registerServiceWorker()", "code": true },
              {
                "text": " використовувався у Create React App для реєстрації Service Worker. Метод застарілий і видалений, починаючи з CRA v4."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Кешування ресурсів і робота офлайн." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Швидше завантаження додатка." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Фонове оновлення ресурсів." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Зараз Service Worker потрібно реєструвати вручну через navigator.serviceWorker.register()."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "106. What is the purpose of registerServiceWorker() in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "registerServiceWorker()", "code": true },
              {
                "text": " was used in Create React App to register a Service Worker. It is deprecated and removed starting from CRA v4."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Offline caching support." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Faster application loading." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Background resource updates." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Today, Service Workers must be registered manually using navigator.serviceWorker.register()."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "106. Do czego służy metoda registerServiceWorker() w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "registerServiceWorker()", "code": true },
              {
                "text": " była używana w Create React App do rejestracji Service Workera. Metoda jest przestarzała i usunięta od CRA v4."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Obsługa trybu offline." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Szybsze ładowanie aplikacji." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Aktualizacja zasobów w tle." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Obecnie Service Worker należy rejestrować ręcznie przez navigator.serviceWorker.register()."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 107,
    "translations": {
      "uk": {
        "question": "107. Що таке синтетичні події (SyntheticEvent) у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "SyntheticEvent",
                "bold": true
              },
              {
                "text": " у React — це обгортка над нативними подіями браузера, яка уніфікує їх поведінку та API."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Кросбраузерна сумісність." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Нормалізований інтерфейс подій." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Оптимізація памʼяті через pooling (у старих версіях React)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "SyntheticEvent надає доступ до оригінальної події через "
              },
              {
                "text": "nativeEvent",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "107. What are SyntheticEvents in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "SyntheticEvent",
                "bold": true
              },
              {
                "text": " in React is a wrapper around native browser events that provides a consistent API."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Cross browser compatibility." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Normalized event interface." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Memory optimizations via event pooling in older React versions."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The original browser event is доступible via "
              },
              {
                "text": "nativeEvent",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "107. Czym są zdarzenia syntetyczne (SyntheticEvent) w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "SyntheticEvent",
                "bold": true
              },
              {
                "text": " w React to obudowa natywnych zdarzeń przeglądarki z ujednoliconym API."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Zgodność między przeglądarkami." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Ustandaryzowany interfejs zdarzeń." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Optymalizacja pamięci przez pooling w starszych wersjach React."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Dostęp do oryginalnego zdarzenia przez "
              },
              {
                "text": "nativeEvent",
                "code": true
              },
              {
                "text": "."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 108,
    "translations": {
      "uk": {
        "question": "108. Техніки оптимізації перфомансу React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Мемоізація", "bold": true },
                  {
                    "text": " — React.memo, useMemo, useCallback для зменшення ререндерів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Контроль ререндерів", "bold": true },
                  {
                    "text": " — правильне використання state, props і Context."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Віртуалізація списків", "bold": true },
                  { "text": " — react-window, react-virtualized." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Code splitting", "bold": true },
                  { "text": " — React.lazy та Suspense." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оптимізація ефектів", "bold": true },
                  {
                    "text": " — коректні залежності useEffect, useRef для mutable значень."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Робота з даними", "bold": true },
                  { "text": " — кешування, debounce/throttle для подій." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "108. React performance optimization techniques?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Memoization", "bold": true },
                  {
                    "text": " — React.memo, useMemo, useCallback to avoid re-renders."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Render control", "bold": true },
                  { "text": " — proper state, props, and Context usage." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "List virtualization", "bold": true },
                  { "text": " — react-window, react-virtualized." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Code splitting", "bold": true },
                  { "text": " — React.lazy and Suspense." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Effect optimization", "bold": true },
                  {
                    "text": " — correct useEffect dependencies, useRef for mutable values."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Data handling", "bold": true },
                  { "text": " — caching, debounce/throttle for events." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "108. Techniki optymalizacji wydajności React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Memoizacja", "bold": true },
                  {
                    "text": " — React.memo, useMemo, useCallback ograniczają renderowanie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontrola renderów", "bold": true },
                  { "text": " — poprawne użycie state, props i Context." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wirtualizacja list", "bold": true },
                  { "text": " — react-window, react-virtualized." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podział kodu", "bold": true },
                  { "text": " — React.lazy oraz Suspense." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optymalizacja efektów", "bold": true },
                  { "text": " — poprawne zależności useEffect, useRef." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Obsługa danych", "bold": true },
                  { "text": " — cache, debounce i throttle zdarzeń." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 109,
    "translations": {
      "uk": {
        "question": "109. Чи можливо використовувати async/await у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Так, "
              },
              {
                "text": "async/await",
                "code": true
              },
              {
                "text": " можна використовувати в React для асинхронних операцій."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Не можна використовувати "
                  },
                  {
                    "text": "async",
                    "code": true
                  },
                  {
                    "text": " безпосередньо в тілі компонента або в "
                  },
                  {
                    "text": "render",
                    "code": true
                  },
                  {
                    "text": "."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Можна використовувати в "
                  },
                  {
                    "text": "useEffect",
                    "code": true
                  },
                  {
                    "text": ", обробниках подій або окремих функціях."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Помилки потрібно обробляти через "
                  },
                  {
                    "text": "try/catch",
                    "code": true
                  },
                  {
                    "text": "."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "109. Is it possible to use async/await in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Yes, "
              },
              {
                "text": "async/await",
                "code": true
              },
              {
                "text": " can be used in React for asynchronous operations."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "It cannot be used directly inside component render logic."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "It is commonly used inside "
                  },
                  {
                    "text": "useEffect",
                    "code": true
                  },
                  {
                    "text": " or event handlers."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Errors should be handled with "
                  },
                  {
                    "text": "try/catch",
                    "code": true
                  },
                  {
                    "text": "."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "109. Czy można używać async/await w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tak, "
              },
              {
                "text": "async/await",
                "code": true
              },
              {
                "text": " można używać w React do operacji asynchronicznych."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Nie można używać bezpośrednio w renderowaniu komponentu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Najczęściej stosowane w "
                  },
                  {
                    "text": "useEffect",
                    "code": true
                  },
                  {
                    "text": " lub obsłudze zdarzeń."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Obsługa błędów przez "
                  },
                  {
                    "text": "try/catch",
                    "code": true
                  },
                  {
                    "text": "."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 110,
    "translations": {
      "uk": {
        "question": "110. Яка історія еволюції React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "2011", "bold": true },
                  {
                    "text": " — створення React у Facebook Джорданом Волке для внутрішніх продуктів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2013", "bold": true },
                  { "text": " — відкриття React як open source." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2015", "bold": true },
                  {
                    "text": " — React 0.14, поділ на React і ReactDOM, поява React Native."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2017", "bold": true },
                  {
                    "text": " — React 16 та архітектура Fiber, Error Boundaries, Portals."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2019", "bold": true },
                  { "text": " — React 16.8, офіційний реліз Hooks." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2020", "bold": true },
                  { "text": " — React 17, спрощення міграцій без змін API." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2022", "bold": true },
                  {
                    "text": " — React 18, Concurrent Rendering, useTransition."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2024", "bold": true },
                  {
                    "text": " — React 19, React Server Components, use(), React Compiler."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "110. What is the evolution history of React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "2011", "bold": true },
                  {
                    "text": " — React was created at Facebook by Jordan Walke."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2013", "bold": true },
                  { "text": " — React was released as open source." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2015", "bold": true },
                  {
                    "text": " — React 0.14, ReactDOM split, React Native introduced."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2017", "bold": true },
                  { "text": " — React 16 with Fiber architecture." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2019", "bold": true },
                  { "text": " — React 16.8, Hooks officially released." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2020", "bold": true },
                  { "text": " — React 17 focused on easier upgrades." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2022", "bold": true },
                  { "text": " — React 18 with Concurrent Rendering." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2024", "bold": true },
                  {
                    "text": " — React 19, Server Components, use(), React Compiler."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "110. Jaka jest historia ewolucji React?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "2011", "bold": true },
                  {
                    "text": " — React powstał w Facebooku, autor Jordan Walke."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2013", "bold": true },
                  { "text": " — React został udostępniony jako open source." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2015", "bold": true },
                  {
                    "text": " — React 0.14, podział na React i ReactDOM, React Native."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2017", "bold": true },
                  { "text": " — React 16 i architektura Fiber." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2019", "bold": true },
                  { "text": " — React 16.8, oficjalne wprowadzenie Hooks." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2020", "bold": true },
                  { "text": " — React 17, łatwiejsze aktualizacje." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2022", "bold": true },
                  { "text": " — React 18, Concurrent Rendering." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "2024", "bold": true },
                  {
                    "text": " — React 19, Server Components, use(), React Compiler."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 111,
    "translations": {
      "uk": {
        "question": "111. Які нововведення було додано в React 19?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React Compiler", "bold": true },
                  {
                    "text": " — автоматична оптимізація ререндерів без ручного memo."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Хук use()", "bold": true },
                  {
                    "text": " — спрощена робота з асинхронними даними та Server Components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Actions API", "bold": true },
                  {
                    "text": " — уніфікований підхід до мутацій і серверних дій."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Покращений Suspense", "bold": true },
                  {
                    "text": " — кращий контроль асинхронного рендерингу та гідратації."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Нативна робота з метатегами", "bold": true },
                  { "text": " — title, meta, link без сторонніх бібліотек." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "111. What new features were introduced in React 19?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React Compiler", "bold": true },
                  {
                    "text": " — automatic render optimization without manual memoization."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "use() hook", "bold": true },
                  {
                    "text": " — simplified async data handling and Server Components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Actions API", "bold": true },
                  {
                    "text": " — unified model for mutations and server actions."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Improved Suspense", "bold": true },
                  { "text": " — better async rendering and hydration control." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Native metadata handling", "bold": true },
                  { "text": " — title, meta, link without extra libraries." }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "111. Jakie nowości wprowadzono w React 19?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "React Compiler", "bold": true },
                  { "text": " — automatyczna optymalizacja renderowania." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hook use()", "bold": true },
                  {
                    "text": " — prostsza obsługa danych asynchronicznych i Server Components."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Actions API", "bold": true },
                  { "text": " — jednolity model mutacji i akcji serwerowych." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ulepszony Suspense", "bold": true },
                  {
                    "text": " — lepsza kontrola renderowania asynchronicznego."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Natywna obsługa metadanych", "bold": true },
                  { "text": " — title, meta, link bez dodatkowych bibliotek." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 112,
    "translations": {
      "uk": {
        "question": "112. Що рекомендують використовувати розробники React після того як Create React App став deprecated?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Next.js", "bold": true },
                  {
                    "text": " — рекомендований за замовчуванням фреймворк з SSR, SSG, RSC та сучасним tooling."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Vite + React", "bold": true },
                  {
                    "text": " — легка альтернатива для SPA з швидким дев-сервером і мінімальною конфігурацією."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Router + Vite", "bold": true },
                  {
                    "text": " — для клієнтських SPA без серверного рендерингу."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Expo", "bold": true },
                  {
                    "text": " — для React Native та кросплатформеної розробки."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "112. What do React developers recommend after Create React App became deprecated?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Next.js", "bold": true },
                  {
                    "text": " — the default recommended framework with SSR, SSG, RSC, and modern tooling."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Vite + React", "bold": true },
                  {
                    "text": " — a lightweight SPA setup with fast dev server and minimal config."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Router + Vite", "bold": true },
                  {
                    "text": " — for client side SPAs without server rendering."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Expo", "bold": true },
                  {
                    "text": " — for React Native and cross platform development."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "112. Co zalecają twórcy React po tym, jak Create React App został wycofany?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Next.js", "bold": true },
                  {
                    "text": " — domyślnie rekomendowany framework z SSR, SSG i RSC."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Vite + React", "bold": true },
                  {
                    "text": " — lekka konfiguracja SPA z szybkim środowiskiem developerskim."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "React Router + Vite", "bold": true },
                  {
                    "text": " — do aplikacji SPA bez renderowania po stronie serwera."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Expo", "bold": true },
                  {
                    "text": " — do React Native i aplikacji wieloplatformowych."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "react",
    "order": 113,
    "translations": {
      "uk": {
        "question": "113. Як працює хук useDeferredValue у React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "useDeferredValue",
                "code": true
              },
              {
                "text": " дозволяє відкладати оновлення значення з нижчим пріоритетом, щоб зберегти чуйність інтерфейсу."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Термінові оновлення виконуються одразу." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Важкі обчислення виконуються пізніше." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Проміжні значення можуть бути пропущені." }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "113. How does the useDeferredValue hook work in React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "useDeferredValue",
                "code": true
              },
              {
                "text": " delays low priority value updates to keep the UI responsive."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Urgent updates run immediately." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Expensive updates are deferred." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Intermediate values may be skipped." }]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "113. Jak działa hook useDeferredValue w React?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "useDeferredValue",
                "code": true
              },
              {
                "text": " opóźnia aktualizacje o niskim priorytecie, zachowując płynność interfejsu."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Pilne aktualizacje wykonywane są natychmiast." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Kosztowne obliczenia są odkładane." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wartości pośrednie mogą być pomijane." }
                ]
              }
            ]
          }
        ]
      }
    }
  }
]
