[
  {
    "category": "git",
    "order": 1,
    "translations": {
      "uk": {
        "question": "1. Що таке Git і яка його роль у розробці програмного забезпечення?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git", "bold": true },
              {
                "text": " - розподілена система контролю версій (VCS) для відстеження змін у коді."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використання:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Зберігання історії змін у проєкті." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Паралельна розробка в гілках (branches)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Об’єднання змін через merge або rebase." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відновлення попередніх версій файлів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Спільна робота команд над кодом через сервіси (GitHub, GitLab, Bitbucket)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git дозволяє безпечно керувати кодом, відстежувати зміни та ефективно співпрацювати."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "1. What is Git and what role does it play in software development?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git", "bold": true },
              {
                "text": " is a distributed version control system (VCS) used to track changes in source code."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usage:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Storing the history of changes in a project." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Parallel development using branches." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Merging changes via merge or rebase." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Restoring previous versions of files." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Team collaboration through services like GitHub, GitLab, and Bitbucket."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git enables safe code management, change tracking, and efficient collaboration."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "1. Czym jest Git i jaką rolę odgrywa w tworzeniu oprogramowania?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git", "bold": true },
              {
                "text": " to rozproszony system kontroli wersji (VCS) służący do śledzenia zmian w kodzie."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zastosowanie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Przechowywanie historii zmian w projekcie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Równoległa praca w gałęziach (branches)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Łączenie zmian za pomocą merge lub rebase." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przywracanie wcześniejszych wersji plików." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Praca zespołowa nad kodem przez serwisy (GitHub, GitLab, Bitbucket)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git umożliwia bezpieczne zarządzanie kodem, śledzenie zmian i efektywną współpracę."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 2,
    "translations": {
      "uk": {
        "question": "2. Чим Git відрізняється від інших систем контролю версій, наприклад, SVN або Mercurial?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Розподіленість:", "bold": true },
                  {
                    "text": " у Git кожен клон репозиторію містить повну історію, на відміну від централізованих VCS (SVN)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Швидкість:", "bold": true },
                  {
                    "text": " локальні операції (commit, diff, log) виконуються дуже швидко."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Гнучке керування гілками:", "bold": true },
                  {
                    "text": " lightweight branches і швидке злиття (merge/rebase)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зберігання змін:", "bold": true },
                  {
                    "text": " Git зберігає снімки (snapshots) файлів, а не лише дельти, як у SVN."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Широка інтеграція:", "bold": true },
                  {
                    "text": " популярність Git забезпечує підтримку в CI/CD, GitHub, GitLab та IDE."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Безпека:", "bold": true },
                  {
                    "text": " SHA-1 хешування гарантує цілісність історії."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git ідеально підходить для сучасних командних workflow та open-source проєктів завдяки швидкості, гнучкості та надійності."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "2. How does Git differ from other version control systems like SVN or Mercurial?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Distributed nature:", "bold": true },
                  {
                    "text": " each Git clone contains the full repository history, unlike centralized VCSs such as SVN."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Speed:", "bold": true },
                  {
                    "text": " local operations (commit, diff, log) are very fast."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Flexible branching:", "bold": true },
                  {
                    "text": " lightweight branches and fast merging (merge/rebase)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Data storage:", "bold": true },
                  {
                    "text": " Git stores snapshots of files instead of deltas like SVN."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wide integration:", "bold": true },
                  {
                    "text": " Git is widely supported by CI/CD tools, GitHub, GitLab, and IDEs."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Security:", "bold": true },
                  {
                    "text": " SHA-1 hashing ensures the integrity of the history."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git is ideal for modern team workflows and open-source projects due to its speed, flexibility, and reliability."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "2. Czym Git różni się od innych systemów kontroli wersji, takich jak SVN lub Mercurial?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Rozproszona architektura:", "bold": true },
                  {
                    "text": " każdy klon repozytorium Git zawiera pełną historię, w przeciwieństwie do scentralizowanych VCS (SVN)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Szybkość:", "bold": true },
                  {
                    "text": " operacje lokalne (commit, diff, log) są bardzo szybkie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Elastyczne zarządzanie gałęziami:",
                    "bold": true
                  },
                  {
                    "text": " lekkie gałęzie (branches) i szybkie scalanie (merge/rebase)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przechowywanie danych:", "bold": true },
                  {
                    "text": " Git przechowuje migawki (snapshots) plików, a nie tylko różnice jak SVN."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Szeroka integracja:", "bold": true },
                  {
                    "text": " popularność Git zapewnia wsparcie w CI/CD, GitHub, GitLab oraz IDE."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Bezpieczeństwo:", "bold": true },
                  {
                    "text": " haszowanie SHA-1 gwarantuje integralność historii."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git doskonale sprawdza się w nowoczesnych workflow zespołowych i projektach open-source dzięki szybkości, elastyczności i niezawodności."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 3,
    "translations": {
      "uk": {
        "question": "3. У чому відмінність між Git і GitHub?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git", "bold": true },
                  {
                    "text": " - система контролю версій (VCS) для відстеження змін у коді локально або на будь-якому сервері."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub", "bold": true },
                  {
                    "text": " - онлайн-сервіс для хостингу Git-репозиторіїв із веб-інтерфейсом, командною роботою та додатковими можливостями: pull requests, issues, CI/CD інтеграції."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коротко:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git - інструмент для роботи з версіями коду, GitHub - платформа для хостингу та командної співпраці."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git можна використовувати без GitHub, але GitHub без Git використати неможливо."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "3. What is the difference between Git and GitHub?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git", "bold": true },
                  {
                    "text": " is a version control system (VCS) used to track changes in code locally or on any server."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub", "bold": true },
                  {
                    "text": " is an online platform for hosting Git repositories with a web interface, team collaboration, and additional features such as pull requests, issues, and CI/CD integrations."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In short:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git is a tool for version control, while GitHub is a platform for hosting and collaborating on Git repositories."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You can use Git without GitHub, but you cannot use GitHub without Git."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "3. Jaka jest różnica między Git a GitHub?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git", "bold": true },
                  {
                    "text": " to system kontroli wersji (VCS) służący do śledzenia zmian w kodzie lokalnie lub na dowolnym serwerze."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub", "bold": true },
                  {
                    "text": " to internetowa platforma do hostowania repozytoriów Git z interfejsem webowym, pracą zespołową oraz dodatkowymi funkcjami: pull requests, issues, integracje CI/CD."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W skrócie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git to narzędzie do kontroli wersji, a GitHub to platforma do hostingu i współpracy zespołowej."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git można używać bez GitHub, ale GitHub nie działa bez Git."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 4,
    "translations": {
      "uk": {
        "question": "4. Що таке репозиторій у Git і яка його роль?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Репозиторій (repository, repo)", "bold": true },
              {
                "text": " - це місце зберігання всього коду проєкту та повної історії змін."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Файли проєкту (код, документацію, конфігурації)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Історію комітів із повідомленнями та авторами."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Гілки (branches) для паралельної розробки." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Репозиторій може бути локальним (на вашому комп’ютері) або віддаленим (GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Він дозволяє відстежувати зміни, працювати командою та повертатися до попередніх версій коду."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "4. What is a repository in Git and what is its role?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A repository (repo)", "bold": true },
              {
                "text": " is a storage location that contains the entire project code and its full change history."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Contains:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Project files (source code, documentation, configuration)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit history with messages and authors." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Branches for parallel development." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A repository can be local (on your computer) or remote (GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It allows you to track changes, collaborate with a team, and restore previous versions of the code."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "4. Czym jest repozytorium w Git i jaka jest jego rola?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Repozytorium (repository, repo)", "bold": true },
              {
                "text": " to miejsce przechowywania całego kodu projektu oraz pełnej historii zmian."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Pliki projektu (kod źródłowy, dokumentację, konfigurację)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Historię commitów z autorami i opisami." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Gałęzie (branches) do równoległej pracy." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Repozytorium może być lokalne (na komputerze) lub zdalne (GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Umożliwia śledzenie zmian, pracę zespołową oraz powrót do wcześniejszych wersji kodu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 5,
    "translations": {
      "uk": {
        "question": "5. Що таке commit у Git і для чого він використовується?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Commit", "bold": true },
              {
                "text": " - це збереження знімка змін у репозиторії разом із повідомленням."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Історію змін файлів (added, modified, deleted)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Авторство та дату зміни." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Унікальний SHA-1 хеш для ідентифікації." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Відстеження прогресу проєкту." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Повернення до попередніх станів (git checkout, git revert)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Координації роботи в команді через pull/merge."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад коміту:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add index.html\n\ngit commit -m \"feat(html): Додаю базову структуру сторінки\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Коміти формують історію проєкту, яку можна аналізувати, відновлювати і об’єднувати."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "5. What is a commit in Git and what is it used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A commit", "bold": true },
              {
                "text": " is a snapshot of changes saved in the repository along with a message."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Contains:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A history of file changes (added, modified, deleted)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Author information and timestamp." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "A unique SHA-1 hash for identification." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Used for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Tracking project progress." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Returning to previous states (git checkout, git revert)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Coordinating team work via pull/merge." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Commit example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add index.html\n\ngit commit -m \"feat(html): Add basic page structure\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Commits form the project history, which can be analyzed, restored, and merged."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "5. Czym jest commit w Git i do czego służy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Commit", "bold": true },
              {
                "text": " to zapis migawki zmian w repozytorium wraz z komunikatem."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Historię zmian plików (added, modified, deleted)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Informacje o autorze i dacie." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Unikalny hash SHA-1 do identyfikacji." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Służy do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Śledzenia postępu projektu." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Powrotu do wcześniejszych stanów (git checkout, git revert)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Koordynacji pracy zespołu poprzez pull/merge."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład commita:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add index.html\n\ngit commit -m \"feat(html): Dodanie podstawowej struktury strony\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Commity tworzą historię projektu, którą można analizować, przywracać i scalać."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 6,
    "translations": {
      "uk": {
        "question": "6. Яка різниця між working directory, staging area/index і repository у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Робочий каталог (Working Directory)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Файли на диску, які ви безпосередньо редагуєте."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Містить останню версію з Git + незакомічені зміни."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Проміжна область (Staging Area / Index)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Тимчасова зона для підготовки змін до коміту."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Дозволяє обрати, які саме зміни потраплять у наступний коміт."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Команда: git add " },
                          { "text": "<file>", "code": true },
                          { "text": " додає зміни до стейджу." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Локальний репозиторій (Repository)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Збережена історія комітів у папці .git."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Містить коміти, гілки, теги та SHA-1 хеші."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Команда: git commit переносить зміни зі стейджу в репозиторій."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Схематично:" }]
          },
          {
            "type": "code",
            "language": "text",
            "content": "Working Directory -> git add -> Staging Area -> git commit -> Repository"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ця модель дозволяє гнучко контролювати, які зміни зберігати, та підтримувати чисту історію комітів."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "6. What is the difference between the working directory, the staging area (index), and the repository in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Working Directory", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Files on disk that you actively edit."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Contains the latest version from Git plus uncommitted changes."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Staging Area (Index)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "A temporary area to prepare changes for a commit."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Allows you to select which changes will be included in the next commit."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Command: git add " },
                          { "text": "<file>", "code": true },
                          { "text": " adds changes to the staging area." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Repository", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Stored commit history inside the .git directory."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Contains commits, branches, tags, and SHA-1 hashes."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Command: git commit moves changes from staging to the repository."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Diagram:" }]
          },
          {
            "type": "code",
            "language": "text",
            "content": "Working Directory -> git add -> Staging Area -> git commit -> Repository"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This model provides fine-grained control over what gets committed and helps maintain a clean commit history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "6. Jaka jest różnica między katalogiem roboczym (working directory), obszarem staging (index) a repozytorium w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Katalog roboczy (Working Directory)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Pliki na dysku, które aktualnie edytujesz."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zawiera ostatnią wersję z Git oraz niezacommitowane zmiany."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Obszar staging (Index)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Tymczasowe miejsce do przygotowania zmian do commita."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Pozwala wybrać, które zmiany trafią do następnego commita."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Polecenie: git add " },
                          { "text": "<file>", "code": true },
                          { "text": " dodaje zmiany do stagingu." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Repozytorium (Repository)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zapisana historia commitów w katalogu .git."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zawiera commity, gałęzie, tagi oraz hashe SHA-1."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Polecenie: git commit przenosi zmiany ze stagingu do repozytorium."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Schemat:" }]
          },
          {
            "type": "code",
            "language": "text",
            "content": "Working Directory -> git add -> Staging Area -> git commit -> Repository"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ten model pozwala precyzyjnie kontrolować zapisywane zmiany i utrzymywać czystą historię commitów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 7,
    "translations": {
      "uk": {
        "question": "7. Що таке розгалуження (branching) у Git і чому воно важливе?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Розгалуження (branch)", "bold": true },
              {
                "text": " - це окрема лінія розробки в репозиторії, яка дозволяє працювати над новими функціями, виправленнями або експериментами, не впливаючи на основну гілку (main/master)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Важливість:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Паралельна робота кількох розробників." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Безпечне тестування нових функцій." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Проста інтеграція змін через merge або rebase."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Чистіша історія комітів і кращий контроль змін."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад створення та перемикання гілки:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch feature-login\n\ngit checkout feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Розгалуження є основою сучасних workflow (Git Flow, GitHub Flow) для командної розробки."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "7. What is branching in Git and why is it important?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Branching", "bold": true },
              {
                "text": " is a separate line of development in a repository that allows you to work on new features, fixes, or experiments without affecting the main branch (main/master)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Why it matters:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Parallel work by multiple developers." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Safe testing of new features." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Easy integration of changes via merge or rebase."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Cleaner commit history and better change control."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Example of creating and switching a branch:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch feature-login\n\ngit checkout feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Branching is the foundation of modern workflows such as Git Flow and GitHub Flow for team development."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "7. Czym jest branching (rozgałęzianie) w Git i dlaczego jest ważne?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Branching (gałąź)", "bold": true },
              {
                "text": " to oddzielna linia rozwoju w repozytorium, która pozwala pracować nad nowymi funkcjami, poprawkami lub eksperymentami bez wpływu na główną gałąź (main/master)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dlaczego jest ważne:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Równoległa praca wielu programistów." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Bezpieczne testowanie nowych funkcji." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Łatwa integracja zmian przez merge lub rebase."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Czystsza historia commitów i lepsza kontrola zmian."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Przykład tworzenia i przełączania gałęzi:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch feature-login\n\ngit checkout feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rozgałęzianie jest podstawą nowoczesnych workflow, takich jak Git Flow i GitHub Flow, w pracy zespołowej."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 8,
    "translations": {
      "uk": {
        "question": "8. Що таке HEAD у Git і яка його роль?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "HEAD", "bold": true },
              {
                "text": " - це поточний вказівник на коміт, з яким ви зараз працюєте."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Зазвичай HEAD вказує на гілку, а гілка - на останній коміт."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Визначення поточного місця в історії комітів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перемикання між гілками (git checkout " },
                  { "text": "<branch>", "code": true },
                  { "text": ") або комітами (git checkout " },
                  { "text": "<commit>", "code": true },
                  { "text": ")." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Можливі стани HEAD:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Normal", "bold": true },
                  { "text": " - HEAD вказує на гілку." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Detached HEAD", "bold": true },
                  {
                    "text": " - HEAD тимчасово вказує на конкретний коміт, а не на гілку."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature-login\n\n# HEAD тепер вказує на гілку feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "HEAD - ключовий концепт для навігації історією Git та управління комітами."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "8. What is HEAD in Git and what is its role?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "HEAD", "bold": true },
              {
                "text": " is a pointer to the commit you are currently working on."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Usually, HEAD points to a branch, and the branch points to the latest commit."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Used for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Identifying your current position in the commit history."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Switching branches (git checkout " },
                  { "text": "<branch>", "code": true },
                  { "text": ") or commits (git checkout " },
                  { "text": "<commit>", "code": true },
                  { "text": ")." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Possible HEAD states:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Normal", "bold": true },
                  { "text": " - HEAD points to a branch." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Detached HEAD", "bold": true },
                  {
                    "text": " - HEAD temporarily points to a specific commit, not a branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature-login\n\n# HEAD now points to the feature-login branch"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "HEAD is a key concept for navigating Git history and managing commits."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "8. Czym jest HEAD w Git i jaka jest jego rola?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "HEAD", "bold": true },
              {
                "text": " to wskaźnik na commit, nad którym aktualnie pracujesz."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zazwyczaj HEAD wskazuje na gałąź, a gałąź na ostatni commit."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Służy do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Określania bieżącej pozycji w historii commitów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przełączania gałęzi (git checkout " },
                  { "text": "<branch>", "code": true },
                  { "text": ") lub commitów (git checkout " },
                  { "text": "<commit>", "code": true },
                  { "text": ")." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Możliwe stany HEAD:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Normal", "bold": true },
                  { "text": " - HEAD wskazuje na gałąź." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Detached HEAD", "bold": true },
                  {
                    "text": " - HEAD tymczasowo wskazuje na konkretny commit, a nie na gałąź."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature-login\n\n# HEAD wskazuje teraz na gałąź feature-login"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "HEAD to kluczowe pojęcie do nawigacji po historii Git i zarządzania commitami."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 9,
    "translations": {
      "uk": {
        "question": "9. Що таке операція clone у Git і для чого вона використовується?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clone", "code": true },
              {
                "text": " - створює повну копію віддаленого репозиторію на вашому локальному комп’ютері."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Копія містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Усі файли проєкту." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Повну історію комітів." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Усі гілки та теги." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Початку роботи над існуючим проєктом." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Спільної роботи команди через GitHub, GitLab або інші сервери."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone https://github.com/user/repo.git"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Результат:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Локальний репозиторій, готовий до комітів, створення гілок і синхронізації з віддаленим сервером."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "9. What is the clone operation in Git and what is it used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clone", "code": true },
              {
                "text": " creates a full copy of a remote repository on your local machine."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "The copy includes:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "All project files." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "The complete commit history." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "All branches and tags." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Used for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Starting work on an existing project." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Team collaboration via GitHub, GitLab, or other servers."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone https://github.com/user/repo.git"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Result:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A local repository ready for commits, branching, and synchronization with the remote server."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "9. Czym jest operacja clone w Git i do czego służy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clone", "code": true },
              {
                "text": " tworzy pełną kopię zdalnego repozytorium na lokalnym komputerze."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kopia zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Wszystkie pliki projektu." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Pełną historię commitów." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Wszystkie gałęzie i tagi." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Służy do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Rozpoczęcia pracy nad istniejącym projektem." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Współpracy zespołowej przez GitHub, GitLab lub inne serwery."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone https://github.com/user/repo.git"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Rezultat:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Lokalne repozytorium gotowe do commitów, tworzenia gałęzi i synchronizacji ze zdalnym serwerem."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 10,
    "translations": {
      "uk": {
        "question": "10. Як Git зберігає дані про проєкт і його історію змін?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git зберігає дані у вигляді знімків (snapshots), а не просто дельт файлів."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Кожен коміт містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Посилання на попередній коміт." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Знімок дерева файлів проєкту." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Інформацію про автора та повідомлення коміту."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні типи об’єктів Git:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Blob", "code": true },
                  { "text": " - вміст файлів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tree", "code": true },
                  { "text": " - структура каталогів і файлів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit", "code": true },
                  { "text": " - вказує на tree та попередній коміт." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Папка " },
              { "text": ".git", "code": true },
              {
                "text": " містить усі об’єкти та метадані, що дозволяє повністю відтворити історію проєкту."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Така модель робить Git швидким, надійним і ефективним для роботи з гілками та злиттями."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "10. How does Git store project data and its change history?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git stores data as snapshots rather than simple file deltas."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Each commit contains:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "A reference to the previous commit." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "A snapshot of the project file tree." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Author information and commit message." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Core Git object types:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Blob", "code": true },
                  { "text": " - file contents." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tree", "code": true },
                  { "text": " - directory and file structure." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit", "code": true },
                  { "text": " - points to a tree and the previous commit." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": ".git", "code": true },
              {
                "text": " directory contains all objects and metadata needed to fully reconstruct the project history."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This model makes Git fast, reliable, and efficient for branching and merging."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "10. W jaki sposób Git przechowuje dane projektu i historię zmian?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git przechowuje dane w postaci migawek (snapshots), a nie tylko różnic plików."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Każdy commit zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Odniesienie do poprzedniego commita." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Migawkę drzewa plików projektu." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Informacje o autorze i komunikat commita." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Podstawowe typy obiektów Git:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Blob", "code": true },
                  { "text": " - zawartość plików." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tree", "code": true },
                  { "text": " - struktura katalogów i plików." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit", "code": true },
                  { "text": " - wskazuje na tree i poprzedni commit." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Katalog " },
              { "text": ".git", "code": true },
              {
                "text": " zawiera wszystkie obiekty i metadane, umożliwiając pełne odtworzenie historii projektu."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Taki model sprawia, że Git jest szybki, niezawodny i wydajny przy pracy z gałęziami i scalaniem."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 11,
    "translations": {
      "uk": {
        "question": "11. Як ініціалізувати новий репозиторій Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використати команду:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git init"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ця команда створює приховану папку .git у поточному каталозі, де зберігається історія комітів, гілки та конфігурація репозиторію."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Далі потрібно додати файли та створити перший коміт:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add .\n\ngit commit -m \"Initial commit\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Після виконання git init каталог стає повноцінним Git-репозиторієм."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "11. How do you initialize a new Git repository?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Use the command:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git init"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This command creates a hidden .git directory in the current folder, which stores the commit history, branches, and repository configuration."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Next, add files and create the first commit:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add .\n\ngit commit -m \"Initial commit\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "After running git init, the directory becomes a fully functional Git repository."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "11. Jak zainicjalizować nowe repozytorium Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Użyj polecenia:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git init"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie to tworzy ukryty katalog .git w bieżącym folderze, w którym przechowywana jest historia commitów, gałęzie oraz konfiguracja repozytorium."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Następnie należy dodać pliki i utworzyć pierwszy commit:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add .\n\ngit commit -m \"Initial commit\""
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Po wykonaniu git init katalog staje się pełnoprawnym repozytorium Git."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 12,
    "translations": {
      "uk": {
        "question": "12. Для чого використовується команда git status?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Показує поточний стан робочого каталогу та індексу (staging area)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Інформує про:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Які файли змінені, але ще не додані." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Які файли вже в індексі та підуть у наступний коміт."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Які файли не відслідковуються." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Поточну гілку та її відставання або випередження відносно віддаленого репозиторію."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git status"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Команда допомагає зрозуміти, що саме буде закомічено, а які зміни ще потребують виконання git add."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "12. What is the git status command used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Displays the current state of the working directory and the staging area (index)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "It informs you about:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Files that have been modified but not yet staged."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Files that are staged and will be included in the next commit."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Files that are untracked." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The current branch and whether it is ahead of or behind the remote branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git status"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It helps you understand what will be committed and which changes still need to be added using git add."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "12. Do czego służy polecenie git status?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wyświetla aktualny stan katalogu roboczego oraz obszaru staging (index)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Informuje o:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Plikach zmodyfikowanych, ale jeszcze nie dodanych do stagingu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Plikach znajdujących się w stagingu, które trafią do następnego commita."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Plikach nieśledzonych (untracked)." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Aktualnej gałęzi oraz jej wyprzedzeniu lub opóźnieniu względem repozytorium zdalnego."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git status"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie pozwala zrozumieć, co zostanie zapisane w commicie, a które zmiany wymagają jeszcze użycia git add."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 13,
    "translations": {
      "uk": {
        "question": "13. Яке призначення команди git add?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git add", "code": true },
                  {
                    "text": " додає зміни з робочого каталогу у staging area (індекс)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Це підготовчий етап перед комітом." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Можна додавати окремі файли або всі зміни." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add file.txt     # додає конкретний файл\ngit add .            # додає всі зміни в поточному каталозі\ngit add -p           # додає зміни частинами (interactive)"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Команда " },
              { "text": "git add", "code": true },
              {
                "text": " не зберігає зміни в історії - вона лише позначає їх для наступного "
              },
              { "text": "git commit", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "en": {
        "question": "13. What is the purpose of the git add command?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git add", "code": true },
                  {
                    "text": " adds changes from the working directory to the staging area (index)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "It is a preparation step before committing." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You can add individual files or all changes at once."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add file.txt     # adds a specific file\ngit add .            # adds all changes in the current directory\ngit add -p           # adds changes interactively"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": "git add", "code": true },
              {
                "text": " command does not save changes to history - it only marks them for the next "
              },
              { "text": "git commit", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "pl": {
        "question": "13. Jakie jest przeznaczenie polecenia git add?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git add", "code": true },
                  {
                    "text": " dodaje zmiany z katalogu roboczego do obszaru staging (index)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jest to etap przygotowawczy przed wykonaniem commita."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Można dodawać pojedyncze pliki lub wszystkie zmiany naraz."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git add file.txt     # dodaje konkretny plik\ngit add .            # dodaje wszystkie zmiany w bieżącym katalogu\ngit add -p           # dodaje zmiany interaktywnie"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Polecenie " },
              { "text": "git add", "code": true },
              {
                "text": " nie zapisuje zmian w historii - jedynie oznacza je do następnego "
              },
              { "text": "git commit", "code": true },
              { "text": "." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 14,
    "translations": {
      "uk": {
        "question": "14. Яким чином створюється новий коміт у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Спочатку додати зміни у staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add ."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Потім створити коміт:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -m \"Опис змін\""
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Ключ ", "children": [] },
                  { "text": "-m", "code": true },
                  { "text": " додає повідомлення коміту." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо параметр не вказати, відкриється текстовий редактор для введення повідомлення."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Коміт зберігає знімок (snapshot) поточного стану індексу в історії репозиторію."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Рекомендується писати короткі та зрозумілі повідомлення комітів, щоб легко відстежувати зміни."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "14. How is a new commit created in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "First, add changes to the staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add ."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Then create the commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -m \"Describe changes\""
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "The ", "children": [] },
                  { "text": "-m", "code": true },
                  { "text": " flag adds a commit message." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If it is not provided, a text editor will open to enter the message."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A commit saves a snapshot of the current staging area state into the repository history."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It is recommended to write short and clear commit messages to easily track changes."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "14. W jaki sposób tworzy się nowy commit w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Najpierw dodaj zmiany do obszaru staging:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add ."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Następnie utwórz commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -m \"Opis zmian\""
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Opcja ", "children": [] },
                  { "text": "-m", "code": true },
                  { "text": " dodaje komunikat commita." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli nie zostanie podana, otworzy się edytor tekstu do wpisania komunikatu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Commit zapisuje migawkę (snapshot) aktualnego stanu stagingu w historii repozytorium."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zaleca się pisanie krótkich i zrozumiałych komunikatów commitów, aby łatwo śledzić zmiany."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 15,
    "translations": {
      "uk": {
        "question": "15. Які дані зберігає об’єкт коміту в Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Об’єкт коміту містить:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Хеш (SHA-1/SHA-256) - унікальний ідентифікатор."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Посилання на tree-об’єкт (структура файлів і папок на момент коміту)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Посилання на parent-коміти (зв’язок в історії; у merge їх може бути кілька)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Автор (ім’я, email, час створення)." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Комітер (той, хто зафіксував зміни; може відрізнятися від автора)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Commit message (опис змін)." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Таким чином Git зберігає не окремі файли, а знімки стану разом із метаданими, що дозволяє легко відновлювати та порівнювати історію."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "15. What data does a commit object store in Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "A commit object contains:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A hash (SHA-1/SHA-256) - a unique identifier."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A reference to a tree object (the file and directory structure at the time of the commit)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "References to parent commits (history linkage; there can be multiple parents in a merge)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Author information (name, email, creation time)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Committer information (the person who recorded the commit; may differ from the author)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit message (description of changes)." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "As a result, Git stores snapshots of the project state along with metadata, which makes it easy to restore and compare history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "15. Jakie dane przechowuje obiekt commita w Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Obiekt commita zawiera:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Hash (SHA-1/SHA-256) - unikalny identyfikator."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Odwołanie do obiektu tree (struktura plików i katalogów w momencie commita)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Odwołania do commitów nadrzędnych (powiązania w historii; przy merge może być ich kilka)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Autor (imię, email, czas utworzenia)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Committer (osoba zapisująca commit; może różnić się od autora)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Commit message (opis zmian)." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Dzięki temu Git przechowuje migawki stanu projektu wraz z metadanymi, co ułatwia odtwarzanie i porównywanie historii."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 16,
    "translations": {
      "uk": {
        "question": "16. Яка різниця між командами git push і git fetch?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git push", "code": true },
                  {
                    "text": " - відправляє локальні коміти у віддалений репозиторій (оновлює remote-гілку)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "text": " - отримує нові дані з віддаленого репозиторію, але не зливає їх у локальну гілку (оновлює лише refs/remotes)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Тобто:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "push", "code": true },
                  { "text": " - викласти свої зміни." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "fetch", "code": true },
                  {
                    "text": " - завантажити чужі зміни для перегляду або подальшого злиття."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "16. What is the difference between git push and git fetch?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git push", "code": true },
                  {
                    "text": " sends local commits to the remote repository (updates the remote branch)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "text": " retrieves new data from the remote repository but does not merge it into the local branch (updates refs/remotes only)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In short:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "push", "code": true },
                  { "text": " = publish your changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "fetch", "code": true },
                  {
                    "text": " = download others’ changes for review or later merging."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "16. Jaka jest różnica między poleceniami git push i git fetch?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git push", "code": true },
                  {
                    "text": " wysyła lokalne commity do zdalnego repozytorium (aktualizuje gałąź zdalną)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "text": " pobiera nowe dane ze zdalnego repozytorium, ale nie scala ich z lokalną gałęzią (aktualizuje tylko refs/remotes)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Czyli:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "push", "code": true },
                  { "text": " = publikacja własnych zmian." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "fetch", "code": true },
                  {
                    "text": " = pobranie cudzych zmian do wglądu lub późniejszego scalenia."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 17,
    "translations": {
      "uk": {
        "question": "17. Яке призначення команди git pull?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  { "text": " = " },
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " (або " },
                  { "text": "rebase", "code": true },
                  { "text": ", якщо вказано відповідну опцію)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Команда завантажує останні зміни з віддаленого репозиторію та одразу інтегрує їх у поточну гілку."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Використовується для синхронізації локальної гілки з віддаленою (remote)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git pull origin main"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Команда отримає оновлення з origin/main і зіллє їх у вашу локальну гілку main."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Якщо потрібен лише перегляд змін без злиття, краще використовувати git fetch."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "17. What is the purpose of the git pull command?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  { "text": " = " },
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " (or " },
                  { "text": "rebase", "code": true },
                  { "text": " if the option is specified)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "It downloads the latest changes from the remote repository and immediately integrates them into the current branch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Used to synchronize the local branch with the remote one."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git pull origin main"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This command fetches updates from origin/main and merges them into your local main branch."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "If you only want to review changes without merging, it is better to use git fetch."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "17. Jakie jest przeznaczenie polecenia git pull?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  { "text": " = " },
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " (lub " },
                  { "text": "rebase", "code": true },
                  { "text": ", jeśli użyto odpowiedniej opcji)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Polecenie pobiera najnowsze zmiany ze zdalnego repozytorium i od razu scala je z bieżącą gałęzią."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Służy do synchronizacji lokalnej gałęzi ze zdalną (remote)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git pull origin main"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie pobierze aktualizacje z origin/main i scali je z lokalną gałęzią main."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jeśli chcesz jedynie przejrzeć zmiany bez scalania, lepiej użyć git fetch."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 18,
    "translations": {
      "uk": {
        "question": "18. Яке призначення та варіанти використання команди git branch?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " керує гілками в репозиторії. Основні сценарії:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд усіх гілок:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Створення нової гілки:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch feature/login"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Видалення гілки (локально):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -d feature/login   # безпечне (якщо змерджено)\ngit branch -D feature/login   # примусове"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перейменування гілки:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -m old-name new-name"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд віддалених гілок:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -r"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Важливо:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " не перемикає гілки, а лише створює та керує ними. Для перемикання використовується "
              },
              { "text": "git checkout", "code": true },
              { "text": " або " },
              { "text": "git switch", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "en": {
        "question": "18. What is the purpose and usage of the git branch command?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " is used to manage branches in a repository. Common use cases:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "List all branches:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Create a new branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch feature/login"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Delete a branch (locally):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -d feature/login   # safe (if merged)\ngit branch -D feature/login   # force delete"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Rename a branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -m old-name new-name"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "View remote branches:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -r"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Important:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " does not switch branches - it only creates and manages them. To switch branches, use "
              },
              { "text": "git checkout", "code": true },
              { "text": " or " },
              { "text": "git switch", "code": true },
              { "text": "." }
            ]
          }
        ]
      },
      "pl": {
        "question": "18. Jakie jest przeznaczenie i sposoby użycia polecenia git branch?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " służy do zarządzania gałęziami w repozytorium. Główne scenariusze:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wyświetlenie wszystkich gałęzi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Utworzenie nowej gałęzi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch feature/login"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Usunięcie gałęzi (lokalnie):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -d feature/login   # bezpieczne (jeśli scalona)\ngit branch -D feature/login   # wymuszone"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zmiana nazwy gałęzi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -m old-name new-name"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wyświetlenie gałęzi zdalnych:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git branch -r"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ważne:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "git branch", "code": true },
              {
                "text": " nie przełącza gałęzi - jedynie je tworzy i nimi zarządza. Do przełączania używa się "
              },
              { "text": "git checkout", "code": true },
              { "text": " lub " },
              { "text": "git switch", "code": true },
              { "text": "." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 19,
    "translations": {
      "uk": {
        "question": "19. Як використовувати git checkout для перемикання між гілками?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Команда " },
              { "text": "git checkout <branch>", "code": true },
              {
                "text": " змінює поточну гілку на вказану, оновлюючи робочий каталог до стану цієї гілки."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "HEAD тепер вказує на feature/login, і всі файли відображають її стан."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Створення нової гілки та одночасне перемикання:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b feature/signup"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Це дозволяє швидко почати роботу в новій гілці без втрати змін (якщо вони закомічені або в staging area)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У сучасних workflow рекомендують використовувати "
              },
              { "text": "git switch", "code": true },
              { "text": " для перемикання гілок (" },
              { "text": "git switch feature/login", "code": true },
              { "text": "), оскільки це більш інтуїтивно." }
            ]
          }
        ]
      },
      "en": {
        "question": "19. How do you use git checkout to switch between branches?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": "git checkout <branch>", "code": true },
              {
                "text": " command switches the current branch to the specified one, updating the working directory to match that branch."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "HEAD now points to feature/login, and all files reflect the state of that branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Create a new branch and switch to it:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b feature/signup"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "This allows you to quickly start working on a new branch without losing changes (if they are committed or staged)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "In modern workflows, it is recommended to use " },
              { "text": "git switch", "code": true },
              { "text": " for switching branches (" },
              { "text": "git switch feature/login", "code": true },
              { "text": "), as it is more intuitive." }
            ]
          }
        ]
      },
      "pl": {
        "question": "19. Jak używać git checkout do przełączania się między gałęziami?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Polecenie " },
              { "text": "git checkout <branch>", "code": true },
              {
                "text": " przełącza bieżącą gałąź na wskazaną, aktualizując katalog roboczy do jej stanu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "HEAD wskazuje teraz na feature/login, a wszystkie pliki odzwierciedlają stan tej gałęzi."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Utworzenie nowej gałęzi i jednoczesne przełączenie:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b feature/signup"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Umożliwia to szybkie rozpoczęcie pracy w nowej gałęzi bez utraty zmian (jeśli są zapisane lub w stagingu)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "W nowoczesnych workflow zaleca się używanie " },
              { "text": "git switch", "code": true },
              { "text": " do przełączania gałęzi (" },
              { "text": "git switch feature/login", "code": true },
              { "text": "), ponieważ jest to bardziej intuicyjne." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 20,
    "translations": {
      "uk": {
        "question": "20. Для чого використовується команда git merge?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge <branch>", "code": true },
                  { "text": " об’єднує зміни з іншої гілки у поточну." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Застосовується для інтеграції роботи над фічами або виправленнями в основну гілку (main/develop)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Типи злиття:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fast-forward", "code": true },
                  {
                    "text": " - просто переміщує вказівник гілки, якщо історія лінійна."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Three-way merge", "code": true },
                  {
                    "text": " - створює новий коміт злиття, якщо гілки розійшлися."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після цього всі зміни з feature/login будуть інтегровані в main."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge дозволяє безпечно інтегрувати паралельні гілки без втрати історії змін."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "20. What is the git merge command used for?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge <branch>", "code": true },
                  {
                    "text": " merges changes from another branch into the current one."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "It is used to integrate feature or bugfix work into the main branch (main/develop)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Merge types:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fast-forward", "code": true },
                  {
                    "text": " - simply moves the branch pointer forward if the history is linear."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Three-way merge", "code": true },
                  {
                    "text": " - creates a new merge commit when branches have diverged."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After this, all changes from feature/login will be integrated into main."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge allows safe integration of parallel branches without losing history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "20. Do czego służy polecenie git merge?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge <branch>", "code": true },
                  { "text": " scala zmiany z innej gałęzi z bieżącą." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Służy do integracji pracy nad funkcjami lub poprawkami z główną gałęzią (main/develop)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Typy scalania:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Fast-forward", "code": true },
                  {
                    "text": " - przesuwa wskaźnik gałęzi, jeśli historia jest liniowa."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Three-way merge", "code": true },
                  {
                    "text": " - tworzy nowy commit scalający, gdy gałęzie się rozeszły."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/login"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po tym wszystkie zmiany z feature/login zostaną scalone z main."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge umożliwia bezpieczną integrację równoległych gałęzi bez utraty historii."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 21,
    "translations": {
      "uk": {
        "question": "21. Який Git workflow ви зазвичай використовуєте в роботі?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Найчастіше використовую Git Flow / Feature Branch Workflow:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  { "text": " - завжди стабільна продакшн-версія." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " - інтеграційна гілка для нових фіч." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Для кожної задачі створюється окрема " },
                  { "text": "feature", "code": true },
                  { "text": "-гілка." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Після завершення - " },
                  { "text": "pull request", "code": true },
                  { "text": " → " },
                  { "text": "code review", "code": true },
                  { "text": " → " },
                  { "text": "merge у develop", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перед релізом створюється " },
                  { "text": "release", "code": true },
                  { "text": "-гілка, після тестування - " },
                  { "text": "merge у main", "code": true },
                  { "text": " та створення тега." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Термінові виправлення виконуються у " },
                  { "text": "hotfix", "code": true },
                  { "text": "-гілках від main." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Такий workflow забезпечує дисципліну, прозорість процесу та повний контроль над релізами."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "21. Which Git workflow do you usually use in your work?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "I usually use Git Flow / Feature Branch Workflow:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  {
                    "text": " - always contains the stable production version."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " - an integration branch for new features." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Each task is developed in a separate " },
                  { "text": "feature", "code": true },
                  { "text": " branch." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "After completion - " },
                  { "text": "pull request", "code": true },
                  { "text": " → " },
                  { "text": "code review", "code": true },
                  { "text": " → " },
                  { "text": "merge into develop", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Before a release, a " },
                  { "text": "release", "code": true },
                  { "text": " branch is created; after testing - " },
                  { "text": "merge into main", "code": true },
                  { "text": " and tagging." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Critical fixes are handled in " },
                  { "text": "hotfix", "code": true },
                  { "text": " branches from main." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This workflow provides structure, transparency, and strong control over releases."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "21. Jaki workflow Git najczęściej stosujesz w pracy?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Najczęściej korzystam z Git Flow / Feature Branch Workflow:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  {
                    "text": " - zawsze zawiera stabilną wersję produkcyjną."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " - gałąź integracyjna dla nowych funkcji." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Każde zadanie realizowane jest w osobnej gałęzi "
                  },
                  { "text": "feature", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Po zakończeniu - " },
                  { "text": "pull request", "code": true },
                  { "text": " → " },
                  { "text": "code review", "code": true },
                  { "text": " → " },
                  { "text": "merge do develop", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przed wydaniem tworzona jest gałąź " },
                  { "text": "release", "code": true },
                  { "text": ", po testach - " },
                  { "text": "merge do main", "code": true },
                  { "text": " oraz tag." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Pilne poprawki realizowane są w gałęziach " },
                  { "text": "hotfix", "code": true },
                  { "text": " od main." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Taki workflow zapewnia dyscyplinę, przejrzystość procesu oraz pełną kontrolę nad wydaniami."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 22,
    "translations": {
      "uk": {
        "question": "22. Опишіть кроки створення нової гілки та її злиття в main.",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Переконуюсь, що локальна гілка main оновлена:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main\n\ngit pull origin main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Створюю нову гілку від main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -b feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Працюю над задачею та комічу зміни:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\n\ngit commit -m \"Implement feature X\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Пушу гілку на віддалений репозиторій:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Відкриваю Pull Request → проходить code review → перевіряється CI."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Мерджу гілку в main (зазвичай через squash або rebase для чистої історії)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Видаляю feature-гілку локально та на remote."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "22. Describe the steps to create a new branch and merge it into main.",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Make sure the local main branch is up to date:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main\n\ngit pull origin main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Create a new branch from main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -b feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Work on the task and commit changes:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\n\ngit commit -m \"Implement feature X\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Push the branch to the remote repository:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Open a Pull Request → go through code review → run CI checks."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Merge the branch into main (usually using squash or rebase to keep history clean)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Delete the feature branch locally and on the remote."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "22. Opisz kroki tworzenia nowej gałęzi i jej scalenia z main.",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Upewniam się, że lokalna gałąź main jest aktualna:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main\n\ngit pull origin main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tworzę nową gałąź na podstawie main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -b feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Pracuję nad zadaniem i wykonuję commity:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\n\ngit commit -m \"Implement feature X\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wysyłam gałąź do repozytorium zdalnego:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Otwieram Pull Request → przeprowadzany jest code review → uruchamiane są testy CI."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Scalam gałąź z main (zwykle przez squash lub rebase, aby zachować czystą historię)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Usuwam gałąź feature lokalnie oraz na remote."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 23,
    "translations": {
      "uk": {
        "question": "23. Що таке merge conflict у Git і як його вирішують?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Merge conflict виникає, коли дві гілки змінюють один і той самий рядок коду або файл у несумісний спосіб, і Git не може автоматично об’єднати ці зміни."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Рішення:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Виконати merge або rebase - Git повідомить про конфліктні файли."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відкрити конфліктний файл і знайти маркери " },
                  { "text": "<<<<<<<", "code": true },
                  { "text": ", " },
                  { "text": "=======", "code": true },
                  { "text": ", " },
                  { "text": ">>>>>>>", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вручну вибрати або об’єднати потрібні зміни." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити файл як вирішений:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Завершити merge або rebase комітом:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "23. What is a merge conflict in Git and how is it resolved?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A merge conflict occurs when two branches modify the same line of code or file in incompatible ways, and Git cannot automatically merge the changes."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Resolution steps:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Run merge or rebase - Git will report the conflicting files."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Open the conflicted file and locate the markers "
                  },
                  { "text": "<<<<<<<", "code": true },
                  { "text": ", " },
                  { "text": "=======", "code": true },
                  { "text": ", " },
                  { "text": ">>>>>>>", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Manually choose or combine the correct changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark the file as resolved:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Finish the merge or rebase with a commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "23. Czym jest konflikt scalania (merge conflict) w Git i jak się go rozwiązuje?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Merge conflict występuje, gdy dwie gałęzie modyfikują ten sam fragment kodu lub plik w niekompatybilny sposób, a Git nie jest w stanie automatycznie scalić zmian."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Rozwiązanie:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wykonać merge lub rebase - Git wskaże pliki z konfliktami."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Otworzyć plik i znaleźć znaczniki " },
                  { "text": "<<<<<<<", "code": true },
                  { "text": ", " },
                  { "text": "=======", "code": true },
                  { "text": ", " },
                  { "text": ">>>>>>>", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ręcznie wybrać lub połączyć właściwe zmiany." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć plik jako rozwiązany:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zakończyć scalanie lub rebase commitem:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 24,
    "translations": {
      "uk": {
        "question": "24. Що таке fast-forward merge у Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Fast-forward merge - це злиття, коли гілка-ціль (наприклад main) не має нових комітів після відгалуження feature-гілки. У такому випадку Git просто пересуває вказівник main на останній коміт feature-гілки без створення merge-коміту."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/my-task --ff"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Це «чисте» злиття без створення додаткових комітів в історії."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "24. What is a fast-forward merge in Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A fast-forward merge occurs when the target branch (for example, main) has no new commits since the feature branch was created. In this case, Git simply moves the main pointer forward to the latest commit of the feature branch without creating a merge commit."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/my-task --ff"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This results in a clean history without additional merge commits."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "24. Czym jest fast-forward merge w Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Fast-forward merge to scalanie, w którym gałąź docelowa (np. main) nie ma nowych commitów od momentu utworzenia gałęzi feature. Git przesuwa wtedy wskaźnik main do ostatniego commita gałęzi feature bez tworzenia commita scalającego."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout main\n\ngit merge feature/my-task --ff"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jest to „czyste” scalanie bez dodatkowych commitów w historii."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 25,
    "translations": {
      "uk": {
        "question": "25. Що таке three-way merge у Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Three-way merge - це тип злиття, під час якого Git використовує три точки для об’єднання змін:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "common ancestor", "code": true },
                  {
                    "text": " - спільний базовий коміт, від якого розійшлися гілки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "HEAD", "code": true },
                  {
                    "text": " - останній коміт у цільовій гілці (наприклад, main)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "branch tip", "code": true },
                  {
                    "text": " - останній коміт у гілці, яка зливається (наприклад, feature)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git порівнює зміни відносно спільного предка та створює новий merge-коміт, який має двох батьківських коміти."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Такий тип злиття використовується, коли fast-forward merge неможливий, тобто в обох гілках з’явилися нові коміти."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "25. What is a three-way merge in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A three-way merge is a merge strategy where Git uses three reference points to combine changes:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "common ancestor", "code": true },
                  {
                    "text": " - the base commit from which the branches diverged."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "HEAD", "code": true },
                  {
                    "text": " - the latest commit in the target branch (for example, main)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "branch tip", "code": true },
                  {
                    "text": " - the latest commit in the branch being merged (for example, feature)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git compares changes relative to the common ancestor and creates a new merge commit that has two parent commits."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This approach is used when a fast-forward merge is not possible, meaning both branches contain new commits."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "25. Czym jest three-way merge w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Three-way merge to strategia scalania, w której Git wykorzystuje trzy punkty odniesienia do połączenia zmian:"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "common ancestor", "code": true },
                  {
                    "text": " - wspólny commit bazowy, od którego rozeszły się gałęzie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "HEAD", "code": true },
                  {
                    "text": " - ostatni commit w gałęzi docelowej (np. main)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "branch tip", "code": true },
                  {
                    "text": " - ostatni commit w scalanej gałęzi (np. feature)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git porównuje zmiany względem wspólnego przodka i tworzy nowy commit scalający z dwoma commitami nadrzędnymi."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ten typ scalania jest stosowany, gdy fast-forward merge nie jest możliwy, czyli gdy obie gałęzie zawierają nowe commity."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 26,
    "translations": {
      "uk": {
        "question": "26. Які кроки виконати, щоб перебазувати (rebase) гілку в Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перейти у свою гілку:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Виконати rebase на актуальну main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin\n\ngit rebase origin/main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо виникають конфлікти - вирішити їх і додати файли:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>\n\ngit rebase --continue"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після завершення оновити remote (з форсом, оскільки історія була переписана):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task --force"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rebase робить історію комітів лінійною, на відміну від merge."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "26. What steps are required to rebase a branch in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Switch to your feature branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Rebase it onto the latest main branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin\n\ngit rebase origin/main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If conflicts occur, resolve them and stage the files:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>\n\ngit rebase --continue"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After completion, update the remote branch (force push is required because history was rewritten):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task --force"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rebase creates a linear commit history, unlike merge."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "26. Jakie kroki należy wykonać, aby wykonać rebase gałęzi w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Przełączyć się na swoją gałąź:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wykonać rebase na aktualną gałąź main:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin\n\ngit rebase origin/main"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli pojawią się konflikty - rozwiązać je i dodać pliki:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>\n\ngit rebase --continue"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po zakończeniu zaktualizować gałąź zdalną (wymagany force push, ponieważ historia została zmieniona):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature/my-task --force"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rebase tworzy liniową historię commitów, w przeciwieństwie do merge."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 27,
    "translations": {
      "uk": {
        "question": "27. Які плюси й мінуси rebase у порівнянні з merge?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Лінійна, чиста історія без merge-комітів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зручніше читати git log, легше дебажити." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Кожен коміт виглядає так, ніби зроблений поверх останнього main."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Переписує історію (особливо небезпечно для спільних гілок)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Потребує force push, що може створити проблеми іншим розробникам."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вимагає більшої дисципліни в команді." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Зберігає повну історію розробки без переписування."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Безпечний для командної роботи." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Простий і зрозумілий у використанні." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Менш чистий git log з великою кількістю merge-комітів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Історію складніше аналізувати та відстежувати."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Загалом:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge безпечніший для командної роботи, тоді як rebase краще підходить для підтримки чистої історії."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "27. What are the pros and cons of rebase compared to merge?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages of rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Clean, linear history without merge commits." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Easier to read git log and debug changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Each commit appears as if it was created on top of the latest main branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Disadvantages of rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Rewrites history (dangerous for shared branches)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Requires force push, which may disrupt others."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Requires more discipline within the team." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages of merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Preserves the complete development history." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Safe for collaborative team workflows." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Simple and straightforward to use." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Disadvantages of merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Messier git log with many merge commits." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "History can be harder to analyze." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Overall:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge is safer for teams, while rebase is better for maintaining a clean history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "27. Jakie są zalety i wady rebase w porównaniu do merge?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Czysta, liniowa historia bez commitów scalających."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Łatwiejsze czytanie git log i debugowanie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Każdy commit wygląda, jakby został wykonany na aktualnej gałęzi main."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady rebase" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Przepisuje historię (niebezpieczne dla współdzielonych gałęzi)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wymaga force push, co może powodować problemy innym."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wymaga większej dyscypliny zespołowej." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Zachowuje pełną historię rozwoju projektu." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Bezpieczne dla pracy zespołowej." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Proste i intuicyjne w użyciu." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady merge" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Mniej czytelna historia z wieloma commitami scalającymi."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Trudniejsza analiza historii zmian." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Podsumowanie:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge jest bezpieczniejszy dla zespołów, natomiast rebase lepiej sprawdza się przy utrzymaniu czystej historii."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 28,
    "translations": {
      "uk": {
        "question": "28. Для чого використовуються теги в Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Теги в Git - це фіксовані маркери, що вказують на конкретні коміти, зазвичай для позначення релізів (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight tag", "code": true },
                  {
                    "text": " - проста вказівка на коміт без додаткових метаданих."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated tag", "code": true },
                  {
                    "text": " - містить автора, дату, повідомлення та може бути підписаний GPG."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Теги зручні для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Відстеження версій у продакшені." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Швидкого переходу до конкретного релізу:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Також теги часто використовуються в CI/CD для автоматичного деплою."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "28. What are Git tags used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git tags are fixed references to specific commits, commonly used to mark releases (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight tag", "code": true },
                  {
                    "text": " - a simple pointer to a commit without additional metadata."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated tag", "code": true },
                  {
                    "text": " - stores author, date, message and can be GPG-signed."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tags are useful for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Tracking production versions." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Quickly checking out a specific release:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tags are also widely used in CI/CD pipelines for automated deployments."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "28. Do czego służą tagi w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tagi w Git to stałe wskaźniki na konkretne commity, najczęściej używane do oznaczania wydań (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight tag", "code": true },
                  {
                    "text": " - proste wskazanie na commit bez dodatkowych informacji."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated tag", "code": true },
                  {
                    "text": " - zawiera autora, datę, opis i może być podpisany GPG."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tagi są przydatne do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Śledzenia wersji na produkcji." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Szybkiego przejścia do konkretnego wydania:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tagi są również często wykorzystywane w CI/CD do automatycznych wdrożeń."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 29,
    "translations": {
      "uk": {
        "question": "29. Як скасувати коміт, який вже запушено на remote?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо потрібно повністю видалити коміт (історія переписується, небезпечно для інших):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git reset --hard <commit_before>\n\ngit push origin <branch> --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо потрібно зберегти історію, створивши «відкат» без переписування:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git revert <commit_hash>\n\ngit push origin <branch>"
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reset --hard", "code": true },
                  { "text": " + " },
                  { "text": "force push", "code": true },
                  {
                    "text": " - змінює історію комітів (небезпечно для спільних гілок)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "revert", "code": true },
                  {
                    "text": " - створює новий коміт, який відміняє зміни, без переписування історії (безпечніше для команди)."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "29. How can you undo a commit that has already been pushed to a remote repository?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If you need to completely remove the commit (history is rewritten, dangerous for others):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git reset --hard <commit_before>\n\ngit push origin <branch> --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If you want to keep the history and safely undo the changes:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git revert <commit_hash>\n\ngit push origin <branch>"
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reset --hard", "code": true },
                  { "text": " + " },
                  { "text": "force push", "code": true },
                  {
                    "text": " rewrites commit history (unsafe for shared branches)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "revert", "code": true },
                  {
                    "text": " creates a new commit that undoes the changes without rewriting history (safer for teams)."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "29. Jak cofnąć commit, który został już wypchnięty (push) do repozytorium zdalnego?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli trzeba całkowicie usunąć commit (historia zostaje przepisana, niebezpieczne dla innych):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git reset --hard <commit_before>\n\ngit push origin <branch> --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli chcesz zachować historię i bezpiecznie cofnąć zmiany:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git revert <commit_hash>\n\ngit push origin <branch>"
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "reset --hard", "code": true },
                  { "text": " + " },
                  { "text": "force push", "code": true },
                  {
                    "text": " przepisuje historię commitów (niebezpieczne dla wspólnych gałęzi)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "revert", "code": true },
                  {
                    "text": " tworzy nowy commit cofający zmiany bez przepisywania historii (bezpieczniejsze dla zespołów)."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 30,
    "translations": {
      "uk": {
        "question": "30. Яке призначення головної гілки (main/master) у Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Головна гілка (main або раніше master) - це стабільна, завжди робоча версія проєкту, на яку орієнтуються всі інші гілки."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Від неї створюють feature-, release- та hotfix-гілки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вона слугує базою для формування релізів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Зазвичай саме з неї запускається CI/CD та деплой у продакшн."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "30. What is the purpose of the main (master) branch in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The main branch (formerly master) represents the stable, production-ready version of the project that all other branches are based on."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Feature, release, and hotfix branches are created from it."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "It serves as the foundation for releases." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "CI/CD pipelines and production deployments usually run from this branch."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "30. Jakie jest przeznaczenie głównej gałęzi (main/master) w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Główna gałąź (main lub dawniej master) to stabilna, zawsze działająca wersja projektu, na której opierają się pozostałe gałęzie."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Na jej podstawie tworzy się gałęzie feature, release i hotfix."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Służy jako baza do przygotowywania wydań." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zazwyczaj z tej gałęzi uruchamiane są procesy CI/CD oraz wdrożenia na produkcję."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 31,
    "translations": {
      "uk": {
        "question": "31. Що таке розподілена система контролю версій і як Git реалізує цей підхід?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Розподілена система контролю версій (DVCS) - це система, у якій кожен розробник має повну копію репозиторію разом з усією історією комітів, а не лише робочі файли."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git реалізує підхід DVCS таким чином:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Під час клонування репозиторію розробник отримує всю історію змін локально."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Коміти, гілки та теги створюються локально й не потребують постійного підключення до сервера."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Синхронізація між розробниками відбувається через push і pull у віддалений репозиторій (наприклад, GitHub)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Такий підхід забезпечує високу швидкість, автономність і можливість працювати офлайн."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "31. What is a distributed version control system and how does Git implement this approach?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A distributed version control system (DVCS) is a system in which every developer has a full copy of the repository, including the complete commit history, not just the working files."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Git implements the DVCS approach as follows:" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "When cloning a repository, the entire history is downloaded locally."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Commits, branches, and tags are created locally and do not require a constant server connection."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Synchronization between developers happens via push and pull operations to a remote repository (for example, GitHub)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "This provides high performance, autonomy, and the ability to work offline."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "31. Czym jest rozproszony system kontroli wersji i jak Git realizuje to podejście?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Rozproszony system kontroli wersji (DVCS) to system, w którym każdy programista posiada pełną kopię repozytorium wraz z całą historią commitów, a nie tylko pliki robocze."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Git realizuje podejście DVCS w następujący sposób:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Podczas klonowania repozytorium pobierana jest cała historia zmian lokalnie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Commity, gałęzie i tagi są tworzone lokalnie i nie wymagają stałego połączenia z serwerem."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Synchronizacja między programistami odbywa się poprzez operacje push i pull do zdalnego repozytorium (np. GitHub)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Takie podejście zapewnia szybkość, autonomię oraz możliwość pracy offline."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 32,
    "translations": {
      "uk": {
        "question": "32. Що таке Git Feature Branch Workflow і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Feature Branch Workflow", "bold": true },
              {
                "text": " - це підхід до розробки, за якого для кожної нової задачі або фічі створюється окрема гілка."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Від main або develop відгалужується гілка " },
                  { "text": "feature/", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Розробка та всі коміти виконуються лише в цій гілці."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після завершення роботи відкривається Pull Request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після code review та проходження CI зміни зливаються назад у develop або main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Feature-гілка видаляється." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ізоляція змін, можливість паралельної роботи без конфліктів та чиста, контрольована історія."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "32. What is the Git Feature Branch Workflow and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Feature Branch Workflow", "bold": true },
              {
                "text": " is a development approach where a separate branch is created for each new task or feature."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "A " },
                  { "text": "feature/", "code": true },
                  { "text": " branch is created from main or develop." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "All development and commits happen only in this branch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Once the feature is complete, a Pull Request is opened."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After code review and successful CI checks, changes are merged back into develop or main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "The feature branch is deleted." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Isolation of changes, parallel development without conflicts, and a clean, controlled history."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "32. Czym jest Git Feature Branch Workflow i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Feature Branch Workflow", "bold": true },
              {
                "text": " to podejście, w którym dla każdego nowego zadania lub funkcji tworzona jest osobna gałąź."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Od gałęzi main lub develop tworzona jest gałąź "
                  },
                  { "text": "feature/", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Cała praca i commity odbywają się wyłącznie w tej gałęzi."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po zakończeniu pracy otwierany jest Pull Request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po code review i przejściu CI zmiany są scalane z powrotem do develop lub main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Gałąź feature jest usuwana." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Izolacja zmian, równoległa praca bez konfliktów oraz czysta i kontrolowana historia."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 33,
    "translations": {
      "uk": {
        "question": "33. Що таке Gitflow Workflow і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Gitflow", "bold": true },
              {
                "text": " - це модель роботи з Git із чіткими правилами для різних типів гілок."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  { "text": " - завжди стабільна продакшн-версія." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " - інтеграційна гілка для активної розробки." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "feature/", "code": true },
                  {
                    "text": " - створюються від develop і після завершення зливаються назад у develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "release/", "code": true },
                  {
                    "text": " - відгалужуються від develop для підготовки релізу, після тестування зливаються в main і develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "hotfix/", "code": true },
                  {
                    "text": " - створюються від main для термінових виправлень і потім зливаються як у main, так і в develop."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Плюси:", "bold": true },
              {
                "text": " чітка структура, контрольована розробка та керовані релізи."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Мінуси:", "bold": true },
              {
                "text": " громіздкий процес для маленьких команд або підходів з continuous delivery."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "33. What is the Gitflow Workflow and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Gitflow", "bold": true },
              {
                "text": " is a Git workflow model with clearly defined rules for different branch types."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  {
                    "text": " - always represents the stable production version."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  {
                    "text": " - the integration branch for active development."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "feature/", "code": true },
                  {
                    "text": " - created from develop and merged back into develop after completion."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "release/", "code": true },
                  {
                    "text": " - branched from develop to prepare a release, then merged into both main and develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "hotfix/", "code": true },
                  {
                    "text": " - branched from main for urgent fixes and merged back into both main and develop."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Pros:", "bold": true },
              {
                "text": " clear structure, controlled development, and predictable releases."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Cons:", "bold": true },
              {
                "text": " can be overly complex for small teams or continuous delivery workflows."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "33. Czym jest Gitflow Workflow i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Gitflow", "bold": true },
              {
                "text": " to model pracy z Git z jasno określonymi zasadami dla różnych typów gałęzi."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main", "code": true },
                  {
                    "text": " - zawsze reprezentuje stabilną wersję produkcyjną."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "develop", "code": true },
                  { "text": " - gałąź integracyjna dla aktywnego rozwoju." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "feature/", "code": true },
                  {
                    "text": " - tworzone z develop i po zakończeniu scalane z powrotem do develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "release/", "code": true },
                  {
                    "text": " - odgałęziane z develop w celu przygotowania wydania, następnie scalane do main i develop."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "hotfix/", "code": true },
                  {
                    "text": " - tworzone z main dla pilnych poprawek i scalane do main oraz develop."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Zalety:", "bold": true },
              {
                "text": " jasno określona struktura, kontrolowany rozwój i przewidywalne wydania."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Wady:", "bold": true },
              {
                "text": " zbyt rozbudowany proces dla małych zespołów lub podejścia continuous delivery."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 34,
    "translations": {
      "uk": {
        "question": "34. Що таке Forking Workflow у Git і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Forking Workflow", "bold": true },
              {
                "text": " - це підхід, за якого кожен розробник працює не напряму з основним репозиторієм, а зі своєю власною копією (fork)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Процес:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Розробник створює fork головного репозиторію у своєму GitHub або GitLab."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Клонує свій fork локально та створює окрему гілку для змін."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після завершення роботи пушить зміни у власний fork."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Відкриває Pull Request зі свого fork у головний (upstream) репозиторій."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після code review та схвалення зміни зливаються в upstream."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Цей workflow зазвичай використовується у великих open-source проєктах, де стороннім контриб’юторам не надається прямий доступ до основного репозиторію."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "34. What is the Forking Workflow in Git and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Forking Workflow", "bold": true },
              {
                "text": " is an approach where each developer works with their own copy (fork) of the repository instead of pushing directly to the main repository."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Process:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The developer creates a fork of the main repository on GitHub or GitLab."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "They clone their fork locally and create a separate branch for changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After completing the work, they push changes to their fork."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "They open a Pull Request from their fork to the main (upstream) repository."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After review and approval, the changes are merged into the upstream repository."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This workflow is commonly used in large open-source projects where external contributors do not have direct write access to the main repository."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "34. Czym jest Forking Workflow w Git i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Forking Workflow", "bold": true },
              {
                "text": " to podejście, w którym każdy programista pracuje na własnej kopii repozytorium (fork), zamiast bezpośrednio na repozytorium głównym."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Proces:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Programista tworzy fork głównego repozytorium na GitHubie lub GitLabie."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Klonuje swój fork lokalnie i tworzy osobną gałąź na zmiany."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po zakończeniu pracy wysyła zmiany (push) do własnego fork’a."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Otwiera Pull Request z własnego fork’a do głównego repozytorium (upstream)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po review i akceptacji zmiany są scalane z repozytorium upstream."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ten workflow jest powszechnie stosowany w dużych projektach open-source, gdzie zewnętrzni kontrybutorzy nie mają bezpośredniego dostępu do głównego repozytorium."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 35,
    "translations": {
      "uk": {
        "question": "35. Що таке Centralized Workflow у Git і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Centralized Workflow", "bold": true },
              {
                "text": " - це модель роботи, у якій є одна головна гілка (зазвичай main), і всі розробники працюють безпосередньо з нею або створюють короткоживучі гілки для невеликих задач."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Процес:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Усі розробники клонують один спільний remote-репозиторій."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Роблять зміни локально та одразу пушать їх у гілку main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "У разі конфліктів їх потрібно вирішити перед пушем."
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Нагадує класичні централізовані системи (SVN), але з перевагами Git: локальна історія та робота офлайн."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Простий процес і мінімальна кількість гілок." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Погано масштабується для великих команд: часті конфлікти та відсутність ізоляції фіч."
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "35. What is the Centralized Workflow in Git and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Centralized Workflow", "bold": true },
              {
                "text": " is a model where there is a single main branch (usually main), and all developers work directly on it or create very short-lived branches for small tasks."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Process:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "All developers clone the same shared remote repository."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "They make changes locally and push them directly to the main branch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Any conflicts must be resolved before pushing."
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Similar to traditional centralized systems (SVN), but with Git advantages such as local history and offline work."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Simple process with minimal branching." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Hard to scale for larger teams due to frequent conflicts and lack of feature isolation."
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "35. Czym jest Centralized Workflow w Git i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Centralized Workflow", "bold": true },
              {
                "text": " to model pracy, w którym istnieje jedna główna gałąź (zwykle main), a wszyscy programiści pracują bezpośrednio na niej lub tworzą bardzo krótkotrwałe gałęzie dla małych zadań."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Proces:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wszyscy programiści klonują jedno wspólne repozytorium zdalne."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wprowadzają zmiany lokalnie i wysyłają je bezpośrednio do gałęzi main."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wszelkie konflikty muszą zostać rozwiązane przed wykonaniem push."
                  }
                ]
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Przypomina klasyczne systemy scentralizowane (SVN), ale z zaletami Git, takimi jak lokalna historia i praca offline."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Prosty proces i minimalna liczba gałęzi." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Słabo skaluje się w większych zespołach z powodu częstych konfliktów i braku izolacji funkcji."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 36,
    "translations": {
      "uk": {
        "question": "36. Що таке remote repository у Git і для чого він потрібен?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Віддалений репозиторій (remote) - це версія Git-репозиторію, що зберігається на сервері (наприклад, GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Призначення:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Спільна робота команди через push і pull змін."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Централізоване зберігання коду та повної історії комітів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Інтеграція з CI/CD пайплайнами та інструментами перевірки коду."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади команд:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git remote -v              # переглянути підключені remote\n\ngit remote add origin URL  # додати віддалений репозиторій\n\ngit push origin main       # відправити зміни\n\ngit pull origin main       # отримати зміни"
          }
        ]
      },
      "en": {
        "question": "36. What is a remote repository in Git and what is it used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A remote repository is a version of a Git repository hosted on a server (for example, GitHub, GitLab, or Bitbucket)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Purpose:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Enables team collaboration via push and pull operations."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Provides centralized storage of code and full commit history."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Integrates with CI/CD pipelines and code review tools."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example commands:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git remote -v              # list configured remotes\n\ngit remote add origin URL  # add a remote repository\n\ngit push origin main       # push changes\n\ngit pull origin main       # fetch and merge changes"
          }
        ]
      },
      "pl": {
        "question": "36. Czym jest zdalne repozytorium (remote repository) w Git i do czego służy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zdalne repozytorium (remote) to wersja repozytorium Git przechowywana na serwerze (np. GitHub, GitLab, Bitbucket)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przeznaczenie:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Umożliwia współpracę zespołową poprzez operacje push i pull."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zapewnia centralne przechowywanie kodu i pełnej historii commitów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Integruje się z pipeline’ami CI/CD oraz narzędziami do code review."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykładowe polecenia:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git remote -v              # wyświetl skonfigurowane remote\n\ngit remote add origin URL  # dodaj zdalne repozytorium\n\ngit push origin main       # wyślij zmiany\n\ngit pull origin main       # pobierz i scal zmiany"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 37,
    "translations": {
      "uk": {
        "question": "37. Як змінити URL remote-репозиторію в Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Для оновлення URL використовують команду:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote set-url origin <новий_URL>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Перевірити зміни можна так:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote -v"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Або замінити remote повністю:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote remove origin\ngit remote add origin <новий_URL>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовується, наприклад, при переході з HTTPS на SSH чи зміні репозиторію на GitHub/GitLab."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "37. How do you change the URL of a remote repository in Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "To update the URL, use:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote set-url origin <new_URL>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You can check the changes with:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote -v"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Or replace the remote entirely:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote remove origin\ngit remote add origin <new_URL>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Useful, for example, when switching from HTTPS to SSH or changing the repository on GitHub/GitLab."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "37. Jak zmienić URL zdalnego repozytorium w Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Aby zaktualizować URL, użyj polecenia:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote set-url origin <new_URL>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zmiany możesz sprawdzić tak:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote -v"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Albo całkowicie podmień remote:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git remote remove origin\ngit remote add origin <new_URL>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Przydatne np. przy przejściu z HTTPS na SSH lub przy zmianie repozytorium na GitHub/GitLab."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 38,
    "translations": {
      "uk": {
        "question": "38. Які команди використовуються, щоб синхронізувати локальний репозиторій з remote у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Отримати останні зміни з remote:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Об’єднати з локальною гілкою:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git pull origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "(еквівалент fetch + merge)." }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Відправити свої зміни на remote:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коротко:" }]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "pull → підтягнути зміни, push → відправити свої." }
            ]
          }
        ]
      },
      "en": {
        "question": "38. Which commands are used to synchronize a local repository with a remote in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Fetch the latest changes from the remote repository:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Merge changes into the local branch:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git pull origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "(equivalent to fetch + merge)." }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Push your local changes to the remote repository:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In short:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "pull → fetch and integrate changes, push → send your changes."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "38. Jakie polecenia służą do synchronizacji lokalnego repozytorium z repozytorium zdalnym w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Pobranie najnowszych zmian z repozytorium zdalnego:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git fetch origin"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Scalenie zmian z lokalną gałęzią:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git pull origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "(odpowiednik fetch + merge)." }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wysłanie własnych zmian do repozytorium zdalnego:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W skrócie:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "pull → pobrać i scalić zmiany, push → wysłać własne zmiany."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 39,
    "translations": {
      "uk": {
        "question": "39. Як видалити невикористані (застарілі) гілки локально й на remote у Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Локально:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch -d branch_name      # видалити вже злиту гілку\n\ngit branch -D branch_name      # примусово видалити"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Віддалено:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git push origin --delete branch_name"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Очистити локальний список remote-гілок (які вже видалені на сервері):"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fetch --prune"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Практика:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Після merge у main видаляють feature-гілки, щоб не захаращувати репозиторій."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "39. How can you delete unused (obsolete) branches locally and on a remote in Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Locally:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch -d branch_name      # delete a branch that has already been merged\n\ngit branch -D branch_name      # force delete"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Remotely:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git push origin --delete branch_name"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Clean up the local list of remote branches (already deleted on the server):"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fetch --prune"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Best practice:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "After merging into main, feature branches should be deleted to keep the repository clean."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "39. Jak usunąć nieużywane (przestarzałe) gałęzie lokalnie i na zdalnym repozytorium w Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Lokalnie:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git branch -d branch_name      # usuń gałąź, która została już scalona\n\ngit branch -D branch_name      # wymuś usunięcie"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zdalnie:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git push origin --delete branch_name"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Wyczyścić lokalną listę gałęzi zdalnych (usuniętych już na serwerze):"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fetch --prune"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Praktyka:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Po scaleniu z main usuwa się gałęzie feature, aby nie zaśmiecać repozytorium."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 40,
    "translations": {
      "uk": {
        "question": "40. Які кроки потрібно виконати для вирішення merge conflict у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Спробувати злиття або rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git повідомляє про конфлікти. Перевірити файли:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git status"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відкрити конфліктні файли, знайти маркери:" },
                  {
                    "type": "code",
                    "language": "text",
                    "content": "<<<<<<< HEAD\n...\n=======\n...\n>>>>>>> feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Вирішити конфлікт вручну (залишити або об’єднати потрібні зміни)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити файли як вирішені:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Продовжити merge або rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit            # якщо merge\n\ngit rebase --continue # якщо rebase"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Перевірити, що все працює, і запушити зміни:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "40. What steps are required to resolve a merge conflict in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Attempt a merge or rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git reports conflicts. Check the affected files:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git status"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Open the conflicted files and locate conflict markers:"
                  },
                  {
                    "type": "code",
                    "language": "text",
                    "content": "<<<<<<< HEAD\n...\n=======\n...\n>>>>>>> feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Resolve the conflict manually by keeping or combining the correct changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark the files as resolved:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Continue the merge or rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit            # for merge\n\ngit rebase --continue # for rebase"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Verify everything works and push the changes:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "40. Jakie kroki należy wykonać, aby rozwiązać konflikt scalania (merge conflict) w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Spróbować wykonać merge lub rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git zgłasza konflikty. Sprawdzić pliki:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git status"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Otworzyć pliki konfliktowe i znaleźć znaczniki:"
                  },
                  {
                    "type": "code",
                    "language": "text",
                    "content": "<<<<<<< HEAD\n...\n=======\n...\n>>>>>>> feature/my-task"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Rozwiązać konflikt ręcznie, zachowując lub łącząc właściwe zmiany."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć pliki jako rozwiązane:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontynuować merge lub rebase:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit            # dla merge\n\ngit rebase --continue # dla rebase"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sprawdzić działanie i wypchnąć zmiany:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin main"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 41,
    "translations": {
      "uk": {
        "question": "41. Для чого призначена команда git stash?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git stash", "code": true },
              {
                "text": " дозволяє тимчасово сховати незавершені зміни (modified / staged файли) у локальному репозиторії, щоб переключитися на іншу гілку або виконати інші операції без створення коміту."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash           # сховати зміни\n\ngit stash pop       # повернути сховані зміни\n\ngit stash list      # переглянути список схованих змін"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовується, коли потрібно швидко переключитися на main для виправлення багу або підтягнути останні зміни."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "41. What is the purpose of the git stash command?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git stash", "code": true },
              {
                "text": " temporarily saves unfinished changes (modified / staged files) in the local repository, allowing you to switch branches or perform other operations without committing them."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash           # save changes\n\ngit stash pop       # restore saved changes\n\ngit stash list      # list saved stashes"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It is commonly used when you need to quickly switch to main to fix a bug or pull the latest changes."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "41. Do czego służy polecenie git stash?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git stash", "code": true },
              {
                "text": " pozwala tymczasowo ukryć niezakończone zmiany (pliki modified / staged) w lokalnym repozytorium, aby przełączyć się na inną gałąź lub wykonać inne operacje bez tworzenia commita."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash           # ukryj zmiany\n\ngit stash pop       # przywróć zapisane zmiany\n\ngit stash list      # lista zapisanych zmian"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Używane, gdy trzeba szybko przełączyć się na main, aby naprawić błąd lub pobrać najnowsze zmiany."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 42,
    "translations": {
      "uk": {
        "question": "42. Як переглянути зміни у файлах, які ще не закомічені, або історію комітів у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Зміни в робочому каталозі (не staged):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зміни, які вже додані до staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff --staged"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Історія комітів:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Коротка та наочна історія:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline --graph --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд змін конкретного файлу:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff <file>\n\ngit log -p <file>"
                  }
                ]
              }
            ]
          }
        ]
      },
      "en": {
        "question": "42. How can you view uncommitted file changes or the commit history in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Changes in the working directory (not staged):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Changes already added to the staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff --staged"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit history:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Compact and visual history:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline --graph --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "View changes of a specific file:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff <file>\n\ngit log -p <file>"
                  }
                ]
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "42. Jak sprawdzić niezacommitowane zmiany w plikach lub historię commitów w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zmiany w katalogu roboczym (nie dodane do stage):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zmiany dodane do staging area:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff --staged"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Historia commitów:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Krótka i czytelna historia:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline --graph --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podgląd zmian w konkretnym pliku:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git diff <file>\n\ngit log -p <file>"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 43,
    "translations": {
      "uk": {
        "question": "43. Чи можна застосувати зміни з Git stash, не видаляючи їх зі списку?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [{ "text": "Так, для цього використовують команду:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Застосовує вибрану сховану зміну до поточної робочої гілки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Не видаляє її зі списку stash." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Якщо потрібно одночасно застосувати зміни і видалити їх зі списку, використовують:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash pop"
          }
        ]
      },
      "en": {
        "question": "43. Can you apply changes from Git stash without removing them from the list?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Yes, this can be done using the following command:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Applies the selected stashed changes to the current working branch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Does not remove the stash entry from the stash list."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "If you want to apply the changes and remove them from the list at the same time, use:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash pop"
          }
        ]
      },
      "pl": {
        "question": "43. Czy można zastosować zmiany z Git stash bez usuwania ich z listy?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [{ "text": "Tak, w tym celu używa się polecenia:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Stosuje wybrane zapisane zmiany do bieżącej gałęzi roboczej."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Nie usuwa ich z listy stash." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jeśli chcesz jednocześnie zastosować zmiany i usunąć je z listy, użyj:"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash pop"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 44,
    "translations": {
      "uk": {
        "question": "44. Що робить команда git clean?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clean", "code": true },
              {
                "text": " видаляє незатрековані файли та каталоги з робочого каталогу, тобто ті, що не відслідковуються Git."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clean -n       # показати, що буде видалено (dry-run)\n\ngit clean -f       # видалити незатрековані файли\n\ngit clean -fd      # видалити файли та каталоги\n\ngit clean -fx      # видалити файли, включаючи ті, що в .gitignore"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовується для очищення робочого каталогу перед збіркою або тестуванням, коли потрібен повністю чистий стан."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "44. What does the git clean command do?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clean", "code": true },
              {
                "text": " removes untracked files and directories from the working directory, meaning files that are not tracked by Git."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clean -n       # show what would be removed (dry-run)\n\ngit clean -f       # remove untracked files\n\ngit clean -fd      # remove files and directories\n\ngit clean -fx      # remove files including those in .gitignore"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It is used to clean the working directory before builds or tests when a completely clean state is required."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "44. Co robi polecenie git clean?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git clean", "code": true },
              {
                "text": " usuwa nieśledzone pliki i katalogi z katalogu roboczego, czyli te, które nie są śledzone przez Git."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clean -n       # pokaż, co zostanie usunięte (dry-run)\n\ngit clean -f       # usuń nieśledzone pliki\n\ngit clean -fd      # usuń pliki i katalogi\n\ngit clean -fx      # usuń pliki, w tym te z .gitignore"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie jest używane do czyszczenia katalogu roboczego przed budowaniem lub testami, gdy wymagany jest całkowicie czysty stan."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 45,
    "translations": {
      "uk": {
        "question": "45. Як видалити файл з відслідковування Git, але залишити його в локальному робочому каталозі?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Для цього використовують команду:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Файл видаляється з індексу (staging area), але залишається у робочому каталозі."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після коміту і пушу Git більше не буде відслідковувати цей файл."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Типовий сценарій - прибрати конфіг або секрети з репозиторію, залишивши файл локально."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>\n\ngit commit -m \"Stop tracking file\""
          }
        ]
      },
      "en": {
        "question": "45. How can you stop tracking a file in Git while keeping it in the local working directory?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Use the following command:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The file is removed from the index (staging area) but remains in the working directory."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After committing and pushing, Git will no longer track this file."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This is commonly used to remove configuration or secret files from version control while keeping them locally."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>\n\ngit commit -m \"Stop tracking file\""
          }
        ]
      },
      "pl": {
        "question": "45. Jak przestać śledzić plik w Git, pozostawiając go w lokalnym katalogu roboczym?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W tym celu używa się polecenia:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Plik zostaje usunięty z indeksu (staging area), ale pozostaje w katalogu roboczym."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po wykonaniu commita i pusha Git przestaje śledzić ten plik."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Często stosowane do usuwania plików konfiguracyjnych lub sekretów z repozytorium."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rm --cached <file>\n\ngit commit -m \"Stop tracking file\""
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 46,
    "translations": {
      "uk": {
        "question": "46. Як переглянути історію комітів у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Базовий перегляд:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Коротка форма:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Графічне відображення гілок:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --graph --oneline --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд змін у конкретному коміті:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -p\n\ngit show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Фільтрація історії по файлу:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ці команди використовуються для аналізу історії, пошуку змін і розуміння того, хто та коли зробив певний коміт."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "46. How can you view the commit history in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Basic view:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Short format:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Graphical view of branches:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --graph --oneline --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "View changes inside commits:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -p\n\ngit show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Filter history by file:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "These commands are used to analyze history, track changes, and see who made specific commits and when."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "46. Jak wyświetlić historię commitów w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Podstawowy widok:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Krótka forma:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --oneline"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Graficzne przedstawienie gałęzi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --graph --oneline --decorate --all"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podgląd zmian w commitach:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -p\n\ngit show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Filtrowanie historii według pliku:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenia te służą do analizy historii, wyszukiwania zmian oraz sprawdzania, kto i kiedy wykonał dany commit."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 47,
    "translations": {
      "uk": {
        "question": "47. Як знайти всі коміти певного автора у Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Використовують команду git log з опцією " },
                  { "text": "--author", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Ім'я або email автора\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Додатково можна скоротити вивід до одного рядка:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Ім'я\" --oneline"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Це дозволяє переглянути всі коміти конкретного розробника в межах проєкту."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "47. How can you find all commits made by a specific author in Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Use the git log command with the " },
                  { "text": "--author", "code": true },
                  { "text": " option:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Author name or email\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You can also shorten the output to a single line per commit:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Name\" --oneline"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This makes it easy to review all commits created by a specific developer in the project."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "47. Jak znaleźć wszystkie commity wykonane przez konkretnego autora w Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Używa się polecenia git log z opcją " },
                  { "text": "--author", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Imię lub email autora\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Można również skrócić wynik do jednej linii na commit:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git log --author=\"Imię\" --oneline"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Dzięki temu można łatwo przejrzeć wszystkie commity wykonane przez danego programistę w projekcie."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 48,
    "translations": {
      "uk": {
        "question": "48. Як переглянути зміни, внесені конкретним комітом у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд повних змін коміту:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Короткий варіант:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --stat <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перегляд змін конкретного файлу в коміті:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash> -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовується для аналізу змін, перевірки перед злиттям або дебагу проблем."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "48. How can you view the changes introduced by a specific commit in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "View full commit changes:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Short summary view:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --stat <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "View changes of a specific file in a commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash> -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This is used for analysis, reviewing changes before merging, or debugging issues."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "48. Jak sprawdzić zmiany wprowadzone przez konkretny commit w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wyświetlenie pełnych zmian commita:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wersja skrócona:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --stat <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podgląd zmian konkretnego pliku w commicie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash> -- <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenia te służą do analizy zmian, przeglądu przed scaleniem oraz debugowania."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 49,
    "translations": {
      "uk": {
        "question": "49. Як переглянути список файлів, змінених у конкретному коміті Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Використовують команду git show з параметром " },
                  { "text": "--name-only", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-only <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Показує лише імена файлів без відображення diff." }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Або використати " },
                  { "text": "--name-status", "code": true },
                  {
                    "text": " для перегляду статусу змін (додано, змінено, видалено):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-status <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Для перегляду diff разом зі списком файлів:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Корисно для швидкого огляду змін у коміті без детального аналізу коду."
              }
            ]
          }
        ]
      },
      "en": {
        "question": "49. How can you view the list of files changed in a specific Git commit?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Use the git show command with the " },
                  { "text": "--name-only", "code": true },
                  { "text": " option:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-only <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This displays only the file names without showing the diff."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Or use " },
                  { "text": "--name-status", "code": true },
                  {
                    "text": " to see file change statuses (added, modified, deleted):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-status <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "To view both file list and diff:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This is useful for quickly reviewing what changed in a commit without analyzing the full diff."
              }
            ]
          }
        ]
      },
      "pl": {
        "question": "49. Jak wyświetlić listę plików zmienionych w konkretnym commicie Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Użyj polecenia git show z opcją " },
                  { "text": "--name-only", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-only <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Wyświetla tylko nazwy plików bez diffów." }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Można też użyć " },
                  { "text": "--name-status", "code": true },
                  {
                    "text": ", aby zobaczyć status zmian (dodany, zmodyfikowany, usunięty):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show --name-status <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Aby zobaczyć listę plików razem z diffem:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git show <commit_hash>"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Przydatne do szybkiego sprawdzenia, co zostało zmienione w danym commicie."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 50,
    "translations": {
      "uk": {
        "question": "50. Що робить команда git blame у Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Команда " },
              { "text": "git blame <file>", "code": true },
              {
                "text": " показує, хто і коли вніс кожен рядок у вказаному файлі."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Для кожного рядка відображається коміт, автор і дата змін."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Допомагає швидко знайти відповідального за зміну або зрозуміти історію конкретного рядка коду."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git blame app.js\ngit blame -L 10,20 app.js   # лише рядки з 10 по 20"
          }
        ]
      },
      "en": {
        "question": "50. What does the git blame command do in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "The " },
              { "text": "git blame <file>", "code": true },
              {
                "text": " command shows who and when modified each line in a file."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "For each line, it displays the commit hash, author, and date."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Helps quickly identify who introduced a change or understand the history of a specific line of code."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git blame app.js\ngit blame -L 10,20 app.js   # show only lines 10 to 20"
          }
        ]
      },
      "pl": {
        "question": "50. Co robi polecenie git blame w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Polecenie " },
              { "text": "git blame <file>", "code": true },
              {
                "text": " pokazuje, kto i kiedy zmodyfikował każdą linię w pliku."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Dla każdej linii wyświetlany jest commit, autor i data."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Pomaga szybko znaleźć osobę odpowiedzialną za zmianę lub zrozumieć historię konkretnej linii kodu."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git blame app.js\ngit blame -L 10,20 app.js   # tylko linie od 10 do 20"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 51,
    "translations": {
      "uk": {
        "question": "51. Що таке теги в Git і чим вони відрізняються від гілок?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Тег", "bold": true },
              {
                "text": " - це фіксована позначка на конкретному коміті, зазвичай для позначення релізів (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Гілка", "bold": true },
              {
                "text": " - це рухомий вказівник на останній коміт у лінії розробки, куди постійно додаються нові коміти."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні відмінності:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Характеристика" }],
              [{ "text": "Тег" }],
              [{ "text": "Гілка" }]
            ],
            "rows": [
              [
                [{ "text": "Рухливість" }],
                [{ "text": "Нерухомий" }],
                [{ "text": "Рухливий" }]
              ],
              [
                [{ "text": "Призначення" }],
                [{ "text": "Позначення релізів" }],
                [{ "text": "Активна розробка" }]
              ],
              [
                [{ "text": "Нові коміти" }],
                [{ "text": "Не додаються" }],
                [{ "text": "Додаються постійно" }]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад створення тега:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git tag v1.0\ngit push origin v1.0"
          }
        ]
      },
      "en": {
        "question": "51. What are tags in Git and how do they differ from branches?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "A tag", "bold": true },
              {
                "text": " is a fixed reference to a specific commit, commonly used to mark releases (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "A branch", "bold": true },
              {
                "text": " is a movable pointer to the latest commit in a line of development, where new commits are continuously added."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key differences:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Characteristic" }],
              [{ "text": "Tag" }],
              [{ "text": "Branch" }]
            ],
            "rows": [
              [
                [{ "text": "Movability" }],
                [{ "text": "Immutable" }],
                [{ "text": "Movable" }]
              ],
              [
                [{ "text": "Purpose" }],
                [{ "text": "Release marking" }],
                [{ "text": "Active development" }]
              ],
              [
                [{ "text": "New commits" }],
                [{ "text": "Not added" }],
                [{ "text": "Added continuously" }]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example of creating a tag:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git tag v1.0\ngit push origin v1.0"
          }
        ]
      },
      "pl": {
        "question": "51. Czym są tagi w Git i czym różnią się od gałęzi?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Tag", "bold": true },
              {
                "text": " to stałe oznaczenie konkretnego commita, zwykle używane do oznaczania wydań (v1.0, v2.1)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Gałąź", "bold": true },
              {
                "text": " to ruchomy wskaźnik na ostatni commit w linii rozwoju, do którego stale dodawane są nowe commity."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne różnice:" }]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "Cecha" }],
              [{ "text": "Tag" }],
              [{ "text": "Gałąź" }]
            ],
            "rows": [
              [
                [{ "text": "Ruchomość" }],
                [{ "text": "Nieruchomy" }],
                [{ "text": "Ruchomy" }]
              ],
              [
                [{ "text": "Zastosowanie" }],
                [{ "text": "Oznaczanie wydań" }],
                [{ "text": "Aktywny rozwój" }]
              ],
              [
                [{ "text": "Nowe commity" }],
                [{ "text": "Nie są dodawane" }],
                [{ "text": "Są dodawane" }]
              ]
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład tworzenia taga:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git tag v1.0\ngit push origin v1.0"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 52,
    "translations": {
      "uk": {
        "question": "52. Як у Git створювати, видаляти та пушити теги?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Створення тегів:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight тег:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated тег (з повідомленням):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0 -m \"Release version 1.0\""
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Видалення тегів:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Локально:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -d v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Віддалено:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --delete v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Надсилання тегів на remote:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Один тег:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Всі теги:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --tags"
                  }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "52. How do you create, delete, and push tags in Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Creating tags:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lightweight tag:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Annotated tag (with message):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0 -m \"Release version 1.0\""
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Deleting tags:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Locally:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -d v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Remotely:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --delete v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Pushing tags to remote:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Single tag:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "All tags:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --tags"
                  }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "52. Jak w Git tworzyć, usuwać i wysyłać tagi?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tworzenie tagów:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lekki tag (lightweight):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tag opisowy (annotated):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0 -m \"Release version 1.0\""
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usuwanie tagów:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Lokalnie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -d v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zdalnie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --delete v1.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wysyłanie tagów na remote:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Pojedynczy tag:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wszystkie tagi:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --tags"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 53,
    "translations": {
      "uk": {
        "question": "53. Що таке семантичне версіонування і як його використовують у Git-тегах?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Семантичне версіонування (SemVer) - це система нумерації версій у форматі "
              },
              {
                "text": "MAJOR.MINOR.PATCH",
                "code": true
              },
              {
                "text": ", яка відображає характер змін у релізі:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "MAJOR", "code": true },
                  { "text": " - несумісні зміни API." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MINOR", "code": true },
                  { "text": " - новий функціонал без порушення сумісності." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PATCH", "code": true },
                  { "text": " - виправлення багів без зміни функціоналу." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "У Git-тегах SemVer використовують для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначення релізів (наприклад v1.2.3)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Розуміння стабільності та сумісності версій." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Автоматизації CI/CD деплою за тегами." }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "53. What is semantic versioning and how is it used in Git tags?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Semantic Versioning (SemVer) is a versioning scheme using the format "
              },
              {
                "text": "MAJOR.MINOR.PATCH",
                "code": true
              },
              {
                "text": " to communicate the type of changes in a release:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "MAJOR", "code": true },
                  { "text": " - incompatible API changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MINOR", "code": true },
                  { "text": " - backward-compatible new features." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PATCH", "code": true },
                  { "text": " - backward-compatible bug fixes." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "In Git tags, SemVer is used to:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Mark releases (e.g. v1.2.3)." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Clearly indicate compatibility and stability." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Trigger CI/CD pipelines based on version tags." }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "53. Czym jest wersjonowanie semantyczne i jak jest używane w tagach Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wersjonowanie semantyczne (SemVer) to system numerowania wersji w formacie "
              },
              {
                "text": "MAJOR.MINOR.PATCH",
                "code": true
              },
              {
                "text": ", który opisuje charakter zmian w wydaniu:"
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "MAJOR", "code": true },
                  { "text": " - niekompatybilne zmiany API." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "MINOR", "code": true },
                  { "text": " - nowe funkcje zachowujące kompatybilność." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "PATCH", "code": true },
                  { "text": " - poprawki błędów bez zmiany funkcjonalności." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "W tagach Git SemVer służy do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Oznaczania wydań (np. v1.2.3)." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Łatwego określenia stabilności i kompatybilności."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Integracji z CI/CD do automatycznych wdrożeń." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 54,
    "translations": {
      "uk": {
        "question": "54. Як у Git перейти на конкретний тег?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Теги не є гілками, тому перехід на тег переводить репозиторій у стан "
              },
              {
                "text": "detached HEAD",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout v1.0"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Або з використанням сучасного синтаксису:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git switch --detach v1.0"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "У цьому режимі можна переглядати, збирати або тестувати код, але нові коміти не будуть прив’язані до жодної гілки."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Щоб продовжити роботу з тегу як із гілки:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b release-1.0 v1.0"
          }
        ]
      },

      "en": {
        "question": "54. How can you switch to a specific tag in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tags are not branches, so checking out a tag puts the repository into a "
              },
              {
                "text": "detached HEAD",
                "code": true
              },
              {
                "text": " state."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout v1.0"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Or using the newer syntax:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git switch --detach v1.0"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In this mode you can inspect, build, or test the code, but new commits will not belong to any branch."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "To continue working from a tag as a branch:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b release-1.0 v1.0"
          }
        ]
      },

      "pl": {
        "question": "54. Jak przełączyć się na konkretny tag w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tagi nie są gałęziami, dlatego przejście na tag powoduje stan "
              },
              {
                "text": "detached HEAD",
                "code": true
              },
              {
                "text": "."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout v1.0"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Lub z użyciem nowszej składni:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git switch --detach v1.0"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W tym trybie można przeglądać, budować lub testować kod, ale nowe commity nie będą przypisane do żadnej gałęzi."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Aby kontynuować pracę z tagu jako z gałęzi:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout -b release-1.0 v1.0"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 55,
    "translations": {
      "uk": {
        "question": "55. Як у Git створити реліз на основі тегу?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Створити тег на потрібному коміті:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0.0 -m \"Release 1.0.0\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Надіслати тег у віддалений репозиторій:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Або надіслати всі теги одразу:"
              },
              {
                "type": "code",
                "language": "bash",
                "content": "git push origin --tags"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "У системі керування кодом (GitHub / GitLab / Bitbucket) створити реліз на основі тега:"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "GitHub: вкладка " },
                          { "text": "Releases", "code": true },
                          { "text": " → Draft a new release → вибрати тег." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Додати опис змін (changelog)." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Опублікувати реліз." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Релізи на основі тегів зручні для CI/CD - можна автоматично запускати збірку та деплой при появі нового тега."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "55. How can you create a release from a tag in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Create a tag on the desired commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0.0 -m \"Release 1.0.0\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Push the tag to the remote repository:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Or push all tags at once:" },
              {
                "type": "code",
                "language": "bash",
                "content": "git push origin --tags"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "In a code hosting platform (GitHub / GitLab / Bitbucket), create a release based on the tag:"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "GitHub: go to " },
                          { "text": "Releases", "code": true },
                          { "text": " → Draft a new release → select the tag." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Add release notes or a changelog." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Publish the release." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tag-based releases work well with CI/CD pipelines, enabling automated builds and deployments triggered by version tags."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "55. Jak utworzyć release na podstawie taga w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Utworzyć tag na odpowiednim commicie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git tag -a v1.0.0 -m \"Release 1.0.0\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wysłać tag do zdalnego repozytorium:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin v1.0.0"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Lub wysłać wszystkie tagi jednocześnie:" },
              {
                "type": "code",
                "language": "bash",
                "content": "git push origin --tags"
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "W systemie hostującym kod (GitHub / GitLab / Bitbucket) utworzyć release na podstawie taga:"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "GitHub: zakładka " },
                          { "text": "Releases", "code": true },
                          { "text": " → Draft a new release → wybrać tag." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Dodać opis zmian (changelog)." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Opublikować release." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Release’y oparte na tagach są wygodne w CI/CD - pozwalają automatycznie uruchamiać buildy i wdrożenia."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 56,
    "translations": {
      "uk": {
        "question": "56. Що таке Git submodule і в яких випадках його доцільно використовувати?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git submodule", "bold": true },
              {
                "text": " - це механізм, що дозволяє вбудовувати один Git-репозиторій в інший як залежність. Основний репозиторій зберігає посилання на конкретний коміт підмодуля."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується, коли:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Є спільна бібліотека або модуль, що використовується в кількох проєктах."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Потрібно зафіксувати залежність на конкретному коміті, а не на останній версії."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Потрібно уникнути дублювання коду між репозиторіями."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад додавання підмодуля:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git submodule add https://github.com/example/lib.git libs/lib\ngit submodule update --init --recursive"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Складніший workflow: підмодулі потрібно оновлювати вручну, а при клонуванні репозиторію слід використовувати прапорець --recursive."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "56. What is a Git submodule and when should it be used?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git submodule", "bold": true },
              {
                "text": " is a mechanism that allows you to embed one Git repository inside another as a dependency. The parent repository stores a reference to a specific commit of the submodule."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "It is useful when:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You have a shared library or module used across multiple projects."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You need to lock a dependency to a specific commit rather than the latest version."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "You want to avoid copying code between repositories."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example of adding a submodule:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git submodule add https://github.com/example/lib.git libs/lib\ngit submodule update --init --recursive"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Drawbacks:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Submodules introduce a more complex workflow: updates must be done manually, and repositories should be cloned using the --recursive flag."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "56. Czym jest Git submodule i kiedy warto go używać?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git submodule", "bold": true },
              {
                "text": " to mechanizm pozwalający osadzić jedno repozytorium Git w innym jako zależność. Repozytorium nadrzędne przechowuje odwołanie do konkretnego commita podmodułu."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Stosuje się, gdy:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Istnieje wspólna biblioteka lub moduł używany w wielu projektach."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Trzeba przypiąć zależność do konkretnego commita, a nie do najnowszej wersji."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Chce się uniknąć kopiowania kodu między repozytoriami."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład dodania podmodułu:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git submodule add https://github.com/example/lib.git libs/lib\ngit submodule update --init --recursive"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Bardziej złożony workflow - podmoduły trzeba aktualizować ręcznie, a klonowanie repozytorium wymaga użycia opcji --recursive."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 57,
    "translations": {
      "uk": {
        "question": "57. Що таке Git hooks і для чого вони потрібні?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git hooks", "bold": true },
              {
                "text": " - це скрипти, які автоматично виконуються при певних подіях у Git-репозиторії (наприклад, перед комітом, перед пушем або після злиття). Вони зберігаються в каталозі "
              },
              { "text": ".git/hooks", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовуються для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Перевірки стилю коду або запуску лінтерів перед комітом ("
                  },
                  { "text": "pre-commit", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Заборони прямого пушу в " },
                  { "text": "main", "code": true },
                  { "text": " (" },
                  { "text": "pre-push", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Автоматичного оновлення залежностей або документації після злиття ("
                  },
                  { "text": "post-merge", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Генерації changelog або перевірки повідомлень комітів."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Приклад pre-commit hook для перевірки ESLint:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "#!/bin/sh\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"Lint errors found. Commit aborted.\"\n  exit 1\nfi"
          }
        ]
      },

      "en": {
        "question": "57. What are Git hooks and what are they used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git hooks", "bold": true },
              {
                "text": " are scripts that automatically run on specific Git events (such as before a commit, before a push, or after a merge). They are stored in the "
              },
              { "text": ".git/hooks", "code": true },
              { "text": " directory." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "They are commonly used to:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Run linters or code style checks before committing ("
                  },
                  { "text": "pre-commit", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Prevent direct pushes to " },
                  { "text": "main", "code": true },
                  { "text": " (" },
                  { "text": "pre-push", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Automatically update dependencies or documentation after merges ("
                  },
                  { "text": "post-merge", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Generate changelogs or validate commit messages." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example of a pre-commit hook for ESLint:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "#!/bin/sh\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"Lint errors found. Commit aborted.\"\n  exit 1\nfi"
          }
        ]
      },

      "pl": {
        "question": "57. Czym są Git hooks i do czego służą?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git hooks", "bold": true },
              {
                "text": " to skrypty uruchamiane automatycznie przy określonych zdarzeniach w repozytorium Git (np. przed commitem, przed pushem lub po merge). Znajdują się w katalogu "
              },
              { "text": ".git/hooks", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Są wykorzystywane do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Uruchamiania linterów lub sprawdzania stylu kodu przed commitem ("
                  },
                  { "text": "pre-commit", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Blokowania bezpośredniego pusha do " },
                  { "text": "main", "code": true },
                  { "text": " (" },
                  { "text": "pre-push", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Automatycznego aktualizowania zależności lub dokumentacji po merge ("
                  },
                  { "text": "post-merge", "code": true },
                  { "text": ")." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Generowania changelogów lub walidacji wiadomości commitów."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykład hooka pre-commit dla ESLint:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "#!/bin/sh\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"Lint errors found. Commit aborted.\"\n  exit 1\nfi"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 58,
    "translations": {
      "uk": {
        "question": "58. Як у Git об’єднати кілька комітів у один (squash)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Squash", "bold": true },
              {
                "text": " - це об’єднання кількох комітів у один. Найчастіше використовується перед злиттям гілки в "
              },
              { "text": "main", "code": true },
              { "text": " або " },
              { "text": "develop", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основний спосіб - interactive rebase:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rebase -i HEAD~N"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "де " },
              { "text": "N", "code": true },
              {
                "text": " - кількість останніх комітів, які потрібно об’єднати."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "У відкритому редакторі:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перший коміт залишаєш як " },
                  { "text": "pick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Для наступних змінюєш " },
                  { "text": "pick", "code": true },
                  { "text": " на " },
                  { "text": "squash (s)", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Після збереження Git об’єднає коміти та запропонує відредагувати фінальне повідомлення."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Коли використовують squash:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Очищення історії перед merge." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Формування зрозумілого changelog." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Приховування дрібних або проміжних комітів." }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "58. How can you squash multiple commits into one in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Squash", "bold": true },
              {
                "text": " means combining several commits into a single one. It is commonly used before merging a branch into "
              },
              { "text": "main", "code": true },
              { "text": " or " },
              { "text": "develop", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "The main approach is interactive rebase:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rebase -i HEAD~N"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "where " },
              { "text": "N", "code": true },
              {
                "text": " is the number of recent commits you want to combine."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "In the editor:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Keep the first commit as " },
                  { "text": "pick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Change the following commits from " },
                  { "text": "pick", "code": true },
                  { "text": " to " },
                  { "text": "squash (s)", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "After saving, Git will combine the commits and prompt you to edit the final commit message."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "When squash is used:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Cleaning up history before merging." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Creating a clear and readable changelog." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Hiding noisy or intermediate commits." }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "58. Jak w Git połączyć kilka commitów w jeden (squash)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Squash", "bold": true },
              {
                "text": " to połączenie kilku commitów w jeden. Najczęściej stosowane przed scaleniem gałęzi do "
              },
              { "text": "main", "code": true },
              { "text": " lub " },
              { "text": "develop", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Podstawowa metoda - interactive rebase:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rebase -i HEAD~N"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "gdzie " },
              { "text": "N", "code": true },
              { "text": " oznacza liczbę ostatnich commitów do połączenia." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "W edytorze:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Pierwszy commit zostawiasz jako " },
                  { "text": "pick", "code": true },
                  { "text": "." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dla kolejnych zmieniasz " },
                  { "text": "pick", "code": true },
                  { "text": " na " },
                  { "text": "squash (s)", "code": true },
                  { "text": "." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Po zapisaniu Git połączy commity i pozwoli edytować końcową wiadomość."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kiedy stosować squash:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Czyszczenie historii przed merge." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Tworzenie czytelnego changelogu." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ukrywanie drobnych commitów technicznych." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 59,
    "translations": {
      "uk": {
        "question": "59. Що таке git bisect і як із ним працювати?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git bisect", "code": true },
              {
                "text": " - це інструмент Git для бінарного пошуку коміту, який ввів баг. Він автоматично звужує діапазон між "
              },
              { "text": "good", "code": true },
              { "text": " і " },
              { "text": "bad", "code": true },
              { "text": " комітами." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основний workflow:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Запустити bisect:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect start"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити поточний стан як " },
                  { "text": "bad", "code": true },
                  { "text": " (баг присутній):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect bad"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вказати коміт, де все працювало:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git автоматично переключається на середній коміт. Ви тестуєте код і повідомляєте результат:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good   # якщо багу немає\ngit bisect bad    # якщо баг присутній"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Процес повторюється, доки Git не знайде проблемний коміт."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Завершити та повернутись у початковий стан:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect reset"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "git bisect особливо корисний у великих проєктах з довгою історією комітів, коли вручну знайти джерело багу складно."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "59. What is git bisect and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git bisect", "code": true },
              {
                "text": " is a Git tool for performing a binary search to find the commit that introduced a bug. It automatically narrows the range between "
              },
              { "text": "good", "code": true },
              { "text": " and " },
              { "text": "bad", "code": true },
              { "text": " commits." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Typical workflow:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Start bisect mode:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect start"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark the current commit as " },
                  { "text": "bad", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect bad"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Specify a known good commit:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git checks out a midpoint commit. You test it and report the result:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good   # bug not present\ngit bisect bad    # bug present"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The process repeats until the faulty commit is identified."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Exit bisect mode and return to the original state:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect reset"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "git bisect is especially useful in large projects with long histories where manual debugging would be too slow."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "59. Czym jest git bisect i jak z niego korzystać?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git bisect", "code": true },
              {
                "text": " to narzędzie Git do wyszukiwania commitów metodą binarną w celu znalezienia tego, który wprowadził błąd. Automatycznie zawęża zakres między "
              },
              { "text": "good", "code": true },
              { "text": " a " },
              { "text": "bad", "code": true },
              { "text": " commitami." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Typowy workflow:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Uruchomić tryb bisect:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect start"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć bieżący commit jako " },
                  { "text": "bad", "code": true },
                  { "text": ":" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect bad"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wskazać commit, w którym wszystko działało poprawnie:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good <commit_hash>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git przełącza się na commit pośredni. Testujesz i zgłaszasz wynik:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect good   # błąd nie występuje\ngit bisect bad    # błąd występuje"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Proces trwa do momentu znalezienia problematycznego commita."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zakończyć bisect i wrócić do poprzedniego stanu:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git bisect reset"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "git bisect jest bardzo przydatny w dużych projektach z długą historią commitów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 60,
    "translations": {
      "uk": {
        "question": "60. Як вручну вирішити конфлікт при злитті в Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Merge conflict виникає, коли Git не може автоматично об’єднати зміни з двох гілок. У такому випадку конфлікт потрібно вирішити вручну."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Кроки вирішення:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Запустити злиття гілок:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git зупиниться та повідомить про файли з конфліктами."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Відкрити конфліктні файли - вони міститимуть маркери:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "<<<<<<< HEAD\nкод з поточної гілки\n=======\nкод з feature-branch\n>>>>>>> feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Вибрати або об’єднати потрібні зміни вручну та видалити маркери конфлікту."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити файл як вирішений:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Завершити злиття:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Якщо merge-коміт не створився автоматично, його потрібно зробити вручну."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для зручності можна використовувати графічні інструменти злиття (VS Code, IntelliJ, Meld)."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "60. How can you manually resolve a merge conflict in Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A merge conflict occurs when Git cannot automatically combine changes from two branches. In this case, the conflict must be resolved manually."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Resolution steps:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Start the merge:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git stops and reports files with conflicts." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Open the conflicted files - they will contain conflict markers:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "<<<<<<< HEAD\ncode from current branch\n=======\ncode from feature-branch\n>>>>>>> feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Manually choose or merge the correct changes and remove the conflict markers."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark the conflict as resolved:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Finish the merge:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "If Git does not create the merge commit automatically, you need to commit it manually."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Graphical merge tools such as VS Code, IntelliJ, or Meld can simplify conflict resolution."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "60. Jak ręcznie rozwiązać konflikt scalania w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Konflikt scalania występuje, gdy Git nie może automatycznie połączyć zmian z dwóch gałęzi. Wtedy konflikt trzeba rozwiązać ręcznie."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kroki rozwiązania:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Rozpocząć scalanie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git merge feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git zatrzyma się i wskaże pliki z konfliktami." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Otworzyć pliki z konfliktami - zawierają znaczniki:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "<<<<<<< HEAD\nkod z bieżącej gałęzi\n=======\nkod z feature-branch\n>>>>>>> feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Ręcznie wybrać lub połączyć poprawne zmiany i usunąć znaczniki konfliktu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć konflikt jako rozwiązany:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zakończyć scalanie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Jeśli commit scalania nie został utworzony automatycznie, należy go wykonać ręcznie."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Graficzne narzędzia do scalania (VS Code, IntelliJ, Meld) znacznie ułatwiają pracę."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 61,
    "translations": {
      "uk": {
        "question": "61. Як налаштувати ім’я користувача та email у Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Для глобальних налаштувань (усі репозиторії):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global user.name \"Ваше Ім’я\"\ngit config --global user.email \"ваш@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Для конкретного репозиторію (тільки в поточному):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config user.name \"Ваше Ім’я\"\ngit config user.email \"ваш@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Перевірка налаштувань:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --list"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Email використовується для зв’язку комітів із профілем GitHub/GitLab."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "61. How do you configure user name and email in Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Global configuration (for all repositories):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global user.name \"Your Name\"\ngit config --global user.email \"your@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              {
                "text": "Repository-specific configuration (current repo only):"
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config user.name \"Your Name\"\ngit config user.email \"your@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Check configuration:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --list"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The email is used to associate commits with your GitHub or GitLab account."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "61. Jak skonfigurować nazwę użytkownika i email w Git?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Konfiguracja globalna (dla wszystkich repozytoriów):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global user.name \"Twoje Imię\"\ngit config --global user.email \"twoj@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Konfiguracja tylko dla bieżącego repozytorium:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config user.name \"Twoje Imię\"\ngit config user.email \"twoj@email.com\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Sprawdzenie ustawień:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --list"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Adres email służy do powiązania commitów z kontem GitHub lub GitLab."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 62,
    "translations": {
      "uk": {
        "question": "62. Які рівні конфігурації Git існують і яка їхня область дії?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git має три рівні конфігурації:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "System", "bold": true },
                  {
                    "text": " (/etc/gitconfig) - застосовується для всіх користувачів і всіх репозиторіїв на машині."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --system ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Global", "bold": true },
                  {
                    "text": " (~/.gitconfig або ~/.config/git/config) - застосовується для поточного користувача у всіх його репозиторіях."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Local", "bold": true },
                  {
                    "text": " (.git/config у репозиторії) - застосовується лише для конкретного репозиторію та має найвищий пріоритет."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config ..."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Пріоритет застосування:" }]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "local > global > system" }]
          }
        ]
      },

      "en": {
        "question": "62. What Git configuration levels exist and what is their scope?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git has three configuration levels:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "System", "bold": true },
                  {
                    "text": " (/etc/gitconfig) - applies to all users and all repositories on the machine."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --system ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Global", "bold": true },
                  {
                    "text": " (~/.gitconfig or ~/.config/git/config) - applies to the current user across all repositories."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Local", "bold": true },
                  {
                    "text": " (.git/config in a repository) - applies only to that repository and has the highest priority."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config ..."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Priority order:" }]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "local > global > system" }]
          }
        ]
      },

      "pl": {
        "question": "62. Jakie poziomy konfiguracji Git istnieją i jaki jest ich zakres?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git posiada trzy poziomy konfiguracji:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "System", "bold": true },
                  {
                    "text": " (/etc/gitconfig) - obowiązuje wszystkich użytkowników i wszystkie repozytoria na danej maszynie."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --system ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Global", "bold": true },
                  {
                    "text": " (~/.gitconfig lub ~/.config/git/config) - dotyczy bieżącego użytkownika we wszystkich jego repozytoriach."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global ..."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Local", "bold": true },
                  {
                    "text": " (.git/config w repozytorium) - dotyczy tylko jednego repozytorium i ma najwyższy priorytet."
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config ..."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kolejność priorytetów:" }]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "local > global > system" }]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 63,
    "translations": {
      "uk": {
        "question": "63. Як у Git створити alias (псевдонім) для команди?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Псевдоніми в Git дозволяють створювати короткі імена для часто використовуваних команд. Вони налаштовуються через "
              },
              { "text": "git config", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Приклади (глобально, для всіх репозиторіїв):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.cm \"commit -m\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Для конкретного репозиторію:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config alias.lg \"log --oneline --graph --all --decorate\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використання:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git st\ngit co main\ngit lg"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Псевдоніми зберігаються у файлах " },
              { "text": "~/.gitconfig", "code": true },
              { "text": " або " },
              { "text": ".git/config", "code": true },
              { "text": "." }
            ]
          }
        ]
      },

      "en": {
        "question": "63. How can you create an alias for a Git command?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git aliases allow you to create short names for frequently used commands. They are configured using "
              },
              { "text": "git config", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples (global, for all repositories):" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.cm \"commit -m\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "For a specific repository:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config alias.lg \"log --oneline --graph --all --decorate\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Usage:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git st\ngit co main\ngit lg"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Aliases are stored in " },
              { "text": "~/.gitconfig", "code": true },
              { "text": " or " },
              { "text": ".git/config", "code": true },
              { "text": "." }
            ]
          }
        ]
      },

      "pl": {
        "question": "63. Jak utworzyć alias (skrót) dla polecenia w Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Aliasy w Git pozwalają tworzyć krótkie nazwy dla często używanych poleceń. Konfiguruje się je za pomocą "
              },
              { "text": "git config", "code": true },
              { "text": "." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Przykłady (globalnie, dla wszystkich repozytoriów):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.cm \"commit -m\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dla konkretnego repozytorium:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git config alias.lg \"log --oneline --graph --all --decorate\""
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Użycie:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git st\ngit co main\ngit lg"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Aliasy są zapisywane w plikach " },
              { "text": "~/.gitconfig", "code": true },
              { "text": " lub " },
              { "text": ".git/config", "code": true },
              { "text": "." }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 64,
    "translations": {
      "uk": {
        "question": "64. Для чого використовується файл .gitignore у Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore", "code": true },
                  {
                    "text": " визначає, які файли й папки Git має ігнорувати - тобто не відстежувати і не додавати у коміти."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Використовується для:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "тимчасових файлів (логи, кеші, .DS_Store, thumbs.db);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "залежностей (node_modules/, vendor/);" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "згенерованих артефактів (build/, coverage-звіти);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "локальних конфігураційних файлів (наприклад, .env)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Важливо:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": ".gitignore не видаляє файли, які вже відстежуються Git. Він лише запобігає додаванню нових."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "64. What is the purpose of the .gitignore file in Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore", "code": true },
                  {
                    "text": " specifies which files and directories Git should ignore, meaning they are not tracked or committed."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Commonly used for:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "temporary files (logs, caches, .DS_Store, thumbs.db);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "dependencies (node_modules/, vendor/);" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "generated artifacts (build/, coverage reports);" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "local configuration files (e.g. .env)." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Important:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": ".gitignore does not remove files that are already tracked by Git. It only prevents new or untracked files from being added."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "64. Do czego służy plik .gitignore w Git?",
        "answerBlocks": [
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore", "code": true },
                  {
                    "text": " określa, które pliki i katalogi Git ma ignorować - czyli nie śledzić i nie dodawać do commitów."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Najczęściej używany do:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "plików tymczasowych (logi, cache, .DS_Store, thumbs.db);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "zależności (node_modules/, vendor/);" }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "wygenerowanych artefaktów (build/, raporty coverage);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "lokalnych plików konfiguracyjnych (np. .env)." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ważne:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": ".gitignore nie usuwa plików już śledzonych przez Git. Zapobiega jedynie dodawaniu nowych lub nieśledzonych plików."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 65,
    "translations": {
      "uk": {
        "question": "65. Як налаштувати глобальний .gitignore, щоб ігнорувати файли у всіх репозиторіях?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Створити глобальний файл, наприклад:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "touch ~/.gitignore_global"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Додати в нього правила (наприклад, IDE або системні файли):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": ".DS_Store\nThumbs.db\nnode_modules/\n*.log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Налаштувати Git використовувати цей файл:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global core.excludesfile ~/.gitignore_global"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Перевірити налаштування:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --list | grep excludesfile"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Після цього всі нові та існуючі репозиторії автоматично ігноруватимуть зазначені файли."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "65. How can you configure a global .gitignore to ignore files across all repositories?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Create a global ignore file, for example:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "touch ~/.gitignore_global"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Add ignore rules (e.g. IDE or system files):" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": ".DS_Store\nThumbs.db\nnode_modules/\n*.log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Configure Git to use this file:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global core.excludesfile ~/.gitignore_global"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Verify the configuration:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --list | grep excludesfile"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "After this, all repositories will automatically ignore the specified files."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "65. Jak skonfigurować globalny .gitignore, aby ignorować pliki we wszystkich repozytoriach?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Utworzyć globalny plik, na przykład:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "touch ~/.gitignore_global"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Dodać do niego reguły ignorowania (np. pliki IDE lub systemowe):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": ".DS_Store\nThumbs.db\nnode_modules/\n*.log"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Skonfigurować Git, aby używał tego pliku:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global core.excludesfile ~/.gitignore_global"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sprawdzić konfigurację:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --list | grep excludesfile"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Od tej pory wszystkie repozytoria będą automatycznie ignorować wskazane pliki."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 66,
    "translations": {
      "uk": {
        "question": "66. Як налаштувати Git для підпису комітів GPG-ключем?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Створити або переглянути GPG-ключі:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "gpg --full-generate-key\ngpg --list-secret-keys --keyid-format=long"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Скопіювати ідентифікатор ключа (GPG_KEY_ID) та вказати його Git:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global user.signingkey GPG_KEY_ID"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Увімкнути підпис усіх комітів за замовчуванням:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global commit.gpgsign true"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Або підписувати окремі коміти вручну:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -S -m \"Signed commit\""
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для GitHub або GitLab потрібно додати публічний ключ у налаштування акаунта."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "gpg --armor --export GPG_KEY_ID"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Перевірка підписів комітів:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git log --show-signature"
          }
        ]
      },

      "en": {
        "question": "66. How can you configure Git to sign commits with a GPG key?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Create or list your GPG keys:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "gpg --full-generate-key\ngpg --list-secret-keys --keyid-format=long"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Copy the key ID (GPG_KEY_ID) and configure Git to use it:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global user.signingkey GPG_KEY_ID"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Enable commit signing by default:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global commit.gpgsign true"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Or sign individual commits manually:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -S -m \"Signed commit\""
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "For GitHub or GitLab, add the public key to your account settings."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "gpg --armor --export GPG_KEY_ID"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Verify signed commits:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git log --show-signature"
          }
        ]
      },

      "pl": {
        "question": "66. Jak skonfigurować Git do podpisywania commitów kluczem GPG?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Utworzyć lub wyświetlić klucze GPG:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "gpg --full-generate-key\ngpg --list-secret-keys --keyid-format=long"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Skopiować identyfikator klucza (GPG_KEY_ID) i ustawić go w Git:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global user.signingkey GPG_KEY_ID"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Włączyć podpisywanie wszystkich commitów domyślnie:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config --global commit.gpgsign true"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Lub podpisywać pojedyncze commity ręcznie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit -S -m \"Signed commit\""
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W GitHub lub GitLab należy dodać klucz publiczny do ustawień konta."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "gpg --armor --export GPG_KEY_ID"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Sprawdzenie podpisów commitów:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git log --show-signature"
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 67,
    "translations": {
      "uk": {
        "question": "67. Які найпоширеніші практики безпеки при роботі з Git-репозиторіями?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "SSH-ключі замість паролів", "bold": true },
                  {
                    "text": " – для безпечної автентифікації з віддаленими репозиторіями."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GPG-підпис комітів", "bold": true },
                  { "text": " – підтвердження авторства і цілісності змін." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore для секретів", "bold": true },
                  {
                    "text": " – не зберігати .env, API-ключі, токени та паролі в репозиторії."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Сканування на секрети", "bold": true },
                  {
                    "text": " – використання інструментів на кшталт GitGuardian або TruffleHog перед пушем."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Обмеження доступу", "bold": true },
                  {
                    "text": " – мінімальні права доступу та захищені гілки (protected branches)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Pull Request review", "bold": true },
                  {
                    "text": " – зміни потрапляють у main лише після код-ревʼю."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Безпечне зберігання секретів у CI/CD",
                    "bold": true
                  },
                  {
                    "text": " – використання GitHub Actions Secrets, Vault тощо замість hardcode."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Регулярне оновлення залежностей", "bold": true },
                  { "text": " – зменшення ризику відомих вразливостей." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Головне правило безпеки: ніколи не зберігати секретні дані у відкритому вигляді в Git-репозиторії."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "67. What are the most common security best practices when working with Git repositories?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "SSH keys instead of passwords", "bold": true },
                  {
                    "text": " – for secure authentication with remote repositories."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GPG commit signing", "bold": true },
                  { "text": " – ensures commit authenticity and integrity." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore for secrets", "bold": true },
                  {
                    "text": " – never commit .env files, API keys, tokens, or passwords."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Secret scanning", "bold": true },
                  {
                    "text": " – using tools like GitGuardian or TruffleHog before pushing code."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Access control", "bold": true },
                  {
                    "text": " – least-privilege access and protected branches."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Pull request reviews", "bold": true },
                  { "text": " – code reaches main only after review." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Secure secrets management in CI/CD",
                    "bold": true
                  },
                  {
                    "text": " – use GitHub Actions Secrets, Vault, etc., instead of hardcoding."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Regular dependency updates", "bold": true },
                  { "text": " – to reduce known security vulnerabilities." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The golden rule: never store sensitive information in plain text inside a Git repository."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "67. Jakie są najczęstsze praktyki bezpieczeństwa podczas pracy z repozytoriami Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Klucze SSH zamiast haseł", "bold": true },
                  {
                    "text": " – bezpieczna autoryzacja z repozytoriami zdalnymi."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podpisywanie commitów GPG", "bold": true },
                  {
                    "text": " – potwierdzenie autorstwa i integralności zmian."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore dla sekretów", "bold": true },
                  {
                    "text": " – brak commitów z .env, kluczami API czy hasłami."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Skanowanie sekretów", "bold": true },
                  {
                    "text": " – użycie narzędzi takich jak GitGuardian lub TruffleHog."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontrola dostępu", "bold": true },
                  { "text": " – minimalne uprawnienia i chronione gałęzie." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Code review przez Pull Requesty", "bold": true },
                  {
                    "text": " – zmiany trafiają do main dopiero po zatwierdzeniu."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Bezpieczne przechowywanie sekretów w CI/CD",
                    "bold": true
                  },
                  {
                    "text": " – używanie GitHub Secrets lub Vault zamiast hardcode."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Regularne aktualizacje zależności", "bold": true },
                  { "text": " – ograniczenie znanych podatności." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Złota zasada: nigdy nie przechowuj wrażliwych danych w jawnym tekście w repozytorium Git."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 68,
    "translations": {
      "uk": {
        "question": "68. Які способи існують для зберігання конфіденційних даних у Git-репозиторії у зашифрованому вигляді?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git-crypt", "code": true },
                  {
                    "text": " – прозоре шифрування вибраних файлів у репозиторії. Дані розшифровуються лише для користувачів із відповідними ключами."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git-secret", "code": true },
                  {
                    "text": " – інструмент на базі GPG для шифрування файлів (.env, API-ключів, токенів) перед комітом."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SOPS (Mozilla)", "code": true },
                  {
                    "text": " – інструмент керування секретами з AES-шифруванням та інтеграцією з AWS KMS, GCP KMS, Azure Key Vault, HashiCorp Vault."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "BlackBox (StackExchange)", "code": true },
                  {
                    "text": " – система керування зашифрованими файлами в Git-репозиторіях на базі GPG."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зберігання секретів поза Git", "bold": true },
                  {
                    "text": " – використання менеджерів секретів (Vault, AWS Secrets Manager, Doppler, GitHub Actions Secrets), а в репозиторії зберігаються лише шаблони типу .env.example."
                  }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "68. What methods exist for storing sensitive data in a Git repository in an encrypted form?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git-crypt", "code": true },
                  {
                    "text": " – transparent encryption of selected files in a repository, decrypted only for users with access keys."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git-secret", "code": true },
                  {
                    "text": " – a GPG-based tool for encrypting sensitive files such as .env files and API keys."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SOPS (Mozilla)", "code": true },
                  {
                    "text": " – a secrets management tool using AES encryption with integrations for AWS KMS, GCP KMS, Azure Key Vault, and HashiCorp Vault."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "BlackBox (StackExchange)", "code": true },
                  {
                    "text": " – a system for managing encrypted files inside Git repositories using GPG."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Keeping secrets outside Git", "bold": true },
                  {
                    "text": " – using secret managers and keeping only templates like .env.example in the repository."
                  }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "68. Jakie sposoby istnieją do przechowywania poufnych danych w repozytorium Git w formie zaszyfrowanej?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git-crypt", "code": true },
                  {
                    "text": " – umożliwia przejrzyste szyfrowanie wybranych plików w repozytorium, odszyfrowywanych tylko dla użytkowników posiadających klucze."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git-secret", "code": true },
                  {
                    "text": " – narzędzie oparte na GPG do szyfrowania plików takich jak .env, klucze API i tokeny."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SOPS (Mozilla)", "code": true },
                  {
                    "text": " – narzędzie do zarządzania sekretami z szyfrowaniem AES oraz integracją z AWS KMS, GCP KMS, Azure Key Vault i HashiCorp Vault."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "BlackBox (StackExchange)", "code": true },
                  {
                    "text": " – system zarządzania zaszyfrowanymi plikami w repozytoriach Git, oparty na GPG."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przechowywanie sekretów poza Git", "bold": true },
                  {
                    "text": " – używanie menedżerów sekretów (Vault, AWS Secrets Manager, Doppler, GitHub Actions Secrets) i trzymanie w repozytorium jedynie szablonów typu .env.example."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 69,
    "translations": {
      "uk": {
        "question": "69. Які існують стратегії зберігання та керування обліковими даними (credentials) у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Credential helpers Git", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "cache", "code": true },
                          {
                            "text": " – тимчасове збереження облікових даних у пам’яті."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "store", "code": true },
                          {
                            "text": " – збереження у відкритому вигляді у файлі (небезпечний варіант)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "manager", "code": true },
                          { "text": " (Windows) або " },
                          { "text": "osxkeychain", "code": true },
                          {
                            "text": " (macOS) – інтеграція з системним менеджером паролів."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SSH-ключі", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Основний і найбезпечніший метод доступу до GitHub/GitLab."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Використання " },
                          { "text": "ssh-agent", "code": true },
                          { "text": " для зручності." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Персональні токени доступу (PAT)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Альтернатива паролям (наприклад, у GitHub)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Рекомендується зберігати через Credential Manager."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GPG-підпис комітів", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Використовується для підтвердження авторства, а не для автентифікації."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Secrets Manager", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "AWS Secrets Manager, Vault, Doppler – для CI/CD і автоматизації без хардкоду."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Найкраща практика: SSH-ключі для доступу + Credential Manager для зручності + Secrets Manager для CI/CD."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "69. What strategies exist for storing and managing credentials in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git credential helpers", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "cache", "code": true },
                          {
                            "text": " – temporarily stores credentials in memory."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "store", "code": true },
                          {
                            "text": " – stores credentials in plain text (not recommended)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "manager", "code": true },
                          { "text": " (Windows) or " },
                          { "text": "osxkeychain", "code": true },
                          {
                            "text": " (macOS) – integration with the OS keychain."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SSH keys", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "The most secure and recommended authentication method."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Using " },
                          { "text": "ssh-agent", "code": true },
                          { "text": " for convenience." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Personal Access Tokens (PAT)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "A secure alternative to passwords (e.g. on GitHub)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Should be stored via a credential manager."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GPG commit signing", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Used to verify authorship, not for authentication."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Secrets Managers", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "AWS Secrets Manager, Vault, Doppler – recommended for CI/CD pipelines."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Best practice: SSH keys for access, Credential Manager for usability, and Secrets Manager for CI/CD."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "69. Jakie strategie istnieją do przechowywania i zarządzania danymi uwierzytelniającymi (credentials) w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Credential helpers Git", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "cache", "code": true },
                          {
                            "text": " – tymczasowe przechowywanie danych w pamięci."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "store", "code": true },
                          {
                            "text": " – zapisywanie danych w postaci jawnej (niezalecane)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "manager", "code": true },
                          { "text": " (Windows) lub " },
                          { "text": "osxkeychain", "code": true },
                          {
                            "text": " (macOS) – integracja z systemowym menedżerem haseł."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Klucze SSH", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Najbezpieczniejsza i zalecana metoda dostępu do GitHub/GitLab."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Użycie " },
                          { "text": "ssh-agent", "code": true },
                          { "text": " dla wygody." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Personal Access Tokens (PAT)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Bezpieczna alternatywa dla haseł (np. w GitHub)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zaleca się przechowywanie ich w menedżerze poświadczeń."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podpisywanie commitów GPG", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Służy do potwierdzania autorstwa, a nie do logowania."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Menedżery sekretów", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "AWS Secrets Manager, Vault, Doppler – rekomendowane dla CI/CD."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Najlepsza praktyka: klucze SSH do dostępu, Credential Manager dla wygody oraz Secrets Manager dla CI/CD."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 70,
    "translations": {
      "uk": {
        "question": "70. Які способи є для скасування доступу користувачу до Git-репозиторію?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub / GitLab / Bitbucket", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Власник або адміністратор видаляє користувача зі списку collaborators або з команди/групи."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Можна знизити або повністю забрати права доступу (read/write → none)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SSH-ключі", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Видалити або відкликати публічний SSH-ключ користувача з налаштувань акаунта або сервера."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Персональні токени доступу (PAT)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Відкликати або видалити токени у налаштуваннях акаунта користувача."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CI/CD секрети", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Якщо користувач мав доступ до секретів (GitHub Actions, GitLab CI), їх потрібно оновити або перевипустити."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Загальний принцип: відкликати доступ на рівні платформи + знеактивувати всі ключі та токени."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "70. What are the ways to revoke a user's access to a Git repository?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub / GitLab / Bitbucket", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "The owner or administrator removes the user from collaborators or from a team/group."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Access permissions can be downgraded or fully revoked (read/write → none)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "SSH keys", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Remove or revoke the user's public SSH key from the account or server settings."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Personal Access Tokens (PAT)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Revoke or delete access tokens in the user's account settings."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CI/CD secrets", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "If the user had access to secrets (GitHub Actions, GitLab CI), they should be rotated or revoked."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "General rule: revoke platform access and invalidate all related keys and tokens."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "70. Jakie są sposoby odebrania użytkownikowi dostępu do repozytorium Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "GitHub / GitLab / Bitbucket", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Właściciel lub administrator usuwa użytkownika z collaborators lub z zespołu/grupy."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Można obniżyć lub całkowicie odebrać uprawnienia (read/write → none)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Klucze SSH", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Usunąć lub unieważnić publiczny klucz SSH użytkownika w ustawieniach konta lub serwera."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Personal Access Tokens (PAT)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Cofnąć lub usunąć tokeny dostępu w ustawieniach konta użytkownika."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sekrety CI/CD", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Jeśli użytkownik miał dostęp do sekretów (GitHub Actions, GitLab CI), należy je zmienić lub unieważnić."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zasada ogólna: odebrać dostęp na poziomie platformy oraz unieważnić wszystkie klucze i tokeny."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 71,
    "translations": {
      "uk": {
        "question": "71. Як у Git знайти та відновити файл, який був видалений?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо файл видалено лише локально (ще не закомічено):"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -- <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Якщо файл був видалений і вже закомічений:" }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Знайти коміт, у якому файл ще існував:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git log -- <file>"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Відновити файл з конкретного коміту:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout <commit_hash> -- <file>"
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Відновлення файлу з останнього коміту в поточній гілці:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git restore <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Порада:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Перед використанням checkout або restore переконайтесь, що у файлі немає незбережених змін, щоб уникнути їх втрати."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "71. How can you find and restore a file that was deleted in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If the file was deleted locally but not committed:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -- <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "If the file was deleted and committed:" }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Find the commit where the file still existed:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git log -- <file>"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Restore the file from that commit:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout <commit_hash> -- <file>"
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Restore the file from the latest commit on the current branch:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git restore <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tip:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Before using checkout or restore, make sure there are no uncommitted changes to avoid overwriting them."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "71. Jak w Git odnaleźć i przywrócić plik, który został usunięty?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli plik został usunięty lokalnie, ale nie został jeszcze zatwierdzony:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout -- <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli plik został usunięty i zapisany w commitcie:"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Znajdź commit, w którym plik jeszcze istniał:" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git log -- <file>"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Przywróć plik z wybranego commita:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git checkout <commit_hash> -- <file>"
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Przywrócenie pliku z ostatniego commita w bieżącej gałęzi:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git restore <file>"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wskazówka:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Przed użyciem checkout lub restore upewnij się, że nie ma niezapisanych zmian, aby ich nie nadpisać."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 72,
    "translations": {
      "uk": {
        "question": "72. Що робити, якщо випадково закомітити секретні дані у Git-репозиторій?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Негайно прибрати файл з індексу та заборонити подальше відстеження:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git rm --cached <file>\necho \"<file>\" >> .gitignore\ngit commit -m \"Remove sensitive file\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Якщо секретні дані вже були запушені на remote:" }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Повністю видалити файл з історії репозиторію за допомогою "
              },
              { "text": "git filter-repo", "code": true },
              { "text": " (або застарілого " },
              { "text": "git filter-branch", "code": true },
              { "text": "):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git filter-repo --path <file> --invert-paths"
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Переписати історію у віддаленому репозиторії:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Негайно оновити всі скомпрометовані дані:" }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Змінити паролі, API-ключі, токени доступу та інші секрети, оскільки вони вже могли бути скомпрометовані."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Порада:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Повідомити команду та перевірити форки або клони репозиторію, якщо секрети були публічно доступні."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "72. What should you do if you accidentally commit sensitive data to a Git repository?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Immediately remove the file from the index and prevent future tracking:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git rm --cached <file>\necho \"<file>\" >> .gitignore\ngit commit -m \"Remove sensitive file\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If the sensitive data was already pushed to a remote repository:"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Completely remove the file from Git history using " },
              { "text": "git filter-repo", "code": true },
              { "text": " (or the legacy " },
              { "text": "git filter-branch", "code": true },
              { "text": "):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git filter-repo --path <file> --invert-paths"
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Force-push the rewritten history to the remote repository:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Rotate all compromised credentials:" }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Change passwords, API keys, access tokens, and any other exposed secrets immediately."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tip:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Notify your team and check forks or clones if the secrets were publicly exposed."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "72. Co zrobić, jeśli przypadkowo zapiszesz poufne dane w repozytorium Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Natychmiast usuń plik z indeksu i zablokuj jego dalsze śledzenie:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git rm --cached <file>\necho \"<file>\" >> .gitignore\ngit commit -m \"Remove sensitive file\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli poufne dane zostały już wypchnięte do repozytorium zdalnego:"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Całkowicie usuń plik z historii repozytorium za pomocą "
              },
              { "text": "git filter-repo", "code": true },
              { "text": " (lub starszego " },
              { "text": "git filter-branch", "code": true },
              { "text": "):" }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git filter-repo --path <file> --invert-paths"
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wypchnij wymuszoną, przepisana historię do repozytorium zdalnego:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin --force"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zmień wszystkie skompromitowane dane uwierzytelniające:"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Natychmiast zmień hasła, klucze API, tokeny dostępu i inne poufne dane."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wskazówka:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Poinformuj zespół i sprawdź forki oraz klony repozytorium, jeśli dane były publicznie dostępne."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 73,
    "translations": {
      "uk": {
        "question": "73. Що таке detached HEAD у Git і як з ним працювати?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Що це таке:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "detached HEAD", "code": true },
                          {
                            "text": " - це стан, коли Git вказує безпосередньо на конкретний коміт або тег, а не на гілку."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Коміти, створені в цьому стані, не прив’язані до жодної гілки і можуть бути втрачені."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Як перейти в detached HEAD:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout <commit_hash>\ngit switch --detach <tag_name>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Робота у detached HEAD:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Можна змінювати код і створювати коміти." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Щоб зберегти коміти, потрібно створити нову гілку:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git checkout -b new-branch"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вихід без збереження комітів:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Detached HEAD зазвичай використовується для тестування старих комітів, перегляду тегів або експериментів без впливу на основну гілку."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "73. What is detached HEAD in Git and how do you work with it?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "What it is:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "detached HEAD", "code": true },
                          {
                            "text": " is a state where Git points directly to a specific commit or tag instead of a branch."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Commits created in this state are not attached to any branch and may be lost."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "How to enter detached HEAD:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout <commit_hash>\ngit switch --detach <tag_name>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Working in detached HEAD:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "You can modify code and create commits." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "To keep those commits, create a new branch:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git checkout -b new-branch"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Exit without keeping commits:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Detached HEAD is commonly used for testing old commits, inspecting tags, or experimenting without affecting the main branch."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "73. Czym jest detached HEAD w Git i jak z nim pracować?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Czym jest:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "detached HEAD", "code": true },
                          {
                            "text": " to stan, w którym Git wskazuje bezpośrednio na konkretny commit lub tag, a nie na gałąź."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Commity utworzone w tym stanie nie są przypisane do żadnej gałęzi i mogą zostać utracone."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jak przejść do detached HEAD:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout <commit_hash>\ngit switch --detach <tag_name>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Praca w detached HEAD:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Można modyfikować kod i tworzyć commity." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Aby zachować commity, należy utworzyć nową gałąź:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git checkout -b new-branch"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wyjście bez zachowania commitów:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout main"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Detached HEAD jest często używany do testowania starszych commitów, przeglądania tagów lub eksperymentów bez wpływu na główną gałąź."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 74,
    "translations": {
      "uk": {
        "question": "74. Як у Git відновити втрачений або випадково видалений stash?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Перевірити наявні stash:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git stash list"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відновити конкретний stash:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git stash apply stash@{n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Команда застосовує зміни, не видаляючи їх зі списку stash."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Якщо stash було випадково видалено (git stash drop або pop):"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Знайти commit, який зберіг stash:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fsck --no-reflogs | grep commit"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Застосувати його вручну:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply <commit_hash>"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Порада:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Видалений stash не зникає одразу - Git зберігає об’єкти до запуску garbage collector."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "74. How can you recover a lost or accidentally deleted stash in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Check existing stashes:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git stash list"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Restore a specific stash:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git stash apply stash@{n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "This applies the changes without removing them from the stash list."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "If the stash was accidentally dropped (git stash drop or pop):"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Find the commit that stored the stash:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fsck --no-reflogs | grep commit"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Apply it manually:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply <commit_hash>"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tip:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "A deleted stash is not immediately lost - Git keeps objects until garbage collection runs."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "74. Jak w Git odzyskać utracony lub przypadkowo usunięty stash?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Sprawdzić istniejące stash’e:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git stash list"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przywrócić konkretny stash:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git stash apply stash@{n}"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Polecenie stosuje zmiany bez usuwania ich z listy stash."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli stash został przypadkowo usunięty (git stash drop lub pop):"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Odnaleźć commit przechowujący stash:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git fsck --no-reflogs | grep commit"
          },
          {
            "type": "paragraph",
            "children": [{ "text": "Zastosować go ręcznie:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git stash apply <commit_hash>"
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wskazówka:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Usunięty stash nie znika od razu - Git przechowuje obiekty do momentu uruchomienia garbage collector."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 75,
    "translations": {
      "uk": {
        "question": "75. Як змінити повідомлення останнього коміту у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Якщо коміт ще не запушений на remote:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit --amend -m \"Нове повідомлення коміту\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Якщо коміт вже запушений:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Змінити повідомлення локально:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git commit --amend -m \"Нове повідомлення коміту\""
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Примусово оновити remote:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git push --force"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Порада:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Не використовуйте --force у спільних або захищених гілках (main, develop), щоб не порушити історію інших розробників."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "75. How can you change the message of the last commit in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "If the commit has not been pushed yet:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit --amend -m \"New commit message\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "If the commit has already been pushed:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Amend the commit locally:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git commit --amend -m \"New commit message\""
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Force-push the updated commit:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git push --force"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tip:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Avoid using --force on shared or protected branches (such as main or develop), as it can break history for other developers."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "75. Jak zmienić wiadomość ostatniego commita w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jeśli commit nie został jeszcze wypchnięty na remote:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit --amend -m \"Nowa wiadomość commita\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Jeśli commit został już wypchnięty:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Zmienić commit lokalnie:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git commit --amend -m \"Nowa wiadomość commita\""
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Wymusić aktualizację remote:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git push --force"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wskazówka:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Nie używaj --force na wspólnych lub chronionych gałęziach (main, develop), aby nie uszkodzić historii innych programistów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 76,
    "translations": {
      "uk": {
        "question": "76. Що таке Pull Request (PR) і як він працює у Git-платформах?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Pull Request", "bold": true },
              {
                "text": " - це запит на внесення змін з однієї гілки в іншу (зазвичай з feature-гілки у main або develop) через Git-платформи: GitHub, GitLab, Bitbucket."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Розробник створює окрему гілку та робить коміти." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Пушить гілку у віддалений репозиторій." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Створює Pull Request у веб-інтерфейсі, додає опис змін та рев’юверів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Команда проводить code review, залишає коментарі, запускається CI/CD."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Після схвалення PR зливається (merge) у цільову гілку."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги PR:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Контроль якості коду через code review." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Прозора історія обговорень та змін." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Автоматичні перевірки (тести, лінт, білд) через CI/CD."
                  }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "76. What is a Pull Request (PR) and how does it work on Git platforms?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Pull Request", "bold": true },
              {
                "text": " is a request to merge changes from one branch into another (usually from a feature branch into main or develop) using Git platforms such as GitHub, GitLab, or Bitbucket."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A developer creates a separate branch and makes commits."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "The branch is pushed to the remote repository." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "A Pull Request is created in the web interface with a description and reviewers."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The team reviews the code, leaves comments, and CI/CD checks are triggered."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After approval, the PR is merged into the target branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Benefits of PRs:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Improved code quality through code reviews." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Clear history of discussions and changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automated checks via CI/CD pipelines." }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "76. Czym jest Pull Request (PR) i jak działa na platformach Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Pull Request", "bold": true },
              {
                "text": " to prośba o połączenie zmian z jednej gałęzi do innej (najczęściej z gałęzi feature do main lub develop) za pomocą platform Git, takich jak GitHub, GitLab czy Bitbucket."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Programista tworzy osobną gałąź i wykonuje commity."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wypycha gałąź do zdalnego repozytorium." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Tworzy Pull Request w interfejsie webowym, dodając opis i recenzentów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zespół przeprowadza code review, dodaje komentarze i uruchamia się CI/CD."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po zatwierdzeniu PR jest scalany z gałęzią docelową."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety Pull Requestów:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontrola jakości kodu poprzez code review." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przejrzysta historia dyskusji i zmian." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatyczne testy i sprawdzenia dzięki CI/CD." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 77,
    "translations": {
      "uk": {
        "question": "77. Як внести зміни в уже відкритий Pull Request?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Перейти у гілку, на основі якої створено Pull Request:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Внести необхідні зміни та створити новий коміт:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\ngit commit -m \"Update changes for PR\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Запушити зміни у віддалений репозиторій:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature-branch"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Pull Request автоматично оновиться на платформі (GitHub, GitLab, Bitbucket) після пушу в ту саму гілку."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "77. How can you update an already opened Pull Request?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Switch to the branch used for the Pull Request:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Make the required changes and create a new commit:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\ngit commit -m \"Update changes for PR\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Push the changes to the remote repository:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature-branch"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "The Pull Request will be automatically updated on the platform (GitHub, GitLab, Bitbucket) after pushing to the same branch."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "77. Jak wprowadzić zmiany do już otwartego Pull Requesta?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Przejść do gałęzi, na podstawie której utworzono Pull Request:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wprowadzić wymagane zmiany i utworzyć nowy commit:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .\ngit commit -m \"Update changes for PR\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wypchnąć zmiany do zdalnego repozytorium:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature-branch"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Pull Request zostanie automatycznie zaktualizowany na platformie (GitHub, GitLab, Bitbucket) po wypchnięciu zmian do tej samej gałęzi."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 78,
    "translations": {
      "uk": {
        "question": "78. Що таке code review (перевірка коду) у контексті Git і як він працює?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Code review", "bold": true },
              {
                "text": " - це процес перевірки змін у коді іншими розробниками перед їх злиттям у основну гілку."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Зазвичай відбувається через " },
              { "text": "Pull Request", "bold": true },
              { "text": " (PR) у Git-платформах: GitHub, GitLab, Bitbucket." }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Розробник створює гілку та робить коміти." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Відкриває Pull Request із описом змін." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Рев’ювери перевіряють код (логіка, стиль, тести, безпека)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Залишають коментарі або запитують правки." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Після схвалення PR зливається в цільову гілку." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Покращення якості коду." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Раннє виявлення багів." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Обмін знаннями в команді." }]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "78. What is code review in the context of Git and how does it work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Code review", "bold": true },
              {
                "text": " is the process of reviewing code changes by other developers before merging them into the main branch."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "It is usually done via a " },
              { "text": "Pull Request", "bold": true },
              {
                "text": " (PR) on Git platforms such as GitHub, GitLab, or Bitbucket."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "A developer creates a branch and makes commits." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Opens a Pull Request with a description of the changes."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Reviewers check the code (logic, style, tests, security)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "They leave comments or request changes." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "After approval, the PR is merged into the target branch."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Benefits:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Improves code quality." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Catches bugs early." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Encourages knowledge sharing within the team." }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "78. Czym jest code review w kontekście Git i jak działa?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Code review", "bold": true },
              {
                "text": " to proces sprawdzania zmian w kodzie przez innych programistów przed scaleniem ich z główną gałęzią."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "Zwykle odbywa się za pomocą " },
              { "text": "Pull Requesta", "bold": true },
              {
                "text": " (PR) na platformach Git takich jak GitHub, GitLab czy Bitbucket."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Programista tworzy gałąź i wykonuje commity." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Otwiera Pull Request z opisem zmian." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Recenzenci sprawdzają kod (logika, styl, testy, bezpieczeństwo)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dodają komentarze lub proszą o poprawki." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Po zatwierdzeniu PR jest scalany z gałęzią docelową."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Poprawa jakości kodu." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Wczesne wykrywanie błędów." }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Lepsze dzielenie się wiedzą w zespole." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 79,
    "translations": {
      "uk": {
        "question": "79. Як вирішувати конфлікти в Pull Request перед злиттям у Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Виявити конфлікти:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "GitHub/GitLab позначає PR повідомленням "
                          },
                          {
                            "text": "“This branch has conflicts that must be resolved”",
                            "code": true
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оновити локальну feature-гілку від цільової:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature-branch\ngit fetch origin\ngit merge origin/main   # або target-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вирішити конфлікти вручну:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Відкрити файли з конфліктами та маркерами:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "<<<<<<< HEAD\nкод main\n=======\nкод feature-branch\n>>>>>>> feature-branch"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Об’єднати або вибрати потрібні зміни та видалити маркери."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Позначити файли як вирішені:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Завершити merge:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оновити Pull Request:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature-branch"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Порада: для зручності використовуйте візуальні merge-інструменти (VS Code, IntelliJ, Sourcetree)."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "79. How do you resolve conflicts in a Pull Request before merging in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Detect conflicts:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "GitHub/GitLab marks the PR with " },
                          {
                            "text": "\"This branch has conflicts that must be resolved\"",
                            "code": true
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Update the local feature branch from the target branch:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature-branch\ngit fetch origin\ngit merge origin/main   # or target-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Resolve conflicts manually:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Open files with conflict markers:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "<<<<<<< HEAD\ncode from main\n=======\ncode from feature-branch\n>>>>>>> feature-branch"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Choose or combine the correct changes and remove the markers."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mark conflicts as resolved:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Complete the merge:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Push updates to refresh the Pull Request:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature-branch"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Tip: visual merge tools (VS Code, IntelliJ, Sourcetree) make conflict resolution easier."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "79. Jak rozwiązywać konflikty w Pull Requeście przed scaleniem w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wykryć konflikty:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "GitHub/GitLab oznacza PR komunikatem " },
                          {
                            "text": "\"This branch has conflicts that must be resolved\"",
                            "code": true
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zaktualizować lokalną gałąź feature względem docelowej:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git checkout feature-branch\ngit fetch origin\ngit merge origin/main   # lub target-branch"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Rozwiązać konflikty ręcznie:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Otworzyć pliki z markerami konfliktów:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "<<<<<<< HEAD\nkod z main\n=======\nkod z feature-branch\n>>>>>>> feature-branch"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Wybrać lub połączyć poprawne zmiany i usunąć markery."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć pliki jako rozwiązane:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <file>"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zakończyć scalanie:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git commit"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wypchnąć zmiany, aby zaktualizować Pull Request:"
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git push origin feature-branch"
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Wskazówka: narzędzia wizualne (VS Code, IntelliJ, Sourcetree) znacznie ułatwiają rozwiązywanie konfliktów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 80,
    "translations": {
      "uk": {
        "question": "80. У чому різниця між git pull і комбінацією git fetch + git merge?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Завантажує зміни з віддаленого репозиторію в локальні remote-гілки, не змінюючи поточну гілку."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Дозволяє переглянути зміни перед їх інтеграцією."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge", "code": true },
                  { "text": " після fetch" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Локально об’єднує зміни з remote-гілки у поточну гілку."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Дає повний контроль над процесом злиття та вирішенням конфліктів."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Комбінує git fetch + git merge в одну команду."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Менш контрольований, оскільки злиття відбувається автоматично."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " - безпечніше та контрольованіше." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  { "text": " - швидко і зручно для простої синхронізації." }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "80. What is the difference between git pull and the combination of git fetch + git merge?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Downloads changes from the remote repository into local remote branches without modifying the current branch."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Allows you to review changes before integrating them."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge", "code": true },
                  { "text": " after fetch" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Merges the fetched changes into the current local branch."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Provides full control over the merge process and conflict resolution."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "A shortcut that performs git fetch followed by git merge."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Less controlled since the merge happens automatically."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Conclusion:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " - safer and more controlled." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  {
                    "text": " - faster and convenient for quick synchronization."
                  }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "80. Jaka jest różnica między git pull a kombinacją git fetch + git merge?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Pobiera zmiany z repozytorium zdalnego do lokalnych gałęzi remote bez modyfikowania bieżącej gałęzi."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Umożliwia przegląd zmian przed ich integracją."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git merge", "code": true },
                  { "text": " po fetch" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Scala pobrane zmiany z bieżącą gałęzią lokalną."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Daje pełną kontrolę nad procesem scalania i rozwiązywaniem konfliktów."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Skrót wykonujący git fetch oraz git merge w jednym kroku."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Mniej kontrolowany, ponieważ scalanie odbywa się automatycznie."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wniosek:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git fetch", "code": true },
                  { "text": " + " },
                  { "text": "git merge", "code": true },
                  { "text": " - bezpieczniejsze i bardziej kontrolowane." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "git pull", "code": true },
                  { "text": " - szybkie i wygodne do prostej synchronizacji." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 81,
    "translations": {
      "uk": {
        "question": "81. Які підходи використовують для роботи з великими файлами в Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git LFS (Large File Storage)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Зберігає великі файли (зображення, відео, бінарники) поза основним Git-репозиторієм."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "У Git зберігаються лише посилання, а самі файли - у спеціальному сховищі."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Ігнорування великих тимчасових або згенерованих файлів (node_modules, build-артефакти)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CI/CD артефакти", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Зберігання бінарних файлів у S3, Nexus, Artifactory замість Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Розділення репозиторіїв", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Винос великих ресурсів в окремі репозиторії або підмодулі."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для frontend-проєктів найчастіше використовують Git LFS для медіа або зовнішні сховища для build-артефактів."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "81. What approaches are used to work with large files in Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git LFS (Large File Storage)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Stores large files (images, videos, binaries) outside the main Git repository."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Only file references are kept in Git, while actual content is stored separately."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Ignore large generated or temporary files (node_modules, build artifacts)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CI/CD artifacts", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Store binaries in S3, Nexus, or Artifactory instead of Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Repository splitting", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Move large assets into separate repositories or submodules."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "For frontend projects, Git LFS is commonly used for media files, while build artifacts are stored externally."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "81. Jakie podejścia stosuje się do pracy z dużymi plikami w Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Git LFS (Large File Storage)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Przechowuje duże pliki (obrazy, wideo, pliki binarne) poza głównym repozytorium Git."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "W Git zapisywane są tylko referencje do plików."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": ".gitignore", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Ignorowanie dużych plików tymczasowych i generowanych (node_modules, artefakty builda)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Artefakty CI/CD", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Przechowywanie plików binarnych w S3, Nexus lub Artifactory zamiast w Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podział repozytorium", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Wydzielanie dużych zasobów do osobnych repozytoriów lub submodułów."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W projektach frontendowych najczęściej stosuje się Git LFS dla multimediów oraz zewnętrzne storage dla artefaktów builda."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 82,
    "translations": {
      "uk": {
        "question": "82. Які техніки можна застосувати для підвищення продуктивності при роботі з великим репозиторієм Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Shallow clone", "bold": true },
                  { "text": " (--depth)" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Завантаження лише останніх комітів для зменшення обсягу історії."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sparse checkout / Partial clone", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Клонування тільки потрібних директорій або файлів за допомогою git sparse-checkout."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git garbage collection (git gc)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Оптимізація та очищення Git-обʼєктів:" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git gc --aggressive --prune=now"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Розбиття монорепозиторію", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Використання submodules або subtree для ізоляції великих компонентів."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оптимальний .gitignore", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Зменшення кількості відстежуваних файлів."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git LFS", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Винесення великих медіа- та бінарних файлів з основної історії Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CI/CD кешування", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Використання кешів залежностей та Docker layer cache замість зберігання артефактів у Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "На практиці у CI часто комбінують shallow clone + sparse checkout для швидких білдів."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "82. What techniques can be used to improve performance when working with a large Git repository?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Shallow clone", "bold": true },
                  { "text": " (--depth)" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Fetch only recent commits to reduce repository history size."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sparse checkout / Partial clone", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Clone only required directories or files using git sparse-checkout."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git garbage collection (git gc)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Optimize and clean Git objects:" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git gc --aggressive --prune=now"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Monorepo splitting", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Use submodules or subtree to isolate large components."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optimized .gitignore", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Reduce the number of tracked files."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git LFS", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Move large media and binary files out of the main Git history."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CI/CD caching", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Use dependency caches and Docker layer caching instead of storing artifacts in Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In CI pipelines, shallow clone combined with sparse checkout is commonly used for faster builds."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "82. Jakie techniki można zastosować, aby poprawić wydajność pracy z dużym repozytorium Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Shallow clone", "bold": true },
                  { "text": " (--depth)" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Pobieranie tylko ostatnich commitów w celu zmniejszenia historii repozytorium."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Sparse checkout / Partial clone", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Klonowanie tylko wybranych katalogów lub plików przy użyciu git sparse-checkout."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git garbage collection (git gc)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Optymalizacja i czyszczenie obiektów Git:"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git gc --aggressive --prune=now"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Podział monorepo", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Użycie submodules lub subtree do izolowania dużych komponentów."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dobrze skonfigurowany .gitignore", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zmniejszenie liczby śledzonych plików."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git LFS", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Przeniesienie dużych plików multimedialnych i binarnych poza główną historię Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Cache w CI/CD", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Wykorzystywanie cache zależności i warstw Dockera zamiast przechowywania artefaktów w Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W praktyce w CI często łączy się shallow clone oraz sparse checkout w celu przyspieszenia buildów."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 83,
    "translations": {
      "uk": {
        "question": "83. Що таке shallow clone у Git і коли доцільно його застосовувати?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Shallow clone", "bold": true },
              {
                "text": " - це клонування Git-репозиторію з обмеженою історією комітів. Замість повної історії завантажується лише задана кількість останніх комітів."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone --depth <N> <repo-url>"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "де " },
              { "text": "<N>", "code": true },
              {
                "text": " - кількість останніх комітів, які потрібно завантажити."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "значно швидше клонування репозиторію;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "менший розмір локального репозиторію;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ідеально підходить для CI/CD, коли потрібен лише актуальний стан коду."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "обмежена історія комітів - неможливо аналізувати старі зміни;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ускладнена робота з rebase, bisect та пошуком у глибокій історії."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Shallow clone застосовують, коли потрібен лише поточний стан проєкту без повної історії - наприклад, для білдів і тестів у CI."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "83. What is a shallow clone in Git and when should it be used?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Shallow clone", "bold": true },
              {
                "text": " is a Git repository clone with a limited commit history. Instead of fetching the entire history, only the most recent commits are downloaded."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone --depth <N> <repo-url>"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "where " },
              { "text": "<N>", "code": true },
              {
                "text": " is the number of most recent commits to fetch."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "significantly faster cloning;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "smaller repository size;" }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ideal for CI/CD pipelines where only the latest code state is required."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Limitations:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "limited commit history - older changes cannot be fully analyzed;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "more difficult to use rebase, bisect, or deep history search."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Shallow clone is commonly used when only the current state of the project is needed, such as in CI builds or automated testing."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "83. Czym jest shallow clone w Git i kiedy warto go używać?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Shallow clone", "bold": true },
              {
                "text": " to klonowanie repozytorium Git z ograniczoną historią commitów. Zamiast pełnej historii pobierana jest tylko określona liczba ostatnich commitów."
              }
            ]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git clone --depth <N> <repo-url>"
          },
          {
            "type": "paragraph",
            "children": [
              { "text": "gdzie " },
              { "text": "<N>", "code": true },
              {
                "text": " oznacza liczbę ostatnich commitów do pobrania."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "znacznie szybsze klonowanie repozytorium;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "mniejszy rozmiar lokalnego repozytorium;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "idealne rozwiązanie dla CI/CD, gdy potrzebny jest tylko aktualny stan kodu."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ograniczona historia commitów - brak pełnego wglądu w stare zmiany;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "utrudniona praca z rebase, bisect oraz analizą głębokiej historii."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Shallow clone stosuje się, gdy potrzebny jest jedynie aktualny stan projektu - np. podczas buildów i testów w CI."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 84,
    "translations": {
      "uk": {
        "question": "84. Які підходи можна застосувати для зменшення розміру репозиторію Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Прибрати непотрібні файли з історії",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Використати git filter-repo (сучасна заміна git filter-branch):"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git filter-repo --path <file> --invert-paths"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Команда повністю видаляє файл з усієї історії репозиторію."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Винести великі файли з репозиторію",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Використовувати Git LFS для зберігання бінарників, зображень та відео."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Запустити очищення та оптимізацію Git",
                    "bold": true
                  },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git gc --aggressive --prune=now"
                  },
                  {
                    "type": "paragraph",
                    "children": [
                      {
                        "text": "Стискає об’єкти та видаляє непотрібні дані."
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Видалити застарілі гілки та теги", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Локально:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git branch -D <branch>"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Віддалено:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git push origin --delete <branch>"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Оптимізувати роботу в CI/CD", "bold": true },
                  {
                    "type": "paragraph",
                    "children": [
                      {
                        "text": "Використовувати shallow clone (--depth 1) для білдів замість повного репозиторію."
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "На практиці найефективніша стратегія - винесення великих файлів у Git LFS та очищення історії через git filter-repo."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "84. What approaches can be used to reduce the size of a Git repository?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Remove unnecessary files from history",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Use git filter-repo (modern replacement for git filter-branch):"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git filter-repo --path <file> --invert-paths"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "This removes the file from the entire repository history."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Move large files out of the repository",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Use Git LFS to store binaries, images, and media files."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Run Git garbage collection", "bold": true },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git gc --aggressive --prune=now"
                  },
                  {
                    "type": "paragraph",
                    "children": [
                      {
                        "text": "Compresses objects and removes unreachable data."
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Delete obsolete branches and tags", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Locally:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git branch -D <branch>"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Remotely:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git push origin --delete <branch>"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optimize CI/CD usage", "bold": true },
                  {
                    "type": "paragraph",
                    "children": [
                      {
                        "text": "Use shallow clone (--depth 1) in CI pipelines instead of cloning the full repository."
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In real-world projects, the most effective approach is combining Git LFS with history cleanup using git filter-repo."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "84. Jakie podejścia można zastosować, aby zmniejszyć rozmiar repozytorium Git?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Usunięcie niepotrzebnych plików z historii",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Użyć git filter-repo (nowoczesny zamiennik git filter-branch):"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git filter-repo --path <file> --invert-paths"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Polecenie usuwa plik z całej historii repozytorium."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wyniesienie dużych plików poza repozytorium",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Zastosować Git LFS do przechowywania binariów i multimediów."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Uruchomienie czyszczenia Git", "bold": true },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git gc --aggressive --prune=now"
                  },
                  {
                    "type": "paragraph",
                    "children": [
                      {
                        "text": "Kompresuje obiekty i usuwa nieużywane dane."
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Usunięcie starych gałęzi i tagów", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Lokalnie:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git branch -D <branch>"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Zdalnie:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git push origin --delete <branch>"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Optymalizacja CI/CD", "bold": true },
                  {
                    "type": "paragraph",
                    "children": [
                      {
                        "text": "Stosować shallow clone (--depth 1) w pipeline’ach zamiast pełnego klonowania."
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W praktyce najlepsze efekty daje połączenie Git LFS oraz czyszczenia historii za pomocą git filter-repo."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 85,
    "translations": {
      "uk": {
        "question": "85. Що таке Git LFS і як ним користуватись?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git LFS (Large File Storage)", "bold": true },
              {
                "text": " - це розширення Git для зберігання великих файлів (зображення, відео, бінарники) поза основною історією репозиторію. У Git зберігаються лише спеціальні посилання (пойнтери), а самі файли розміщуються у зовнішньому сховищі."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Установити Git LFS:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git lfs install"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Вказати типи файлів для зберігання в LFS:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git lfs track \"*.png\"\ngit lfs track \"*.mp4\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Додати та закомітити файли як звичайно:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .gitattributes image.png\ngit commit -m \"Add image with Git LFS\"\ngit push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "репозиторій не роздувається великими файлами;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "швидше клонування та робота з історією;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "зручно для мультимедіа та бінарних артефактів." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "потрібна підтримка Git LFS на стороні remote (GitHub, GitLab мають ліміти);"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "обмеження за трафіком і обсягом зберігання на безкоштовних тарифах."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git LFS доцільно використовувати, якщо в проєкті є великі файли, що часто змінюються."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "85. What is Git LFS and how do you use it?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git LFS (Large File Storage)", "bold": true },
              {
                "text": " is a Git extension designed to handle large files such as images, videos, and binaries outside the main repository history. Git stores lightweight pointer files, while the actual content is stored in a separate storage."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Install Git LFS:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git lfs install"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Track file types to be stored in LFS:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git lfs track \"*.png\"\ngit lfs track \"*.mp4\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Commit and push files as usual:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .gitattributes image.png\ngit commit -m \"Add image with Git LFS\"\ngit push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "repository size stays small;" }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "faster cloning and history operations;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "ideal for media and binary artifacts." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Drawbacks:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "requires Git LFS support on the remote side with usage limits;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "storage and bandwidth limits on free plans." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git LFS is recommended when a project contains large files that change frequently."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "85. Czym jest Git LFS i jak z niego korzystać?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git LFS (Large File Storage)", "bold": true },
              {
                "text": " to rozszerzenie Git przeznaczone do obsługi dużych plików, takich jak obrazy, wideo i pliki binarne, poza główną historią repozytorium. W repozytorium Git przechowywane są jedynie wskaźniki do tych plików."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Zainstalować Git LFS:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git lfs install"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Oznaczyć typy plików przechowywane w LFS:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git lfs track \"*.png\"\ngit lfs track \"*.mp4\""
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Dodać i zakomitować pliki:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add .gitattributes image.png\ngit commit -m \"Add image with Git LFS\"\ngit push origin main"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "repozytorium nie powiększa się przez duże pliki;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "szybsze klonowanie i praca z historią;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "idealne rozwiązanie dla multimediów i binariów." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "wymaga wsparcia Git LFS po stronie zdalnej i posiada limity;"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "ograniczenia transferu i przestrzeni na darmowych planach."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git LFS warto stosować w projektach z dużymi plikami często podlegającymi zmianom."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 86,
    "translations": {
      "uk": {
        "question": "86. Як Git інтегрується в CI/CD-процеси?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git є джерелом правди для коду, а CI/CD-системи (GitHub Actions, GitLab CI, Jenkins, Azure DevOps тощо) інтегруються з ним через події (hooks або webhooks)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Як це працює:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Push / Pull Request / Merge → тригер для CI/CD-пайплайну."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "CI/CD-система клонує або фетчить Git-репозиторій."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Виконуються автоматичні кроки: білд, тести, лінтинг, деплой."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Результати зберігаються: артефакти, логи, статуси, релізи."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади інтеграції:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Actions запускає workflow при подіях push або pull_request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitLab CI використовує файл .gitlab-ci.yml для опису пайплайнів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jenkins реагує на webhooks від GitHub/GitLab і запускає job-и."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові моменти:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git визначає, які зміни потрібно перевіряти та деплоїти."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git-теги часто використовують для запуску релізних пайплайнів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Стратегія гілок (Gitflow, trunk-based) напряму впливає на CI/CD."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Отже, Git відповідає за контроль версій і події, а CI/CD - за автоматизацію збірки, тестування та деплою."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "86. How does Git integrate with CI/CD processes?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git serves as the single source of truth for code, while CI/CD systems (GitHub Actions, GitLab CI, Jenkins, Azure DevOps, etc.) integrate with it through events such as hooks or webhooks."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "How it works:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Push / Pull Request / Merge events trigger CI/CD pipelines."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The CI/CD system clones or fetches the Git repository."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Automated steps are executed: build, tests, linting, deployment."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Artifacts, logs, statuses, and releases are generated and stored."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Integration examples:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Actions runs workflows on push and pull_request events."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitLab CI uses the .gitlab-ci.yml file to define pipelines."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jenkins listens to webhooks from GitHub/GitLab to trigger jobs."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key points:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git determines what changes should be built and deployed."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git tags are often used to trigger release pipelines."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Branching strategies (Gitflow, trunk-based) directly affect CI/CD design."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In short, Git provides version control and events, while CI/CD automates building, testing, and deployment."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "86. W jaki sposób Git integruje się z procesami CI/CD?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git jest głównym źródłem prawdy dla kodu, a systemy CI/CD (GitHub Actions, GitLab CI, Jenkins, Azure DevOps itd.) integrują się z nim za pomocą zdarzeń takich jak hooki lub webhooki."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Jak to działa:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zdarzenia Push / Pull Request / Merge uruchamiają pipeline CI/CD."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "System CI/CD klonuje lub pobiera repozytorium Git."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wykonywane są kroki automatyczne: build, testy, linting, deployment."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zapisywane są artefakty, logi, statusy oraz wydania (releases)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady integracji:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Actions uruchamia workflow przy zdarzeniach push i pull_request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitLab CI korzysta z pliku .gitlab-ci.yml do definiowania pipeline’ów."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Jenkins reaguje na webhooki z GitHub/GitLab i uruchamia zadania."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kluczowe aspekty:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git określa, które zmiany mają być budowane i wdrażane."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Tagi Git są często używane do uruchamiania pipeline’ów release."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Strategia gałęzi (Gitflow, trunk-based) wpływa na architekturę CI/CD."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Podsumowując: Git odpowiada za wersjonowanie i zdarzenia, a CI/CD za automatyzację budowania, testowania i wdrażania."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 87,
    "translations": {
      "uk": {
        "question": "87. Як налаштовується автоматизоване розгортання (deployment) з використанням Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Автоматизоване розгортання з використанням Git базується на інтеграції з CI/CD-системами та реакції на події в репозиторії (push, merge, теги)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові кроки:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Push або merge у визначену гілку (main, develop, release) → тригер CI/CD-пайплайну."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "CI/CD-система (GitHub Actions, GitLab CI, Jenkins, Azure DevOps):"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "клонує або фетчить репозиторій;" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "виконує білд проєкту (наприклад, npm install && npm run build);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "запускає тести та лінтери;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "створює артефакти (Docker-образ, build bundle)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Розгортання (deployment):" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "публікація артефактів або Docker-образів у реєстр (ECR, Docker Hub);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "деплой на інфраструктуру (Kubernetes, ECS, сервер через SSH, Vercel, Netlify)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Моніторинг і rollback: перевірка статусу деплою та можливість відкату на попередній тег або реліз."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git push origin main", "code": true },
                  {
                    "text": " → GitHub Actions запускає пайплайн і деплоїть застосунок (наприклад, на AWS або Vercel)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "git tag v1.0.0 && git push origin v1.0.0",
                    "code": true
                  },
                  {
                    "text": " → запускається релізний пайплайн з деплоєм у продакшн."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Основна ідея: Git відповідає за контроль версій і події, а CI/CD-пайплайни автоматично виконують білд, тести та розгортання."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "87. How is automated deployment configured using Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Automated deployment using Git is based on integration with CI/CD systems and reacting to repository events such as push, merge, or tags."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key steps:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Push or merge into a target branch (main, develop, release) triggers a CI/CD pipeline."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "The CI/CD system (GitHub Actions, GitLab CI, Jenkins, Azure DevOps):"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "clones or fetches the repository;" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "builds the project (e.g., npm install && npm run build);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "runs tests and linters;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "creates artifacts (Docker images, build bundles)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Deployment:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "pushes artifacts or Docker images to a registry (ECR, Docker Hub);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "deploys to infrastructure (Kubernetes, ECS, SSH servers, Vercel, Netlify)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Monitoring and rollback: tracking deployment status and reverting to a previous tag or release if needed."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In essence, Git acts as the trigger and version control system, while CI/CD pipelines automate build, test, and deployment processes."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "87. Jak konfiguruje się automatyczne wdrażanie (deployment) z użyciem Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Automatyczne wdrażanie z wykorzystaniem Git opiera się na integracji z systemami CI/CD oraz reagowaniu na zdarzenia w repozytorium (push, merge, tagi)."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne kroki:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Push lub merge do określonej gałęzi (main, develop, release) uruchamia pipeline CI/CD."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "System CI/CD (GitHub Actions, GitLab CI, Jenkins, Azure DevOps):"
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "klonuje lub pobiera repozytorium;" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "buduje projekt (np. npm install && npm run build);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "uruchamia testy i linters;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "tworzy artefakty (obrazy Docker, paczki build)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wdrażanie:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "publikacja artefaktów lub obrazów Docker w rejestrze (ECR, Docker Hub);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "wdrożenie na infrastrukturę (Kubernetes, ECS, serwery SSH, Vercel, Netlify)."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Monitoring i rollback: monitorowanie wdrożenia i możliwość cofnięcia do poprzedniego taga lub wydania."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Podsumowując: Git odpowiada za wersjonowanie i zdarzenia, a pipeline’y CI/CD automatyzują proces budowy, testów i wdrażania."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 88,
    "translations": {
      "uk": {
        "question": "88. Як налаштувати правила захисту гілок у Git, щоб інтегрувати їх із CI/CD?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Захищені гілки (наприклад, main або release) використовуються для того, щоб у продакшен не потрапили неякісні або неперевірені зміни."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Ключові правила захисту:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Заборона прямих push у гілку - всі зміни лише через Pull Request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Обов’язкове проходження CI/CD перед злиттям:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "успішний білд;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "успішні тести (green);" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "лінтери та форматтери без помилок." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Обов’язковий code review - мінімум 1–2 схвалення перед merge."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Актуальність гілки - PR має бути синхронізований з останнім main (без конфліктів)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Обов’язковий підпис комітів (GPG або SSO) для підвищення безпеки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Контроль історії - дозволити лише squash або rebase (без merge-комітів)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад (GitHub):" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Settings → Branches → Branch protection rules" }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Require pull request reviews" }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Require status checks to pass before merging (CI)"
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Require signed commits" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Require linear history" }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Результат: злиття і деплой можливі лише після успішного проходження CI/CD, що гарантує стабільність продакшену."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "88. How can branch protection rules be configured in Git to integrate with CI/CD?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Protected branches (such as main or release) ensure that untested or low-quality changes do not reach production."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key protection rules:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Disable direct pushes - all changes must go through Pull Requests."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Require CI/CD checks before merging:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "successful build;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "passing tests;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "linting and formatting checks." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mandatory code review - at least 1–2 approvals." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Branch must be up to date with the target branch (no conflicts)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Require signed commits (GPG or SSO) for security."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Enforce linear history (squash or rebase only)." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "As a result, deployments are triggered only after successful CI/CD validation, protecting production stability."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "88. Jak skonfigurować zasady ochrony gałęzi w Git, aby zintegrować je z CI/CD?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Chronione gałęzie (np. main lub release) zapobiegają trafieniu nieprzetestowanego kodu do środowiska produkcyjnego."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Kluczowe zasady ochrony:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Zakaz bezpośrednich pushy - zmiany tylko przez Pull Request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wymagane sprawdzenia CI/CD przed scaleniem:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "poprawny build;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "przechodzące testy;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "linting i formatowanie bez błędów." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Obowiązkowy code review - co najmniej 1–2 akceptacje."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Gałąź musi być aktualna względem main (bez konfliktów)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Wymagane podpisane commity (GPG/SSO)." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wymuszenie liniowej historii (squash lub rebase)."
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Efekt: wdrożenie następuje tylko po pomyślnym przejściu CI/CD, co zapewnia stabilność produkcji."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 89,
    "translations": {
      "uk": {
        "question": "89. Яку роль відіграють Git hooks (гачки) в автоматизації процесів?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git hooks - це скрипти, які автоматично виконуються при певних подіях Git (commit, push, merge тощо). Вони дозволяють автоматизувати перевірки та дії безпосередньо в процесі розробки."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні ролі в автоматизації:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Контроль якості коду перед комітом:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "запуск лінтерів (ESLint, Prettier);" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "перевірка форматування;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "блокування коміту з помилками." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Автоматичний запуск тестів:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "pre-push може запускати unit або integration тести, щоб не допустити пушу зламаного коду."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Підвищення безпеки:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "перевірка на наявність секретів (ключі, паролі);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "примусове підписання комітів." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Уніфікація процесів команди:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "перевірка commit message за Conventional Commits;"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "автогенерація changelog;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "оновлення документації." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "На практиці Git hooks часто керуються через інструменти Husky або lefthook для зручної інтеграції в командні проєкти."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "89. What role do Git hooks play in process automation?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git hooks are scripts that run automatically on specific Git events (commit, push, merge, etc.). They help automate checks and actions directly in the development workflow."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Key roles in automation:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Code quality enforcement before commit:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "run linters (ESLint, Prettier);" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "check formatting;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "block commits with errors." }]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automated test execution:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "pre-push hooks can run unit or integration tests to prevent broken code from being pushed."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Security enforcement:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "detect committed secrets (keys, passwords);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "enforce signed commits." }]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Process standardization across the team:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "validate commit messages (Conventional Commits);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "auto-generate changelogs;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "update documentation." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "In practice, tools like Husky or lefthook are commonly used to manage Git hooks in team projects."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "89. Jaką rolę odgrywają Git hooks w automatyzacji procesów?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git hooks to skrypty uruchamiane automatycznie przy określonych zdarzeniach Git (commit, push, merge itp.). Pozwalają automatyzować działania bezpośrednio w cyklu pracy programisty."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne role w automatyzacji:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Kontrola jakości kodu przed commitem:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "uruchamianie linterów (ESLint, Prettier);"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "sprawdzanie formatowania;" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "blokowanie commitów z błędami." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatyczne uruchamianie testów:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "hook pre-push może uruchamiać testy jednostkowe lub integracyjne."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zwiększenie bezpieczeństwa:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "wykrywanie sekretów w commitach;" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "wymuszanie podpisanych commitów." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ujednolicenie procesów zespołu:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "walidacja komunikatów commitów;" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "automatyczne generowanie changelogów;" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "aktualizacja dokumentacji." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "W praktyce Git hooks są często zarządzane za pomocą narzędzi takich jak Husky lub lefthook."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 90,
    "translations": {
      "uk": {
        "question": "90. Як Git використовується для відкату змін у разі невдалого деплою?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git робить rollback безпечним і контрольованим, оскільки кожен реліз базується на конкретному коміті або тегу. У разі невдалого деплою можна швидко повернутися до стабільного стану коду."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні підходи до відкату:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Повернення до стабільного тегу або коміту:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "переключення на попередній релізний тег:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git checkout v1.2.3"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "повторний деплой цього стану коду." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Використання git revert:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "створює новий коміт, який скасовує зміни проблемного коміту:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git revert <commit_hash>"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "безпечний варіант для main-гілки без переписування історії."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Rollback через CI/CD:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "деплой зазвичай відбувається з тегів або main;"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "можна автоматично redeploy попереднього тегу."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Blue-Green або Canary deployment:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Git виступає джерелом істини для версій коду;"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "відкат відбувається шляхом переключення трафіку на попередню версію."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Головна ідея: Git дозволяє миттєво відтворити будь-який попередній стан коду, що робить rollback швидким, передбачуваним і безпечним."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "90. How is Git used to roll back changes after a failed deployment?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git enables safe and predictable rollbacks because each release is tied to a specific commit or tag. In case of a failed deployment, teams can quickly return to a stable version."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Common rollback strategies:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Rollback to a stable tag or commit:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "check out a previous release tag:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git checkout v1.2.3"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "redeploy that version of the code." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Using git revert:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "creates a new commit that undoes a faulty one:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git revert <commit_hash>"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "safe for main branches without rewriting history."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "CI/CD-based rollback:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "deployments are typically triggered from tags or main;"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "pipelines can redeploy the previous tag automatically."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Blue-Green or Canary deployments:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Git acts as the single source of truth for code versions;"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "rollback is done by switching traffic to the previous version."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Key idea: Git allows instant reproduction of any previous code state, making rollbacks fast, controlled, and reliable."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "90. Jak Git jest wykorzystywany do cofania zmian po nieudanym wdrożeniu?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git umożliwia bezpieczny i przewidywalny rollback, ponieważ każdy release jest powiązany z konkretnym commitem lub tagiem. W razie nieudanego wdrożenia można szybko wrócić do stabilnej wersji."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Najczęstsze strategie rollbacku:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Powrót do stabilnego tagu lub commita:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "przełączenie na poprzedni tag release:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git checkout v1.2.3"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "ponowne wdrożenie tej wersji." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Użycie git revert:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "tworzy nowy commit cofający błędne zmiany:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git revert <commit_hash>"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "bezpieczne dla gałęzi main bez przepisywania historii."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Rollback w CI/CD:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "wdrożenia uruchamiane są z tagów lub main;"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "pipeline może automatycznie wdrożyć poprzedni tag."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Blue-Green lub Canary deployment:" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Git jest źródłem prawdy dla wersji kodu;" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "rollback polega na przełączeniu ruchu na poprzednią wersję."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Kluczowa idea: Git pozwala natychmiast odtworzyć dowolny wcześniejszy stan kodu, dzięki czemu rollback jest szybki i bezpieczny."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 91,
    "translations": {
      "uk": {
        "question": "91. Як налаштувати та інтегрувати Git у сучасне IDE для зручної роботи?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Сучасні IDE мають вбудовану або розширювану інтеграцію з Git, що дозволяє виконувати більшість Git-операцій безпосередньо з інтерфейсу редактора."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Підтримка Git у популярних IDE:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "VS Code", "code": true },
                  {
                    "text": " - вбудований Source Control + розширення GitLens, Git Graph."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "IntelliJ IDEA / WebStorm", "code": true },
                  { "text": " - повна інтеграція через VCS." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Visual Studio", "code": true },
                  { "text": " - Git Tools / Team Explorer." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні кроки налаштування:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Відкрити або клонувати Git-репозиторій у IDE." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Переконатися, що Git встановлений і доступний у PATH."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Налаштувати ім’я та email Git (глобально або локально)."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Можливості Git в IDE:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "stage / commit / push / pull з UI;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "візуальний diff та blame;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "керування гілками та тегами;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "GUI для вирішення merge-конфліктів;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "інтеграція з Pull Request та Issues." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Інтеграція Git у IDE зменшує кількість перемикань контексту і значно пришвидшує повсякденну розробку."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "91. How can Git be configured and integrated into a modern IDE for efficient work?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Modern IDEs provide built-in or extensible Git integration, allowing developers to perform most version control operations directly from the editor."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git support in popular IDEs:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "VS Code", "code": true },
                  {
                    "text": " - built-in Source Control with extensions like GitLens and Git Graph."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "IntelliJ IDEA / WebStorm", "code": true },
                  { "text": " - full VCS integration." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Visual Studio", "code": true },
                  { "text": " - Git Tools / Team Explorer." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Basic setup steps:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Open or clone a Git repository in the IDE." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Ensure Git is installed and available in PATH." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Configure Git user name and email." }]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Git features inside IDEs:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "stage / commit / push / pull from UI;" }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "visual diff and blame;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "branch and tag management;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "GUI-based merge conflict resolution;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Pull Request and issue integration." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "IDE integration with Git reduces context switching and significantly improves developer productivity."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "91. Jak skonfigurować i zintegrować Git z nowoczesnym IDE?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Nowoczesne IDE oferują wbudowaną lub rozszerzalną integrację z Git, umożliwiając wykonywanie większości operacji bezpośrednio z poziomu edytora."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Obsługa Git w popularnych IDE:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "VS Code", "code": true },
                  {
                    "text": " - wbudowany Source Control + GitLens, Git Graph."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "IntelliJ IDEA / WebStorm", "code": true },
                  { "text": " - pełna integracja VCS." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Visual Studio", "code": true },
                  { "text": " - Git Tools / Team Explorer." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Podstawowe kroki konfiguracji:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Otworzyć lub sklonować repozytorium Git w IDE." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Upewnić się, że Git jest zainstalowany i dostępny w PATH."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Skonfigurować nazwę użytkownika i email Git." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Funkcje Git w IDE:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "stage / commit / push / pull z GUI;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "wizualny diff i blame;" }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "zarządzanie gałęziami i tagami;" }]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "graficzne rozwiązywanie konfliktów merge;" }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "integracja z Pull Requestami i Issues." }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Integracja Git z IDE znacząco przyspiesza pracę i poprawia komfort codziennej pracy programisty."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 92,
    "translations": {
      "uk": {
        "question": "92. Які плюси та мінуси використання GUI для Git у порівнянні з командним рядком?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Переваги GUI для Git:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Візуалізація історії та гілок" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Зручно бачити граф комітів, merge та конфлікти."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Менше помилок у синтаксисі" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Не потрібно запам’ятовувати точні Git-команди."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Швидкість для типових дій" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Stage/commit/branch/revert виконуються через UI."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Інтеграція з IDE та CI/CD" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Статус PR, pipeline та конфлікти видно прямо в IDE."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Недоліки GUI:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Обмежений контроль" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Складні операції (rebase -i, filter-repo) зазвичай простіші в CLI."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Менша прозорість" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "GUI може приховувати реальні Git-операції під капотом."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Продуктивність на великих репозиторіях" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "GUI-інструменти можуть працювати повільніше."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Залежність від конкретного інструменту" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Різні GUI мають різний функціонал і UX." }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "CLI", "code": true },
                  {
                    "text": " - повний контроль, автоматизація, складні сценарії."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GUI", "code": true },
                  { "text": " - зручність, наочність, швидка щоденна робота." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Найкраща практика - комбінувати CLI та GUI залежно від задачі."
                  }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "92. What are the pros and cons of using a Git GUI compared to the command line?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Advantages of Git GUI:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Visual representation of history and branches" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Commit graphs and merges are easier to understand."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Fewer syntax errors" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "No need to memorize complex Git commands."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Fast access to common actions" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Stage, commit, branch, and revert via UI."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "IDE and CI/CD integration" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "PRs, pipelines, and conflicts visible directly in IDE."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Disadvantages of Git GUI:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Limited control" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Advanced operations are often easier in CLI."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Less transparency" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "GUI may hide what Git actually does internally."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Performance issues on large repositories" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Some GUIs slow down with big histories." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Tool dependency" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Different GUIs behave differently." }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Conclusion:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "CLI", "code": true },
                  { "text": " - full control, automation, advanced workflows." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GUI", "code": true },
                  {
                    "text": " - convenience and visualization for daily tasks."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Best practice is to combine both approaches." }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "92. Jakie są zalety i wady korzystania z GUI Git w porównaniu do wiersza poleceń?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zalety GUI Git:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Wizualizacja historii i gałęzi" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Łatwiejsze zrozumienie grafu commitów." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mniej błędów składni" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Brak potrzeby zapamiętywania komend." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Szybki dostęp do typowych operacji" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Stage, commit i merge przez interfejs." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Integracja z IDE i CI/CD" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Widoczność PR i pipeline’ów." }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wady GUI Git:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Ograniczona kontrola" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Zaawansowane operacje łatwiejsze w CLI." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mniejsza przejrzystość" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "GUI może ukrywać szczegóły działania Git."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Problemy z wydajnością" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Duże repozytoria mogą spowalniać GUI." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zależność od narzędzia" },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Różnice między narzędziami GUI." }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wniosek:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "CLI", "code": true },
                  { "text": " - pełna kontrola i automatyzacja." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "GUI", "code": true },
                  { "text": " - wygoda i czytelność." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Najlepsze podejście to łączenie obu metod." }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 93,
    "translations": {
      "uk": {
        "question": "93. Які популярні плагіни та розширення використовують для інтеграції Git у IDE та редакторах коду?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Для VS Code:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitLens - авторство рядків (blame), історія комітів, гілок, інтеграція з Pull Request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git Graph - візуальне дерево гілок і комітів." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Pull Requests and Issues - керування PR та Issues без виходу з редактора."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git History - швидкий перегляд історії змін файлів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Project Manager + Git інтеграція - зручна робота з кількома репозиторіями."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Для JetBrains IDE (IntelliJ, WebStorm, PhpStorm):" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Вбудований Git/VCS - commit, merge, rebase, stash, conflict resolver, history."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitToolBox - інформація про remote-гілки, auto-fetch, підсвітка статусу."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git Flow Integration - підтримка Gitflow без використання CLI."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Для Visual Studio:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git Tools / Team Explorer - базові Git-операції в IDE."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Extension for Visual Studio - інтеграція з GitHub, PR та issues."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Окремі GUI-клієнти:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Sourcetree - безкоштовний Git GUI від Atlassian." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Fork - легкий та швидкий Git GUI для macOS та Windows."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Tower - комерційний Git GUI з розширеним функціоналом."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Порада:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для фронтенд-розробки найпопулярніша комбінація: VS Code + GitLens + Git Graph + GitHub PR."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "93. What popular plugins and extensions are used to integrate Git into IDEs and code editors?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "For VS Code:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitLens - line blame, commit and branch history, PR integration."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git Graph - visual commit and branch graph." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Pull Requests and Issues - manage PRs and issues directly in the editor."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git History - quick access to file and repository history."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Project Manager with Git support - easy multi-repository workflow."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "For JetBrains IDEs (IntelliJ, WebStorm, PhpStorm):" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Built-in Git/VCS - commit, merge, rebase, stash, history, conflict resolution."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitToolBox - remote branch info, auto-fetch, enhanced status indicators."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git Flow Integration - Gitflow workflow without CLI."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "For Visual Studio:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git Tools / Team Explorer - core Git operations inside the IDE."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Extension for Visual Studio - GitHub PR and issue integration."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Standalone Git GUI clients:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Sourcetree - free Git GUI by Atlassian." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Fork - fast and lightweight Git client for macOS and Windows."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Tower - commercial Git client with advanced features."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tip:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "For frontend development, the most common setup is VS Code + GitLens + Git Graph + GitHub PR integration."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "93. Jakie popularne wtyczki i rozszerzenia są używane do integracji Git z IDE i edytorami kodu?",
        "answerBlocks": [
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dla VS Code:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitLens - blame linii, historia commitów i integracja z Pull Request."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git Graph - wizualne drzewo commitów i gałęzi." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Pull Requests and Issues - zarządzanie PR i issue w edytorze."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git History - szybki podgląd historii repozytorium."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Project Manager z integracją Git - praca z wieloma repozytoriami."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [
              { "text": "Dla IDE JetBrains (IntelliJ, WebStorm, PhpStorm):" }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Wbudowany Git/VCS - commit, merge, rebase, stash, historia."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitToolBox - informacje o gałęziach zdalnych, auto-fetch."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Git Flow Integration - obsługa Gitflow bez CLI." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Dla Visual Studio:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Git Tools / Team Explorer - podstawowe operacje Git."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "GitHub Extension for Visual Studio - integracja z GitHub."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Samodzielne klienty GUI:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Sourcetree - darmowy GUI Git od Atlassian." }
                ]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Fork - lekki i szybki klient Git." }]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Tower - komercyjny klient Git z rozbudowanymi funkcjami."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wskazówka:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Najczęściej używany zestaw we frontendzie to VS Code + GitLens + Git Graph + GitHub PR."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 94,
    "translations": {
      "uk": {
        "question": "94. Як вирішувати Git merge конфлікти за допомогою візуальних інструментів?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Використання IDE (VS Code, WebStorm, IntelliJ)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "IDE автоматично відкриває файли з конфліктами та підсвічує їх."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "<<<<<<< HEAD - ваші локальні зміни" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "======= - роздільник конфлікту" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": ">>>>>>> feature-branch - зміни з іншої гілки"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Кнопки керування конфліктами:",
                            "bold": true
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Accept Current Change - залишити вашу версію"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Accept Incoming Change - прийняти зміни з іншої гілки"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Accept Both Changes - об’єднати обидві версії"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Compare Changes - перегляд side-by-side для точного аналізу"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Використання Git GUI-клієнтів", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Sourcetree, Fork, GitKraken" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Графічне відображення конфліктів і гілок" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Зручне об’єднання змін через UI" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Після вирішення - Mark as Resolved" }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Завершення merge після вирішення конфліктів:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <resolved_file>\ngit commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Порада:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Візуальні інструменти особливо корисні для JSX, CSS та JSON-файлів."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Для складних конфліктів поєднання IDE + GUI-клієнта дає максимальну наочність."
                  }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "94. How can Git merge conflicts be resolved using visual tools?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Using IDEs (VS Code, WebStorm, IntelliJ)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "The IDE highlights conflicting files automatically."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "<<<<<<< HEAD - your local changes" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "======= - conflict separator" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": ">>>>>>> feature-branch - incoming branch changes"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Visual conflict resolution actions:",
                            "bold": true
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Accept Current Change" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Accept Incoming Change" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Accept Both Changes" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Compare Changes (side-by-side view)" }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Using Git GUI clients", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Sourcetree, Fork, GitKraken" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Graphical conflict tree and visual diffs" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Easy conflict resolution via UI controls" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Finalize with Mark as Resolved" }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Finalize the merge:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <resolved_file>\ngit commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Tip:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Visual tools are especially useful for JSX, CSS and JSON conflicts."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "For complex merges, combining IDE tools with a Git GUI gives the best clarity."
                  }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "94. Jak rozwiązywać konflikty merge w Git przy użyciu narzędzi wizualnych?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Korzystanie z IDE (VS Code, WebStorm, IntelliJ)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "IDE automatycznie podświetla pliki z konfliktami."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "<<<<<<< HEAD - twoje lokalne zmiany" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "======= - separator konfliktu" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": ">>>>>>> feature-branch - zmiany z innej gałęzi"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Akcje wizualne:", "bold": true }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Accept Current Change" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Accept Incoming Change" }]
                      },
                      {
                        "type": "listItem",
                        "children": [{ "text": "Accept Both Changes" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Compare Changes (widok side-by-side)" }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Korzystanie z klientów GUI Git", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [{ "text": "Sourcetree, Fork, GitKraken" }]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Graficzne drzewo konfliktów i różnic" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Łatwe łączenie zmian przez interfejs" }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Zakończenie przez Mark as Resolved" }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Zakończenie merge:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git add <resolved_file>\ngit commit"
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wskazówka:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Narzędzia wizualne są szczególnie przydatne przy konfliktach w JSX, CSS i JSON."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Dla złożonych konfliktów najlepiej łączyć IDE z klientem GUI Git."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 95,
    "translations": {
      "uk": {
        "question": "95. Що таке Git bridge і яку роль він відіграє у взаємодії з іншими системами контролю версій?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git bridge", "bold": true },
              {
                "text": " - це механізм або набір інструментів, що дозволяє інтегрувати Git з іншими системами контролю версій (SVN, Perforce, Mercurial)."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Він забезпечує двосторонню синхронізацію: розробники можуть працювати у Git, а зміни синхронізуються з іншою VCS, або навпаки."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклади використання:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git-svn - робота з SVN через Git", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Клонування SVN-репозиторію у Git." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Синхронізація комітів між Git і SVN." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Perforce Git Fusion", "bold": true },
                  {
                    "text": " - дозволяє користувачам Git працювати з Perforce як із віддаленим репозиторієм."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mercurial ↔ Git", "bold": true },
                  {
                    "text": " - інструменти для міграції або тимчасової синхронізації між системами."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Перевага:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git bridge дозволяє поступово мігрувати на Git без зупинки розробки та без руйнування існуючих процесів у старих VCS."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "95. What is a Git bridge and what role does it play in interacting with other version control systems?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git bridge", "bold": true },
              {
                "text": " is a mechanism or set of tools that enables Git to integrate with other version control systems such as SVN, Perforce, or Mercurial."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "It provides bidirectional synchronization, allowing developers to work in Git while changes are reflected in the legacy VCS, or vice versa."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Examples:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git-svn", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Clone an SVN repository into Git." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Sync commits between Git and SVN." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Perforce Git Fusion", "bold": true },
                  {
                    "text": " allows Git users to interact with Perforce as a remote repository."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mercurial ↔ Git", "bold": true },
                  {
                    "text": " tools used for migration or temporary synchronization between systems."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Benefit:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git bridges enable gradual migration to Git without disrupting existing workflows or stopping development."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "95. Czym jest Git bridge i jaką rolę odgrywa we współpracy z innymi systemami kontroli wersji?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "Git bridge", "bold": true },
              {
                "text": " to mechanizm lub zestaw narzędzi umożliwiających integrację Git z innymi systemami kontroli wersji, takimi jak SVN, Perforce czy Mercurial."
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Zapewnia dwukierunkową synchronizację, dzięki czemu programiści mogą pracować w Git, a zmiany są odzwierciedlane w starszym systemie VCS lub odwrotnie."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Przykłady:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "git-svn", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Klonowanie repozytorium SVN do Git." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Synchronizacja commitów między Git a SVN."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Perforce Git Fusion", "bold": true },
                  {
                    "text": " umożliwia użytkownikom Git pracę z Perforce jak z repozytorium zdalnym."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Mercurial ↔ Git", "bold": true },
                  {
                    "text": " narzędzia do migracji lub tymczasowej synchronizacji systemów."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Zaleta:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git bridge pozwala zespołom stopniowo przejść na Git bez przerywania istniejących procesów i workflow."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 96,
    "translations": {
      "uk": {
        "question": "96. Як керувати великими бінарними файлами в Git, якщо не використовувати Git LFS?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Ігнорування великих файлів", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Додати файли у .gitignore, щоб не зберігати їх у репозиторії:"
                          }
                        ]
                      },
                    {
                      "type": "listItem",
                      "children": [
                        {
                          "type": "code",
                          "language": "gitignore",
                          "content": "*.mp4\n*.zip\nnode_modules/\ndist/"
                        }
                      ]
                    }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зберігання поза репозиторієм", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Використовувати зовнішні сховища (AWS S3, GCS, Azure Blob)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "CDN або внутрішні файлові сервери." }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "У Git зберігати лише посилання або метадані."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Артефактні репозиторії", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Nexus, Artifactory, Verdaccio для білд-артефактів."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Shallow clone та sparse checkout", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Обмежити завантаження історії або директорій:"
                          }
                        ]
                      },
                    {
                      "type": "listItem",
                      "children": [
                        {
                          "type": "code",
                          "language": "bash",
                          "content": "git clone --depth 1 <repo>\ngit sparse-checkout init --cone\ngit sparse-checkout set src/"
                        }
                      ]
                    }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Без Git LFS великі бінарні файли краще зберігати поза Git, залишаючи в репозиторії лише код і легкі метадані."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "96. How can large binary files be managed in Git without using Git LFS?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Ignore large files", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Add them to .gitignore to prevent tracking."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "External storage", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Use AWS S3, Google Cloud Storage, Azure Blob."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Store only links or references in Git." }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Artifact repositories", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Use Nexus, Artifactory, or similar tools."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Shallow clone and sparse checkout", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Reduce fetched history or directories to improve performance."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Conclusion:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Without Git LFS, large binary files should be stored externally, while Git remains focused on source code and lightweight metadata."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "96. Jak zarządzać dużymi plikami binarnymi w Git bez użycia Git LFS?",
        "answerBlocks": [
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Ignorowanie dużych plików", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Dodanie ich do .gitignore, aby nie były śledzone."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Przechowywanie poza repozytorium", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Użycie zewnętrznych magazynów (AWS S3, GCS, Azure Blob)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "W Git przechowywać jedynie linki lub metadane."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Repozytoria artefaktów", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Nexus, Artifactory do plików binarnych i buildów."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Shallow clone i sparse checkout", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Ograniczenie historii i katalogów dla lepszej wydajności."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Wniosek:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Bez Git LFS duże pliki binarne najlepiej przechowywać poza Git, a repozytorium wykorzystywać głównie do kodu źródłowego."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 97,
    "translations": {
      "uk": {
        "question": "97. Для чого використовується git rebase -i (інтерактивний rebase)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git rebase -i", "code": true },
              {
                "text": " дозволяє інтерактивно змінювати історію комітів у локальній гілці перед її злиттям або пушем."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Основні сценарії використання:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Squash комітів", "bold": true },
                  {
                    "text": " – об’єднання кількох дрібних комітів в один логічний."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Редагування повідомлень", "bold": true },
                  { "text": " – зміна commit message перед merge." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Видалення комітів", "bold": true },
                  {
                    "text": " – повне прибирання непотрібних або помилкових комітів (drop)."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Зміна порядку комітів", "bold": true },
                  { "text": " – упорядкування історії для читабельності." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Приклад:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rebase -i HEAD~3"
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Відкриває останні 3 коміти в редакторі." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Для кожного коміту можна вибрати: pick, squash (s), edit, drop."
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Порада:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Використовувати лише для локальних гілок, які ще не були запушені, щоб не зламати історію команди."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "97. What is git rebase -i (interactive rebase) used for?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git rebase -i", "code": true },
              {
                "text": " allows you to interactively rewrite commit history in a local branch."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Common use cases:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Squashing commits into a single logical commit." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Editing commit messages before merging." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Removing unnecessary or incorrect commits." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Reordering commits to keep history clean." }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Example:" }]
          },
          {
            "type": "code",
            "language": "bash",
            "content": "git rebase -i HEAD~3"
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Use interactive rebase only on local branches that have not been pushed to avoid rewriting shared history."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "97. Do czego służy git rebase -i (interaktywny rebase)?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              { "text": "git rebase -i", "code": true },
              {
                "text": " umożliwia interaktywną modyfikację historii commitów w lokalnej gałęzi."
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Główne zastosowania:" }]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [{ "text": "Łączenie commitów (squash)." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Edycja komunikatów commitów." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Usuwanie zbędnych commitów." }]
              },
              {
                "type": "listItem",
                "children": [{ "text": "Zmiana kolejności commitów." }]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Interaktywny rebase należy stosować tylko na lokalnych gałęziach, aby nie naruszyć wspólnej historii zespołu."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 98,
    "translations": {
      "uk": {
        "question": "98. Як організувати безперервне резервне копіювання репозиторіїв Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Безперервне резервне копіювання Git-репозиторіїв гарантує збереження коду, історії комітів, гілок і тегів у разі збою, помилки або втрати доступу."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Віддалені репозиторії (Remote backup)",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Регулярний push у віддалені репозиторії (GitHub, GitLab, Bitbucket, приватний сервер)."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Дзеркальне копіювання всіх refs:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git remote add backup <backup-repo-url>\ngit push --mirror backup"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Автоматизація (cron / CI/CD)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Налаштувати cron або CI-пайплайн для періодичного mirror-пушу:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "0 2 * * * cd /repo && git fetch origin && git push --mirror backup"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Архівування (git bundle)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Створення повного автономного бекапу:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git bundle create repo.bundle --all"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Відновлення з bundle:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git clone repo.bundle project"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Хмарні сховища", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Резервне копіювання .git директорії у S3, Google Drive, Azure Blob."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Порада:" }]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Для критичних проєктів рекомендовано комбінувати mirror-репозиторій + git bundle та регулярно перевіряти можливість відновлення."
              }
            ]
          }
        ]
      },

      "en": {
        "question": "98. How can continuous backup of Git repositories be organized?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Continuous Git repository backup ensures preservation of code, commit history, branches, and tags in case of failures or data loss."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Remote mirrors", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Push all refs to a secondary remote repository."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Example:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git push --mirror backup"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automation via cron or CI/CD", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Schedule periodic backups using cron or CI pipelines."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Offline backups (git bundle)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Create a self-contained backup file:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git bundle create repo.bundle --all"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Best practice is combining remote mirrors with periodic offline bundles."
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "98. Jak zorganizować ciągłe tworzenie kopii zapasowych repozytoriów Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Ciągłe kopie zapasowe repozytoriów Git zapewniają bezpieczeństwo kodu, historii commitów, gałęzi i tagów."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Repozytoria lustrzane", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Regularne pushowanie wszystkich refs do zapasowego repozytorium."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Automatyzacja (cron / CI)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Cykliczne wykonywanie kopii zapasowych."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Backup offline (git bundle)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Tworzenie przenośnego archiwum repozytorium:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git bundle create repo.bundle --all"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Najlepszym podejściem jest łączenie repozytorium lustrzanego z archiwami offline."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 99,
    "translations": {
      "uk": {
        "question": "99. Як чутливість до регістру впливає на Git і як її контролювати на різних ОС?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git за своєю природою є регістрочутливим до імен файлів, але фактична поведінка залежить від файлової системи операційної системи."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Чутливість Git до регістру", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "file.txt і File.txt у Git вважаються різними файлами."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "На деяких ОС це може призводити до прихованих конфліктів."
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "ОС" }],
              [{ "text": "Файлова система" }],
              [{ "text": "Типова проблема" }]
            ],
            "rows": [
              [
                [{ "text": "Linux" }],
                [{ "text": "case-sensitive" }],
                [{ "text": "Проблем зазвичай немає" }]
              ],
              [
                [{ "text": "macOS" }],
                [{ "text": "case-insensitive (HFS+/APFS)" }],
                [{ "text": "Git може не бачити зміну регістру" }]
              ],
              [
                [{ "text": "Windows" }],
                [{ "text": "case-insensitive (NTFS)" }],
                [{ "text": "Конфлікти з Linux/CI-серверами" }]
              ]
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Контроль поведінки", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Налаштування core.ignorecase:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git config core.ignorecase true   # типово для Windows/macOS\ngit config core.ignorecase false  # рекомендовано для Linux/CI"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Зміна регістру імені файлу через проміжний крок:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git mv File.txt temp.txt\ngit mv temp.txt file.txt\ngit commit -m \"Fix filename case\""
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Для кросплатформових проєктів регістрочутливість є критичною."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Рекомендовано уніфікувати неймінг файлів (lowercase) і орієнтуватись на Linux/CI як джерело істини."
                  }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "99. How does case sensitivity affect Git and how can it be controlled across different operating systems?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git is inherently case-sensitive, but actual behavior depends on the underlying file system of the operating system."
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "OS" }],
              [{ "text": "File system" }],
              [{ "text": "Common issue" }]
            ],
            "rows": [
              [
                [{ "text": "Linux" }],
                [{ "text": "case-sensitive" }],
                [{ "text": "Works as expected" }]
              ],
              [
                [{ "text": "macOS" }],
                [{ "text": "case-insensitive" }],
                [{ "text": "Case-only renames may be ignored" }]
              ],
              [
                [{ "text": "Windows" }],
                [{ "text": "case-insensitive" }],
                [{ "text": "Conflicts with Linux-based CI" }]
              ]
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Control using core.ignorecase configuration:" },
                  {
                    "type": "code",
                    "language": "bash",
                    "content": "git config core.ignorecase true\ngit config core.ignorecase false"
                  }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "99. Jak wrażliwość na wielkość liter wpływa na Git i jak ją kontrolować na różnych systemach?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Git jest wrażliwy na wielkość liter, ale zachowanie zależy od systemu plików systemu operacyjnego."
              }
            ]
          },
          {
            "type": "table",
            "header": [
              [{ "text": "System" }],
              [{ "text": "System plików" }],
              [{ "text": "Problem" }]
            ],
            "rows": [
              [
                [{ "text": "Linux" }],
                [{ "text": "case-sensitive" }],
                [{ "text": "Brak problemów" }]
              ],
              [
                [{ "text": "macOS" }],
                [{ "text": "case-insensitive" }],
                [{ "text": "Zmiany wielkości liter mogą być ignorowane" }]
              ],
              [
                [{ "text": "Windows" }],
                [{ "text": "case-insensitive" }],
                [{ "text": "Konflikty z CI/Linux" }]
              ]
            ]
          },
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Najlepszą praktyką jest stosowanie jednolitego nazewnictwa plików oraz dostosowanie core.ignorecase do środowiska CI."
              }
            ]
          }
        ]
      }
    }
  },
  {
    "category": "git",
    "order": 100,
    "translations": {
      "uk": {
        "question": "100. Як організувати підтримку кількох версій продукту за допомогою Git-гілок?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Підтримка кількох версій продукту в Git базується на чіткій стратегії гілок, яка дозволяє паралельно розвивати нові функції та підтримувати старі релізи."
              }
            ]
          },
          {
            "type": "numberedList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "Основна гілка (main / master)", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Містить стабільний код, готовий до продакшен-деплою."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Зазвичай кожен merge у main відповідає релізу або hotfix."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Release-гілки для підтримуваних версій",
                    "bold": true
                  },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Для кожної версії створюється окрема гілка:"
                          },
                          {
                            "type": "code",
                            "language": "text",
                            "content": "release/1.0\nrelease/1.1\nrelease/2.0"
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "У цих гілках дозволені лише багфікси та security-патчі."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Feature-гілки", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Створюються від main або develop для нових фіч."
                          }
                        ]
                      },
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Ніколи напряму не вливаються у release-гілки."
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Backport змін", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          {
                            "text": "Критичні багфікси можна переносити у старі версії:"
                          },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git checkout release/1.0\ngit cherry-pick <commit_hash>"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Тегування релізів", "bold": true },
                  {
                    "type": "bulletList",
                    "children": [
                      {
                        "type": "listItem",
                        "children": [
                          { "text": "Кожен реліз фіксується тегом:" },
                          {
                            "type": "code",
                            "language": "bash",
                            "content": "git tag -a v1.0.0 -m \"Release 1.0.0\"\ngit push origin v1.0.0"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "type": "heading",
            "level": 4,
            "children": [{ "text": "Висновок:" }]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Release-гілки дозволяють підтримувати кілька версій паралельно без блокування розробки."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Теги гарантують швидкий rollback і відтворюваність релізів."
                  }
                ]
              }
            ]
          }
        ]
      },

      "en": {
        "question": "100. How can multiple product versions be maintained using Git branches?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Supporting multiple product versions in Git relies on a clear branching strategy that separates active development from long-term maintenance."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main/master holds production-ready code." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "release/* branches maintain supported versions with bugfixes only."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "feature branches are used for new functionality." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Critical fixes can be backported using cherry-pick."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Tags mark every stable release for rollback and deployment."
                  }
                ]
              }
            ]
          }
        ]
      },

      "pl": {
        "question": "100. Jak organizować wsparcie wielu wersji produktu za pomocą gałęzi Git?",
        "answerBlocks": [
          {
            "type": "paragraph",
            "children": [
              {
                "text": "Obsługa wielu wersji produktu w Git opiera się na strategii gałęzi oddzielającej rozwój od utrzymania."
              }
            ]
          },
          {
            "type": "bulletList",
            "children": [
              {
                "type": "listItem",
                "children": [
                  { "text": "main/master zawiera stabilny kod produkcyjny." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Gałęzie release/* służą do utrzymania starszych wersji."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  { "text": "Nowe funkcje rozwijane są w gałęziach feature." }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Poprawki można przenosić do starszych wersji przez cherry-pick."
                  }
                ]
              },
              {
                "type": "listItem",
                "children": [
                  {
                    "text": "Tagi umożliwiają szybki rollback i identyfikację wersji."
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  }
]
